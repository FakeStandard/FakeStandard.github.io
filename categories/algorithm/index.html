<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algorithm | How can I help</title>
<meta name="keywords" content="" />
<meta name="description" content="不專業代碼">
<meta name="author" content="Polar Bear">
<link rel="canonical" href="https://fakestandard.github.io/categories/algorithm/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d1b405b7c6bf1b09aebca33eb6e2d8bd070113d119bdfa2715c32f6408f9fbee.css" integrity="sha256-0bQFt8a/GwmuvKM&#43;tuLYvQcBE9EZvfonFcMvZAj5&#43;&#43;4=" rel="preload stylesheet" as="style">


<script data-ad-client="ca-pub-4877674098686024" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<meta name="google-site-verification" content="iCWzIE4kN0sAVM_Slr-q8E5zIT2Qfs-IxUuxhpFVD94" />







<link rel="icon" href="https://fakestandard.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fakestandard.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fakestandard.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fakestandard.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fakestandard.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.81.0" />
<link rel="alternate" type="application/rss+xml" href="https://fakestandard.github.io/categories/algorithm/index.xml">
<meta property="og:title" content="Algorithm" />
<meta property="og:description" content="不專業代碼" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fakestandard.github.io/categories/algorithm/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm"/>
<meta name="twitter:description" content="不專業代碼"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fakestandard.github.io/" accesskey="h" title="How can I help (Alt + H)">How can I help</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fakestandard.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/algorithm/" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/netcore/" title=".NET Core">
                    <span>.NET Core</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://fakestandard.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://fakestandard.github.io/categories/">Categories</a></div>
  <h1>Algorithm</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元排序樹在先前的文章都已經有實作過，一顆符合規定的二元樹，也就是二元排序樹，必須符合以下規則
 第一個輸入的值作為二元樹的樹根 逐一將後續的資料與樹根進行比較，大於樹根的資料放置右子樹，小於樹根的資料放置左子樹，以遞迴的方式進行比較，直到資料找到一個空節點可以放置。  假設有一陣列 12, 46, 10, 23, 11, 30, 7, 21，欲對此陣列建立二元排序樹，先將地一個元素作為樹根
接著取得第二個元素，與樹根作比較，因元素 46 大於樹根 12，故放置於右子樹
繼續取得第三個元素，與樹根作比較，因元素 10 小於樹根 12，故放置於左子樹
取得第四個元素，與樹根作比較，元素 23 大於樹根 12，故放置於右子樹，但右子樹已經存在 46 這個節點，所以繼續將元素 23 與右子樹根節點 46 進行比較，最後元素 23 小於 46，故放置於左子樹中。
使用此方式繼續將所有資料在樹中進行比較，欲到已被佔位的節點，就繼續比較，最後形成一顆二元排序樹。
實作程式碼的部分也相當簡單，先前也實作過很多遍，透過遞迴的方式進行比較，值到有空節點為止。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this....</p>
  </section>
  <footer class="entry-footer">August 20, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）" href="https://fakestandard.github.io/algorithm/algorithm-41-binarysorttree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹插入與刪除節點</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 這篇文章會紀錄節點插入與刪除的原理與應用
節點插入 在二元樹中節點插入非常簡單，利用先前學到的走訪與搜尋，先對二元樹進行走訪搜尋，若搜尋時發現樹中已存在相同值，則節點插入失敗，若樹中沒有找到值，才執行節點插入。
依據先前實作過的樹，逐一建立樹節點類別、二元樹類別，二元樹類別中至少需具有新增節點方法與搜尋節點方法，方能執行節點插入。在類別中額外添加前序走訪方法，供後續輸出二元樹節點使用。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } /// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array.Length; i&#43;&#43;) AddNode(array[i]); } public void AddNode(int value) { if (root == null) { root = new TreeNode(value); return; } TreeNode current = root; while (true) { if (value &gt; current....</p>
  </section>
  <footer class="entry-footer">August 17, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹插入與刪除節點" href="https://fakestandard.github.io/algorithm/algorithm-40-binarytreeinsertanddelete/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元搜尋樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元搜尋樹其實就是在樹中搜尋指定的值，只是二元搜尋樹必須符合以下特性
 可以是空集合，若非空集合，則節點上必須有一個鍵值 每個樹根的值須大於左子樹的值 每個樹根的值必須小於右子樹的值 左右子樹也同是二元搜尋樹 樹的每個節點值都不相同  那要如何搜尋？其實很簡單，只需在二元樹中比較樹節點值和欲搜尋的值，依序由左子樹→樹根→右子樹的順序進行走訪，直到找到值或搜尋完畢為止。
實作程式碼，先建立樹節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹類別，下一步實作搜尋方法
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 13, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元搜尋樹" href="https://fakestandard.github.io/algorithm/algorithm-39-binarysearchtree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹走訪</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 對於線性結構的陣列和串列而言，只能執行單向的走訪，如從頭到尾或反向走訪，而二元樹的走訪即是訪問樹中所有節點一次，並且在走訪後，將樹中的資料傳換成線性關係。
二元樹走訪方式有三種，以樹根訪問的順序作為區分，分別是
 前序走訪（Preorder Traversal）：樹根→左子樹→右子樹 中序走訪（Inorder Traversal）：左子樹→樹根→右子樹 後序走訪（Postorder Traversal）：左子樹→右子樹→樹根  從上可以明顯知道，先訪問樹根的稱為前序走訪，後訪問樹根稱為後續走訪，而樹根訪問順序在中間稱為中序走訪，非常的好記。
前序走訪 前序走訪的順序是由上往下進行訪問，從樹根開始，接著往左方移動走訪左子樹，若無法再繼續前進時，則往右方移動訪問右子樹，重複此步驟直到訪問完成。
以上圖為例，訪問的順序是 A→B→D→F→G→H→I→E→C
中序走訪 中序走訪的順序，是從樹根左側開始向下移動，直到無法移動時，追蹤此節點，再往右側移動，若右側無法再移動時，則返回上層父節點，重複左中右的順序進行訪問。
以上圖為例，訪問的順序是 F→D→H→G→I→B→E→A→C
後序走訪 後序走訪的順序，從左子樹開始，接著在往右子樹，最後訪問樹根，因樹根是最後訪問，訪問的方向是由下往上，與前序稍微不同的感覺。
以上圖為例，訪問的順序是 F→H→I→G→D→E→B→C→A
實作程式碼時間，分別為三種走訪方式設計方法，讓以串列表示的二元樹，可以分別輸出前序、中序和後序走訪的結果
建立樹的節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹的類別，其中前序、中序和後續走訪方法在下一步實作
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 9, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹走訪" href="https://fakestandard.github.io/algorithm/algorithm-38-binarytreetraversal/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—串列實作二元樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以串列來表示二元樹，假設有一顆樹，如下
該如何使用串列來表示？
使用鏈結串列來表示二元樹的優點，是在新增和刪除節點時非常容易，缺點則是不容易找到父節點。在使用陣列儲存歪斜樹時，會造成許多的空間被浪費，對於歪斜樹來說，使用串列儲存較為節省空間。
根據上一篇的慘痛經驗，這篇偷偷將樹的值改了一個，讓樹高只維持在 4，上一篇做到 5 層，可真是毅力與耐力的考驗。
首先，先了解一下要如何使用串列來表示二元樹，在先前學過的串列，都具有一個資料欄和指標欄，指標欄存放著下一個節點的記憶體位置，作為節點與節點之間的連結，透過指標的特性，我們將指標欄設置為兩個，分別為左指標與右指標，左指標存放左子樹的節點位址，右指標存放右子樹的節點位址，如下圖所示
使用一個陣列先將樹的節點值儲存起來
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。
在使用串列表示二元樹時，也必須符合二元樹的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值，最後以串列表示的方式如下
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 31, 23, 11, 30, 7, 10 }，按照二元樹的定義，形成一顆以串列表示的完整二元樹。
先建立樹節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { // 值  public int data; // 左子樹  public TreeNode leftNode; // 右子樹  public TreeNode rightNode; public TreeNode(int value) { this....</p>
  </section>
  <footer class="entry-footer">August 5, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—串列實作二元樹" href="https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—陣列實作二元樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以陣列來表示二元樹，假設有一顆樹，如下
該如何使用陣列來表示？
首先，我們可以先想像這是一顆完整二元樹，從樹根開始，依序由左到右、上到下編號，對於空的樹葉依然給它編號，但元素依然為空，如下
準備一個一維陣列，陣列大小為完滿二元樹的最大編號加一，以上圖來說最大編號是 15，其陣列大小為 15&#43;1，因為陣列首將不放任何元素，如下
依照前述的編號，將編號的樹葉值填入相對應的陣列位置
如此一來就完成使用陣列表示樹的方法，不過這個例子不能是一顆二元樹，因為它並不符合上述的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。
為了要讓它成為一顆符合定義個二元樹，先把這顆樹的值都取出來，存放於一個陣列中
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。如下
繼續將剩下的陣列元素，逐一放入完整二元樹中，其放置過程中必須符合樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。最後完成一顆符合規定的二元樹（例子又沒開好QQ）
接著為二元樹編上編號，再將完滿二元樹轉換成陣列表示法，大功造成！
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 10, 23, 11, 30, 7, 31 }，按照二元樹的定義，形成一顆以陣列表示的完整二元樹
static void Main(string[] args) { int i, j; // 原始陣列  int[] data = { 12, 46, 10, 23, 11, 30, 7, 31 }; int[] btree = new int[32]; for (i = 0; i &lt; btree....</p>
  </section>
  <footer class="entry-footer">August 2, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—陣列實作二元樹" href="https://fakestandard.github.io/algorithm/algorithm-36-arrayimplementationoftree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】鏈結串列應用—單向串列反轉演算法</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 學會串列插入、刪除和連結的基本功之後，這篇要來思考如何反轉串列？反轉串列顧名思義就是將串列內的元素都顛倒過來，最後形成頂端節點變成末端節點，而末端節點成為頂端節點，但是串列指標只能知道下一個節點的位置，無法得知上一個節點，那該如何做？這就需要一點小技巧，直接實作程式碼
/// &lt;summary&gt; /// 節點類別 /// &lt;/summary&gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } /// &lt;summary&gt; /// 鏈結串列類別 /// &lt;/summary&gt; class LinkedList { public Node first; public Node last; public bool IsEmpty() { return first == null; } public void Print() { Node current = first; while (current != null) { Write($&#34;[{current....</p>
  </section>
  <footer class="entry-footer">July 29, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】鏈結串列應用—單向串列反轉演算法" href="https://fakestandard.github.io/algorithm/algorithm-35-linkedlistreverse/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】鏈結串列應用—單向串列刪除節點演算法</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 以單向的鏈結串列來說，欲串列中的節點，可刪除的位置與插入節點相同會有三種
  刪除串列的第一個節點
第一個節點刪除後，第二個節點會成為頂端節點，只需將頂端節點指給第二個節點
  刪除串列的最後一個節點
最後一個節點刪除後，倒數第二個節點會成為末端節點，只需將末端節點指標只給倒數第二個節點
  從串列中刪除其中一個中間節點
將欲刪除節點的前一個節點指標，指給欲刪除節點的下一個節點即可
  實作串列刪除節點程式碼，先建立節點類別，類別內包含資料欄與指標欄，每當新節點建立時，新節點資料欄必須帶有值，而指標欄先指向 NULL，等待後續將指標指向特定節點作業。
/// &lt;summary&gt; /// 節點類別 /// &lt;/summary&gt; class Node { // 資料欄  public int data; // 指標欄  public Node next; /// &lt;summary&gt;  /// 帶有一個資料的建構子  /// &lt;/summary&gt;  /// &lt;param name=&#34;data&#34;&gt;&lt;/param&gt;  public Node(int data) { this.data = data; this.next = null; } } 建立鏈結串列類別，串列類別需包含頂端節點和末端節點屬性，類別內再建立一個輸出當前串列的方法，以及判斷當前陣列是否為空，若沒有頂端節點則該串列為空。另外再建立兩個方法，一個是 Insert 用於插入新節點，一個是 Delete 用於刪除節點，下一步將實作這兩個方法。...</p>
  </section>
  <footer class="entry-footer">July 26, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】鏈結串列應用—單向串列刪除節點演算法" href="https://fakestandard.github.io/algorithm/algorithm-34-linkedlistdelete/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】鏈結串列應用—單向串列插入節點與連結兩串列演算法</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 以單向的鏈結串列來說，欲插入新節點到現有的串列，有三種位置可以插入
  插入於第一個節點之前
新節點成為串列的首節點，作法是將新節點的指標指向串列原來的第一個節點，再把串列的指標首指向新節點
  插入於最後一個節點之後
新節點成為串列的末節點，只需要將串列的最後一個節點指標指向新節點，新節點再指向 NULL 即可
  插入於串列中間的位置
假設插入於 A.B 節點之間，將 A 節點的指標指向新節點，新節點的指標再指向 B 節點即可
  實作串列插入節點程式碼，先建立節點類別，類別內包含資料欄與指標欄，每當新節點建立時，新節點資料欄必須帶有值，而指標欄先指向 NULL，等待後續將指標指向特定節點作業。
/// &lt;summary&gt; /// 節點類別 /// &lt;/summary&gt; class Node { // 資料欄  public int data; // 指標欄  public Node next; /// &lt;summary&gt;  /// 帶有一個資料的建構子  /// &lt;/summary&gt;  /// &lt;param name=&#34;data&#34;&gt;&lt;/param&gt;  public Node(int data) { this.data = data; this....</p>
  </section>
  <footer class="entry-footer">July 24, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】鏈結串列應用—單向串列插入節點與連結兩串列演算法" href="https://fakestandard.github.io/algorithm/algorithm-33-linkedlistinsertandconcatenation/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】陣列應用—多項式陣列表示法</h2>
  </header>
  <section class="entry-content">
    <p>【5/26 閱讀紀錄】
根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 多項式在數學中是相當重要的表現方式，先複習一下多項式
以上面的公式來看，我們可以稱 P(x) 是一個 n 次多項式，n 代表該多項式中最大的指數。那麼如何用資料結構的陣列來表示多項式？其實很簡單，方法有兩種
  使用一個 n&#43;2 大小的一維陣列來存放多項式相關的數值，首先陣列的第一個位置儲存 n，後續的位置儲存各指數相對應的係數。舉例 以上述公式來看，n 是最大指數 4，故陣列大小 n&#43;2 是 6，陣列第一個位置儲存 4，往後陸續儲存相對應的係數 A = { 4, 3, 5, 0, 6, 3 }
 此種方法的優點是在運算過程較方便設計，缺點則是可能會造成空間浪費，在多項式的係數多數為零的情況下，則明顯有空間浪費的疑慮，如下公式。    使用 2m&#43;1 大小的一維陣列來存放指數和係數，m 表示該多項式不為零的項目，首先陣列第一個位置儲存 m，後續位置依序存放項目相對應的係數和指數，例如 以上述公式來看，m 為 4，故陣列大小 2m&#43;1 為 9，將第一個位置存放 4，接著依序存放相對應係數和指數 A = { 9, 3, 4, 5, 3, 6, 1, 3, 0 }
 此方法的優點改善了不必要的記憶體空間浪費，缺點則是設計演算法時會較為複雜，優點與缺點則是與第一種方式完全相反。
   接著使用上述兩種方法來設計兩多項式的加法運算，多項式分別為...</p>
  </section>
  <footer class="entry-footer">July 22, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】陣列應用—多項式陣列表示法" href="https://fakestandard.github.io/algorithm/algorithm-32-polynomial/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://fakestandard.github.io/categories/algorithm/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://fakestandard.github.io/">How can I help</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
