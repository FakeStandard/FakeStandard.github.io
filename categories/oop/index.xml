<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OOP on How can I help</title>
    <link>https://fakestandard.github.io/categories/oop/</link>
    <description>Recent content in OOP on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sat, 07 Aug 2021 16:43:36 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/categories/oop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【OOP】委託與事件（Delegate and Event）</title>
      <link>https://fakestandard.github.io/post/oop/oop-6-delegate-and-event/</link>
      <pubDate>Sat, 07 Aug 2021 16:43:36 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-6-delegate-and-event/</guid>
      <description>Start 接續先前物件導向的紀錄，此篇會紀錄
 委託（Delegate） 事件（Event）  委託（Delegate） 委託是對函數的封裝，可以當作給方法的特徵去指定一個名稱，而委託為一種參考方法的類型，一旦委託分配了方法，委託將與該方法具有完全相同的行為。委託使用 delegate 關鍵字宣告。
事件（Event） 事件則是委託的一種特殊形式，當發生有意義的事情時，事件物件會去處理通知的過程。所以在發生其他類別或物件關注的事情時，類別或物件可透過事件去通知它們。事件使用 event 關鍵字宣告。
假設Swordman為隊長，Thief和Acolyte為隊員，當隊長發現打不過怪物時，選擇逃跑，隊員也跟著逃跑，使用委託和事件，來讓隊員知道什麼時候要跑。
在Swordman宣告委託和事件並加入逃跑方法
// 宣告委託 LeaderRunEventHandler public delegate void LeaderRunEventHandler(); // 宣告事件 Run，事件類型是委託 LeaderRunEventHandler public event LeaderRunEventHandler LeaderRun; public void Run() { Console.WriteLine(&amp;#34;隊長：快跑！&amp;#34;); if (LeaderRun != null) { // 表示執行 Run 方法時，如果 LeaderRun 有註冊事件，則執行 LeaderRun  LeaderRun(); } } 在Thief和Acolyte加入逃跑方法
// 逃跑方法 public void Run() { Console.WriteLine(name + &amp;#34;：隊長跑了！快跑！&amp;#34;); } 將隊員逃跑的方法註冊到隊長的委託中
Swordman swordman = new Swordman(); Thief thief = new Thief(); Acolyte acolyte = new Acolyte(); // 註冊事件到委託中 swordman.</description>
    </item>
    
    <item>
      <title>【OOP】集合與泛型（Collection and Generic）</title>
      <link>https://fakestandard.github.io/post/oop/oop-5-collection-and-generic/</link>
      <pubDate>Sat, 31 Jul 2021 16:27:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-5-collection-and-generic/</guid>
      <description>Start 接續先前物件導向的紀錄，此篇會著重於
 集合（Collection） 泛型（Generic）  集合（Collection） 在介紹三大特性時使用CareerBasic類別的物件陣列，且設置陣列長度為 6，雖然陣列的優點，在記憶體中連續儲存，可以快速地走訪元素，但缺點就是設置長度，必須先知道需要設置多少的長度才夠使用，但若保險的使用把長度設的過大，又會造成記憶體的浪費，設的過小又造成溢出，還有陣列在兩元素間加入元素也較困難。
所以.Net Framework提供用於儲存和檢索專用的類別，統稱為集合。這些類別提供對堆疊、佇列、列比和雜湊表的支持，大多數集合實現了相同的介面：IList，IList介面定義了許多方法，讓類別去實現。
馬上來看最常使用的 ArrayList，命名空間為 System.Collections;
// 宣告集合，也可以直接宣告 ArrayList career; IList career; // 實體化集合物件，無須指定大小 career = new ArrayList(); // 調用 IList 的 Add 方法 career.Add(new Swordman(&amp;#34;離人劍&amp;#34;)); career.Add(new Thief()); career.Add(new Acolyte()); career.Add(new Acolyte(&amp;#34;補不完&amp;#34;)); // 取得集合內元素個數 Console.WriteLine(career.Count.ToString()); // 走訪集合 foreach (CareerBasic item in career) { Console.WriteLine(item.PassiveSkill()); } Console.WriteLine(&amp;#34;=============================&amp;#34;); // 移除集合內指定元素 career.RemoveAt(3); // 再走訪一次 foreach (CareerBasic item in career) { Console.WriteLine(item.PassiveSkill()); } 在調用集合的Add方法時，參數的型別是object，不像陣列已經預先指定資料類型，而在這個範例裡類別本身就是object，假如是其他型別就會有個效能問題。
ArrayList存放值類型的資料時，需要將值類型裝箱為Object物件，使用集合元素時還要執行拆箱，這就帶來了效能耗損，因為在裝箱和拆箱的過程中需要進行大量的運算，當使用集合時也消耗了資源和時間。
裝箱（boxing）—把值類型打包到Object參考類型的一個實體中</description>
    </item>
    
    <item>
      <title>【OOP】重構、抽象和介面（Refactoring、Abstract and Interface）</title>
      <link>https://fakestandard.github.io/post/oop/oop-4-refactoring-abstract-interface/</link>
      <pubDate>Thu, 08 Jul 2021 15:24:41 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-4-refactoring-abstract-interface/</guid>
      <description>Start 接續先前物件導向的紀錄，此篇會著重於下列三部份
 重構（Refactoring） 抽象（Abstract） 介面（Interface）  重構（Refactoring） 重構的概念是將原本重複的地方改寫，使程式碼更精簡且更好維護。
接續前篇的範例，定義一個父類別 CareerBasic，該父類別內有一個虛擬方法可以讓子類別複寫。
/// &amp;lt;summary&amp;gt; /// 職業基礎類別 /// &amp;lt;/summary&amp;gt; class CareerBasic { // something...  /// &amp;lt;summary&amp;gt;  /// 父類別虛擬方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public virtual string PassiveSkill() { return &amp;#34; 使出被動技能： &amp;#34;; } } 定義兩個子類別分別為 Swordman 和 Thief，並繼承 CareerBasic 類別，使其成為父類別。在子類別裡，分別複寫父類別方法 PassiveSkill()
/// &amp;lt;summary&amp;gt; /// 盜賊類別 /// &amp;lt;/summary&amp;gt; class Thief : CareerBasic { // ...  // Thief 複寫 父類別方法  public override string PassiveSkill() { return name + base.</description>
    </item>
    
    <item>
      <title>【OOP】物件導向設計的五大原則</title>
      <link>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</link>
      <pubDate>Tue, 29 Jun 2021 21:47:25 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</guid>
      <description>Start 前篇講解 OOP 的特性卻還沒介紹基本原則，馬上來惡補一下內功心法。
物件導向設計五大原則「SOLID」由羅伯特·C·馬丁在21世紀早期提出，SOLID分別為單一功能原則、開閉原則、里氏替換原則、介面隔離原則、依賴反轉原則。
了解物件導向基本原則及特性，透過不斷練習和思考就可寫出閱讀性、維護性、擴充性高的程式碼，然而開發易維護與擴展的系統也變得不難。
單一職責（Single Responsibility Principle） 對一個類別來說，應該只有一個引起他變化的理由，意為一個類別應只專注做一件事，當類別需要做兩件以上的工作時，就承擔了過多的職責，一旦需變更代碼，耦合度會比一件工作還要高，而當發生錯誤時很難快速定位錯誤原因，間接導致程式碼可閱讀性降低。
開放封閉（Open-Closed Principle） 增加新的代碼來擴充系統，而非修改原本已存在的代碼來擴充新功能。所以在設計類別時對擴充保持開放及對修改保持封閉。若面對需求變化時，有無法封閉的變化，此時就須建立抽象點來隔離那些變化。
里氏替換（Liskov Substitution Principle） 子類別必須可以替換父類別而不影響程式架構。若使用繼承，子類別實作的行為必須與父類別或介面所定義的行為一致，且子類別可完全取代父類別。
介面隔離（Interface Segregation Principle） 抽取相同的功能形成介面，再讓各類別去實作。即針對不同類別開放對應需求的介面，需抽換時只需實作介面類別即可，大量降低耦合度。
依賴反轉（Dependency Inversion Principle） 高階模組不應依賴低階模組，兩者都應依賴在抽象概念上；抽象概念不依賴細節，而細節依賴在抽象概念。模組之間若太過耦合，很容易出現修改A又被迫修改B的情況，若依賴抽象則兩只只要關注自己本身即可。
Reference 【大話設計模式】</description>
    </item>
    
    <item>
      <title>【OOP】物件導向特性—封裝、繼承、多型</title>
      <link>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</link>
      <pubDate>Tue, 22 Jun 2021 20:56:20 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</guid>
      <description>Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。
 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明
 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。
封裝的好處
 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。
static void Main(string[] args) { Swordman swordman = new Swordman(); } /// &amp;lt;summary&amp;gt; /// 封裝類別 /// &amp;lt;/summary&amp;gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。
原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。
/// &amp;lt;summary&amp;gt; /// 盜賊類別 /// &amp;lt;/summary&amp;gt; class Thief { private string name = string.</description>
    </item>
    
    <item>
      <title>【OOP】物件導向基礎概念（Object Oriented Programming）</title>
      <link>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</link>
      <pubDate>Thu, 10 Jun 2021 14:08:57 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</guid>
      <description>Start 物件導向（Object-Oriented Programming），意為針對物件進行程式設計。而學習設計模式前必須先了解物件導向設計，不然難以體會設計模式的魅力。
接下來我們會知道
 類別（Class） 物件（Object） 實體（Instance） 建構式（Constructor） 多載（Overloading） 欄位（Field） 屬性（Property） 修飾詞（Modifiers）  類別（Class） 類別是具有相同「屬性（Attribute）」和 「功能（Method）」的物件之抽象集合。在 C# 中定義類別的關鍵字為 class，類別命名規則為第一個字母為大寫，多個單字命名時各個首字母為大寫。
// 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法使外部可以呼叫，修飾詞用 public  public string Attack() { return &amp;#34;基本攻擊！&amp;#34;; } } 物件（Object） 物件是一個獨立的實體，實體裡包含許多資料，資料彼此之間不會互相影響，每個皆為獨立的資料。物件與類別的關係，最簡單易懂又不抽象的解釋為—物件是類別的實體。
// 宣告一個Swordman 物件，物件名為 swordman Swordman swordman; // 先前建立的 Swordman 類別 class Swordman { ... }  在程式碼的世界裡，萬物皆為物件。
 實體（Instance） 實體就是一個真實的物件。實體化是建立物件的過程，使用 new 關鍵字建立。
// 實體化 swordman 物件 swordman = new Swordman(); 綜合上述介紹的類別、物件和實體，實際演練一次程式碼並觀察結果。 在 Swordman 有一個公開的 Attack 方法，當物件被實體化後，未來就能一直呼叫該方法</description>
    </item>
    
  </channel>
</rss>
