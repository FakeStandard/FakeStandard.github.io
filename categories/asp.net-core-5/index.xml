<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ASP.NET Core 5 on How can I help</title>
    <link>https://fakestandard.github.io/categories/asp.net-core-5/</link>
    <description>Recent content in ASP.NET Core 5 on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 11 Jun 2021 11:10:37 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/categories/asp.net-core-5/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【.NET Core】記錄 Logging</title>
      <link>https://fakestandard.github.io/netcore/netcore5-5-logging/</link>
      <pubDate>Fri, 11 Jun 2021 11:10:37 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-5-logging/</guid>
      <description>【ASP.NET Core 5】
過去在記錄 Log 時，會使用第三方套件來記錄，在 .NET Core 預設就已經將 Logger 注入到 DI 容器，直接使用 ILogger 介面來執行。
Start 此篇會紀錄的部分有以下
 Logging Provider Create Logs Log Level Log EventID Log Message Log Exceptions Configure Logging  Logging Provider Logging Provider 會儲存記錄檔，但 Console 顯示記錄的提供者除外。
在 Program.cs 調用 CreateDefaultBuilder 會新增下列記錄提供者
 Console Debug EventSource EventLog: Windows only  欲 override 由 Host.CreateDefaultBuilder 設置的 logging provider 集合，可呼叫 ClearProviders 移除所有 ILoggerProvider 實例，再加入需要的記錄提供者。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
    <item>
      <title>【.NET Core】靜態檔案 Static Files</title>
      <link>https://fakestandard.github.io/netcore/netcore5-4-staticfiles/</link>
      <pubDate>Sun, 06 Jun 2021 16:17:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-4-staticfiles/</guid>
      <description>【ASP.NET Core 5】
靜態檔案是 HTML、css、image、js 等資源檔案，過去 .NET Framework 可直接被存取，在 ASP.NET Core 中，已不能直接被瀏覽，對於存取有特定的限制。
Start 首先，先了解 Content root 以及 Web root，硬翻成中文為內容根目錄 &amp;amp; Web 根目錄。
Content root（內容根目錄） Content root 預設為專案的根目錄，包含
 裝載應用程式的可執行檔 .exe 組成應用程式的已編譯元件 .dll 應用程式所使用的內容檔案  Razor(.cshtml、.razor) 設定檔(.json、.xml) 資料檔案(.db)   Web 根目錄(Web root)  Web root（Web 根目錄） Web root 為公共靜態資源的基本路徑，預設路徑為 {content root}/wwwroot
 樣式 .css JavaScript .js 影像檔 .png、.jpg  建立一個專案，在方案總管中找到 wwwroot，可看到預設已建立 css、js、lib 資料夾，使用路徑 https://localhost:5000/css/site.css 嘗試讀取 ~/css/site.css 該檔案， 可直接瀏覽檔案內容。
測試自行建立的資料夾是否能存取，在 wwwroot 目錄下建立 images 資料夾以自定義靜態檔案路徑，並放置一張影像檔在該目錄下，嘗試使用 URL https://localhost:5000/images/MyImages.</description>
    </item>
    
    <item>
      <title>【.NET Core】中介軟體 Middleware</title>
      <link>https://fakestandard.github.io/netcore/netcore5-3-middleware/</link>
      <pubDate>Mon, 31 May 2021 14:52:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-3-middleware/</guid>
      <description>【ASP.NET Core 5】
ASP.NET Core 引入一個新概念稱為中介軟體（Middleware），Middleware 會在 ASP.NET Core 應用程式中的每個請求上執行。
過去 ASP.NET 中 HttpHandlers 和 HttpModules 在 ASP.NET Core 已不復存在，更準確地說，它們已成為 Request Pipeline 的一部分，Middleware 類似於 HttpHandlers、HttpModules，都需要在每個請求中進行配置及執行。
Start Middleware 是組成應用程式 Pipeline 的軟體，每個組件可以選擇是否將請求傳遞到管線中的下一個組件，也可以在下一個組件中的前後執行工作。
通常 ASP.NET Core Web 應用程式中有許多 Middleware，它可以是 Framework provided 的中介軟體，也可以通過 NuGet 添加，甚至可以自行定義 Middleware。我們可以在請求管道中設置中介軟體的執行順序，每個中介軟體都會新增或修改 Http 請求，且可選擇將控制權傳遞給下一個中介軟體。
請求委派用於建構請求管道，請求委派會處理每個 Http 請求。該句的原文是這樣
 Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.
 Request delegates 使用 Run、Map 和 Use 三種擴充方法來配置。單個請求委派可以指定嵌入式（in-line）匿名方法，稱為嵌入式中介軟體，也可以在重複使用的類別中進行定義。這些可重用的類別和嵌入式匿名方法就是 middleware ，也稱之為 middleware components。在請求管道中的每個中介軟體元件負責調用 Pipeline 中的下一個元件，或對管線執行最少運算，當中介軟體短路時（short-circult），會阻止接下來的中介軟體處理請求，稱之為終端中介軟體 terminal middleware。</description>
    </item>
    
    <item>
      <title>【.NET Core】相依性注入 Dependency Injection</title>
      <link>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</link>
      <pubDate>Thu, 20 May 2021 15:41:33 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</guid>
      <description>【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&amp;#34;Message:{message}&amp;#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&amp;#34;MyClass get a message&amp;#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。</description>
    </item>
    
    <item>
      <title>【.NET Core】Application Startup Class</title>
      <link>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</link>
      <pubDate>Thu, 13 May 2021 16:23:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</guid>
      <description>【ASP.NET Core 5】
在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。
Start 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup&amp;lt;T&amp;gt; 方法，其中泛型 &amp;lt;T&amp;gt; 預設為 Startup
public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { // 配置啟動類別位置  webBuilder.UseStartup&amp;lt;Startup&amp;gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup&amp;lt;T&amp;gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
  </channel>
</rss>
