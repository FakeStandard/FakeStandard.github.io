<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>NETCores on How can I help</title>
    <link>https://fakestandard.github.io/netcore/</link>
    <description>Recent content in NETCores on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 31 May 2021 14:52:16 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/netcore/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【.NET Core】中介軟體 Middleware</title>
      <link>https://fakestandard.github.io/netcore/netcore5-3-middleware/</link>
      <pubDate>Mon, 31 May 2021 14:52:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-3-middleware/</guid>
      <description>【ASP.NET Core 5】
ASP.NET Core 引入一個新概念稱為中介軟體（Middleware），Middleware 會在 ASP.NET Core 應用程式中的每個請求上執行。
過去 ASP.NET 中 HttpHandlers 和 HttpModules 在 ASP.NET Core 已不復存在，更準確地說，它們已成為 Request Pipeline 的一部分，Middleware 類似於 HttpHandlers、HttpModules，都需要在每個請求中進行配置及執行。
Start Middleware 是組成應用程式 Pipeline 的軟體，每個組件可以選擇是否將請求傳遞到管線中的下一個組件，也可以在下一個組件中的前後執行工作。
通常 ASP.NET Core Web 應用程式中有許多 Middleware，它可以是 Framework provided 的中介軟體，也可以通過 NuGet 添加，甚至可以自行定義 Middleware。我們可以在請求管道中設置中介軟體的執行順序，每個中介軟體都會新增或修改 Http 請求，且可選擇將控制權傳遞給下一個中介軟體。
請求委派用於建構請求管道，請求委派會處理每個 Http 請求。該句的原文是這樣
 Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.
 Request delegates 使用 Run、Map 和 Use 三種擴充方法來配置。單個請求委派可以指定嵌入式（in-line）匿名方法，稱為嵌入式中介軟體，也可以在重複使用的類別中進行定義。這些可重用的類別和嵌入式匿名方法就是 middleware ，也稱之為 middleware components。在請求管道中的每個中介軟體元件負責調用 Pipeline 中的下一個元件，或對管線執行最少運算，當中介軟體短路時（short-circult），會阻止接下來的中介軟體處理請求，稱之為終端中介軟體 terminal middleware。</description>
    </item>
    
    <item>
      <title>【.NET Core】相依性注入 Dependency Injection</title>
      <link>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</link>
      <pubDate>Thu, 20 May 2021 15:41:33 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</guid>
      <description>【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&amp;#34;Message:{message}&amp;#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&amp;#34;MyClass get a message&amp;#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。</description>
    </item>
    
    <item>
      <title>【.NET Core】Application Startup Class</title>
      <link>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</link>
      <pubDate>Thu, 13 May 2021 16:23:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</guid>
      <description>【ASP.NET Core 5】
在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。
Start 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup&amp;lt;T&amp;gt; 方法，其中泛型 &amp;lt;T&amp;gt; 預設為 Startup
public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { // 配置啟動類別位置  webBuilder.UseStartup&amp;lt;Startup&amp;gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup&amp;lt;T&amp;gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
  </channel>
</rss>
