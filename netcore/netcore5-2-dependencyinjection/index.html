<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>【.NET Core】相依性注入 Dependency Injection | How can I help</title>
<meta name="keywords" content="DotNET Core, ASP.NET Core 5, CSharp, DI, Dependency Injection" />
<meta name="description" content="【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&#34;Message:{message}&#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&#34;MyClass get a message&#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。">
<meta name="author" content="Polar Bear">
<link rel="canonical" href="https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d1b405b7c6bf1b09aebca33eb6e2d8bd070113d119bdfa2715c32f6408f9fbee.css" integrity="sha256-0bQFt8a/GwmuvKM&#43;tuLYvQcBE9EZvfonFcMvZAj5&#43;&#43;4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>


<script data-ad-client="ca-pub-4877674098686024" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<meta name="google-site-verification" content="iCWzIE4kN0sAVM_Slr-q8E5zIT2Qfs-IxUuxhpFVD94" />







<link rel="icon" href="https://fakestandard.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fakestandard.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fakestandard.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fakestandard.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fakestandard.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.81.0" />
<meta property="og:title" content="【.NET Core】相依性注入 Dependency Injection" />
<meta property="og:description" content="【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&#34;Message:{message}&#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&#34;MyClass get a message&#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/" /><meta property="article:section" content="NETCore" />
<meta property="article:published_time" content="2021-05-20T15:41:33&#43;08:00" />
<meta property="article:modified_time" content="2021-05-20T15:41:33&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【.NET Core】相依性注入 Dependency Injection"/>
<meta name="twitter:description" content="【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&#34;Message:{message}&#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&#34;MyClass get a message&#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "NETCores",
      "item": "https://fakestandard.github.io/netcore/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "【.NET Core】相依性注入 Dependency Injection",
      "item": "https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【.NET Core】相依性注入 Dependency Injection",
  "name": "【.NET Core】相依性注入 Dependency Injection",
  "description": "【ASP.NET Core 5】\n如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。\nStart 相依性是另一個物件所依賴的物件。\n建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法\npublic class MyDependency { public void WriteMessage(string message) { Console.WriteLine($\u0026#34;Message:{message}\u0026#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。\npublic class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(\u0026#34;MyClass get a message\u0026#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。",
  "keywords": [
    "DotNET Core", "ASP.NET Core 5", "CSharp", "DI", "Dependency Injection"
  ],
  "articleBody": "【ASP.NET Core 5】\n如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。\nStart 相依性是另一個物件所依賴的物件。\n建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法\npublic class MyDependency { public void WriteMessage(string message) { Console.WriteLine($\"Message:{message}\"); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。\npublic class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(\"MyClass get a message\"); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。\n接著透過 DI 容器來切斷彼此間的相依性，首先使用介面或父類別讓相依性資訊抽象化，在內建 Services 容器中註冊依賴類別，服務通常在應用程式中 Startup.ConfigureServices 註冊，最後將服務植入到使用該服務的類別建構式中，DI 容器會負責產生物件實例，直到不需要時會將其釋放。\n建立介面 IMyDependency，並定義 WriteMessage 方法\npublic interface IMyDependency { void WriteMessage(string message); } MyDependency 類別繼承 IMyDependency 且明確實作該介面\npublic class MyDependency : IMyDependency { void IMyDependency.WriteMessage(string message) { Console.WriteLine($\"Message:{message}\"); } } 使用 AddScoped 擴充功能在 Startup.ConfigureServices 中註冊該實作類別，第一個泛型為注入的類型，建議用介面包裝以拆掉相依性，第二個泛型為實作類別。\npublic void ConfigureServices(IServiceCollection services) { // 註冊服務  services.AddScoped(); services.AddControllersWithViews(); } ASP.NET Core 使用 Constructor Injection 將實例化的物件從建構式傳入，要取用已經註冊在 DI 容器的服務物件，只要在建構式加入相對的介面即可。\n回到 MyClass 類別，使用 IMyDependency 介面來改善實作\n 不使用具體類別 MyDependency，改為使用它所執行的 IMyDependency 介面 不會產生 MyDependency 實例，該實例會由 DI 容器建立  public class MyClass { private readonly IMyDependency _myDependency; public MyClass(IMyDependency myDependency) { _myDependency = myDependency; } public void Get() { _myDependency.WriteMessage(\"MyClass get a message\"); } } 如此一來就完成 DI 注入的動作。\nService Lifetime 前面使用 AddScoped 擴充方法註冊服務，除了該擴充方法外，還有其餘可用於註冊的擴充方法，它們用以定義服務的生命週期，待使用完服務時，容器會對注入的服務進行釋放，而選擇適當的生命週期，可以節省記憶體，提升程式效率，反之可能會造成重大的異常錯誤。\n從程式碼可以看到，生命週期有三種列舉值\nnamespace Microsoft.Extensions.DependencyInjection { public enum ServiceLifetime { Singleton = 0, Scoped = 1, Transient = 2 } } Transient  每次向服務容器請求時，都會建立新實例，該生命週期適用於輕量級的無狀態服務。 使用 AddTransient 註冊服務 無論是否為同一客戶端或請求，每次都使用新的實例  Scoped  每個 Client Side 請求時，都會重新建立一個實例，所以同一個請求不管經過多少 Pipeline 都是用同一個實例 使用 AddScoped 註冊服務 不同客戶端使用不同實例，客戶端內不同請求使用同一個實例  Singleton  第一次請求時建立新實例，應用程式運行期間不會消失，也不會再建立 使用 AddSingleton 註冊服務 不同客戶端不同請求都是使用同一個實例   依照 John Wu 文章的實驗，筆者也仿照他的方式，實際測試服務生命週期的差異\n 新增三個介面並繼承 IMyDependency 介面 MyDependency 類別改為繼承上述新增的三個介面  public interface ITransient : IMyDependency { } public interface IScoped : IMyDependency { } public interface ISingleton : IMyDependency { } public class MyDependency : ITransient, IScoped, ISingleton { void IMyDependency.WriteMessage(string message) { Console.WriteLine($\"Message:{message}\"); } } 在 Startup.cs 中註冊三種不同生命週期的服務\npublic void ConfigureServices(IServiceCollection services) { // 註冊生命週期的服務  services.AddTransient(); services.AddScoped(); services.AddSingleton(); services.AddControllersWithViews(); } 在 HomeController 建構子中注入實例及定義 ServiceLifeTime 動作方法\npublic class HomeController : Controller { private readonly ILogger _logger; private readonly ITransient _transient; private readonly IScoped _scoped; private readonly ISingleton _singleton; public HomeController( ITransient transient, IScoped scoped, ISingleton singleton) { _transient = transient; _scoped = scoped; _singleton = singleton; } public IActionResult ServiceLifeTime() { ViewBag.TransientHC = _transient.GetHashCode(); ViewBag.ScopedHC = _scoped.GetHashCode(); ViewBag.SingletonHC = _singleton.GetHashCode(); return View(); } } 繪製 View 呈現的表格\ntable class=\"table\" thead tr tdLifetimetd tdHash Codetd tr thead tbody tr tdTransienttd td@ViewBag.TransientHCtd tr tr tdScopedtd td@ViewBag.ScopedHCtd tr tr tdSingletontd td@ViewBag.SingletonHCtd tr tbody table 實際運行應用程式，在三個瀏覽器同時打開頁面，或者對頁面重新整理，發現 Singleton 的 Hash Code 都是一樣的，驗證了前述所說，只在應用程式啟動時 new 一個新實例，運行期間不會消失，直到應用程式停用才會釋放。\n再修改 View 代碼，使用 @inject 直接在 View 中注入 Service\n@inject ITransient transient @inject IScoped scoped @inject ISingleton singleton ... hr/ table border=\"1\" thead tr tdLifetimetd tdHash Codetd tr thead tbody tr tdTransienttd td@transient.GetHashCode()td tr tr tdScopedtd td@scoped.GetHashCode()td tr tr tdSingletontd td@singleton.GetHashCode()td tr tbody table 啟動應用程式如下圖，在同一個 Client Side 使用不同請求，Scoped 的 Hash Code 並未改變；比較在不同的 Client Side，Scoped 的 Hash Code 也不同。\n最後，自行定義一個服務，並注入上述三個 Service，觀察變化\npublic class MyService { public ITransient Transient { get; private set; } public IScoped Scoped { get; private set; } public ISingleton Singleton { get; private set; } public MyService( ITransient transient, IScoped scoped, ISingleton singleton) { Transient = transient; Scoped = scoped; Singleton = singleton; } } 在 Startup.cs 註冊自定義服務\npublic void ConfigureServices(IServiceCollection services) { ... // 註冊自定義服務  services.AddScoped(); } 使用 @inject 注入到 View\n@inject ITransient transient @inject IScoped scoped @inject ISingleton singleton @inject MyService myService ... hr/ table border=\"1\" thead tr tdLifetimetd tdHash Codetd tr thead tbody tr tdTransienttd td@myService.Transient.GetHashCode()td tr tr tdScopedtd td@myService.Scoped.GetHashCode()td tr tr tdSingletontd td@myService.Singleton.GetHashCode()td tr tbody table 啟動應用程式，觀察不同服務注入，在同一個請求內，對於 Scoped 來說會使用同一個實例；Transient 則是每次請求都重新建立實例，Singleton 在應用程式啟動時建立實例，往後該實例會一直存在並被使用，直到應用程式關閉才將其處置。\nNote 實際了解相依性注入後，發現服務的 Lifetime 很有趣，對於動作的時間點有著更進一步的理解，John Wu 生命週期的實驗，對筆者來說有很大的收穫，動手做果然很有感。\nReference Dependency Injection in ASP.NET Core\nDependency injection in .NET\nASP.NET Core - Dependency Injection\nASP.NET Core 3 系列 - 依賴注入 (Dependency Injection) \n",
  "wordCount" : "579",
  "inLanguage": "en",
  "datePublished": "2021-05-20T15:41:33+08:00",
  "dateModified": "2021-05-20T15:41:33+08:00",
  "author":{
    "@type": "Person",
    "name": "Polar Bear"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "How can I help",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fakestandard.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fakestandard.github.io/" accesskey="h" title="How can I help (Alt + H)">How can I help</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fakestandard.github.io/post/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/algorithm/" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/netcore/" title=".NET Core">
                    <span>.NET Core</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://fakestandard.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://fakestandard.github.io/netcore/">NETCores</a></div>
    <h1 class="post-title">
      【.NET Core】相依性注入 Dependency Injection
    </h1>
    <div class="post-meta">May 20, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear
</div>
  </header> 
  <div class="post-content"><p>【ASP.NET Core 5】</p>
<p>如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。</p>
<h1 id="start">Start<a hidden class="anchor" aria-hidden="true" href="#start">#</a></h1>
<p>相依性是另一個物件所依賴的物件。</p>
<p>建立 <code>MyDependency</code> 類別，內含一個無返回值的 <code>WriteMessage</code> 方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDependency</span>
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> WriteMessage(<span style="color:#66d9ef">string</span> message)
    {
        Console.WriteLine(<span style="color:#e6db74">$&#34;Message:{message}&#34;</span>);
    }
}
</code></pre></div><p>再建一個 <code>MyClass</code> 類別，類別內建立 <code>MyDependency</code> 實例，在 <code>MyClass</code> 內實作無返回值的 <code>Get</code> 方法，該方法內調用 <code>MyDependency</code> 實例的 <code>WriteMessage</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> MyDependency _myDependency = <span style="color:#66d9ef">new</span> MyDependency();

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Get()
    {
        _myDependency.WriteMessage(<span style="color:#e6db74">&#34;MyClass get a message&#34;</span>);
    }
}
</code></pre></div><p>到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，<code>MyClass</code> 物件直接依賴於 <code>MyDependency</code> 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 <code>MyDependency</code>，<code>MyClass</code> 必須修改此類別，再來該實作也難以進行單元測試。</p>
<p>接著透過 DI 容器來切斷彼此間的相依性，首先使用介面或父類別讓相依性資訊抽象化，在內建 Services 容器中註冊依賴類別，服務通常在應用程式中 <code>Startup.ConfigureServices</code> 註冊，最後將服務植入到使用該服務的類別建構式中，DI 容器會負責產生物件實例，直到不需要時會將其釋放。</p>
<p>建立介面 <code>IMyDependency</code>，並定義 <code>WriteMessage</code> 方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IMyDependency
{
    <span style="color:#66d9ef">void</span> WriteMessage(<span style="color:#66d9ef">string</span> message);
}
</code></pre></div><p><code>MyDependency</code> 類別繼承 <code>IMyDependency</code> 且明確實作該介面</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDependency</span> : IMyDependency
{
    <span style="color:#66d9ef">void</span> IMyDependency.WriteMessage(<span style="color:#66d9ef">string</span> message)
    {
        Console.WriteLine(<span style="color:#e6db74">$&#34;Message:{message}&#34;</span>);
    }
}
</code></pre></div><p>使用 <code>AddScoped&lt;&gt;</code> 擴充功能在 <code>Startup.ConfigureServices</code> 中註冊該實作類別，第一個泛型為注入的類型，建議用介面包裝以拆掉相依性，第二個泛型為實作類別。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    <span style="color:#75715e">// 註冊服務
</span><span style="color:#75715e"></span>    services.AddScoped&lt;IMyDependency, MyDependency&gt;();

    services.AddControllersWithViews();
}
</code></pre></div><p>ASP.NET Core 使用 Constructor Injection 將實例化的物件從建構式傳入，要取用已經註冊在 DI 容器的服務物件，只要在建構式加入相對的介面即可。</p>
<p>回到 <code>MyClass</code> 類別，使用 <code>IMyDependency</code> 介面來改善實作</p>
<ul>
<li>不使用具體類別 <code>MyDependency</code>，改為使用它所執行的 <code>IMyDependency</code> 介面</li>
<li>不會產生 <code>MyDependency</code> 實例，該實例會由 DI 容器建立</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IMyDependency _myDependency;

    <span style="color:#66d9ef">public</span> MyClass(IMyDependency myDependency)
    {
        _myDependency = myDependency;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Get()
    {
        _myDependency.WriteMessage(<span style="color:#e6db74">&#34;MyClass get a message&#34;</span>);
    }
}
</code></pre></div><p>如此一來就完成 DI 注入的動作。</p>
<h2 id="service-lifetime">Service Lifetime<a hidden class="anchor" aria-hidden="true" href="#service-lifetime">#</a></h2>
<p>前面使用 <code>AddScoped&lt;&gt;</code> 擴充方法註冊服務，除了該擴充方法外，還有其餘可用於註冊的擴充方法，它們用以定義服務的生命週期，待使用完服務時，容器會對注入的服務進行釋放，而選擇適當的生命週期，可以節省記憶體，提升程式效率，反之可能會造成重大的異常錯誤。</p>
<p>從程式碼可以看到，生命週期有三種列舉值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">namespace</span> Microsoft.Extensions.DependencyInjection
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> ServiceLifetime
    {
        Singleton = <span style="color:#ae81ff">0</span>,
        Scoped = <span style="color:#ae81ff">1</span>,
        Transient = <span style="color:#ae81ff">2</span>
    }
}
</code></pre></div><h3 id="transient">Transient<a hidden class="anchor" aria-hidden="true" href="#transient">#</a></h3>
<ul>
<li>每次向服務容器請求時，都會建立新實例，該生命週期適用於輕量級的無狀態服務。</li>
<li>使用 <code>AddTransient</code> 註冊服務</li>
<li>無論是否為同一客戶端或請求，每次都使用新的實例</li>
</ul>
<h3 id="scoped">Scoped<a hidden class="anchor" aria-hidden="true" href="#scoped">#</a></h3>
<ul>
<li>每個 Client Side 請求時，都會重新建立一個實例，所以同一個請求不管經過多少 Pipeline 都是用同一個實例</li>
<li>使用 <code>AddScoped</code> 註冊服務</li>
<li>不同客戶端使用不同實例，客戶端內不同請求使用同一個實例</li>
</ul>
<h3 id="singleton">Singleton<a hidden class="anchor" aria-hidden="true" href="#singleton">#</a></h3>
<ul>
<li>第一次請求時建立新實例，應用程式運行期間不會消失，也不會再建立</li>
<li>使用 <code>AddSingleton</code> 註冊服務</li>
<li>不同客戶端不同請求都是使用同一個實例</li>
</ul>
<hr>
<p>依照 John Wu 文章的實驗，筆者也仿照他的方式，實際測試服務生命週期的差異</p>
<ul>
<li>新增三個介面並繼承 <code>IMyDependency</code> 介面</li>
<li><code>MyDependency</code> 類別改為繼承上述新增的三個介面</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> ITransient : IMyDependency { }
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IScoped : IMyDependency { }
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> ISingleton : IMyDependency { }

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyDependency</span> : ITransient, IScoped, ISingleton
{
    <span style="color:#66d9ef">void</span> IMyDependency.WriteMessage(<span style="color:#66d9ef">string</span> message)
    {
        Console.WriteLine(<span style="color:#e6db74">$&#34;Message:{message}&#34;</span>);
    }
}
</code></pre></div><p>在 <code>Startup.cs</code> 中註冊三種不同生命週期的服務</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    <span style="color:#75715e">// 註冊生命週期的服務
</span><span style="color:#75715e"></span>    services.AddTransient&lt;ITransient, MyDependency&gt;();
    services.AddScoped&lt;IScoped, MyDependency&gt;();
    services.AddSingleton&lt;ISingleton, MyDependency&gt;();

    services.AddControllersWithViews();
}
</code></pre></div><p>在 <code>HomeController</code> 建構子中注入實例及定義 <code>ServiceLifeTime</code> 動作方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HomeController</span> : Controller
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger&lt;HomeController&gt; _logger;

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ITransient _transient;
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IScoped _scoped;
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ISingleton _singleton;

    <span style="color:#66d9ef">public</span> HomeController(
        ITransient transient,
        IScoped scoped,
        ISingleton singleton)
    {
        _transient = transient;
        _scoped = scoped;
        _singleton = singleton;
    }

    <span style="color:#66d9ef">public</span> IActionResult ServiceLifeTime()
    {
        ViewBag.TransientHC = _transient.GetHashCode();
        ViewBag.ScopedHC = _scoped.GetHashCode();
        ViewBag.SingletonHC = _singleton.GetHashCode();

        <span style="color:#66d9ef">return</span> View();
    }
}
</code></pre></div><p>繪製 View 呈現的表格</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">table</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;table&#34;</span>&gt;
    &lt;<span style="color:#f92672">thead</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Lifetime&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Hash Code&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">thead</span>&gt;
    &lt;<span style="color:#f92672">tbody</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Transient&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@ViewBag.TransientHC&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Scoped&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@ViewBag.ScopedHC&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Singleton&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@ViewBag.SingletonHC&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">tbody</span>&gt;
&lt;/<span style="color:#f92672">table</span>&gt;
</code></pre></div><p>實際運行應用程式，在三個瀏覽器同時打開頁面，或者對頁面重新整理，發現 <code>Singleton</code> 的 Hash Code 都是一樣的，驗證了前述所說，只在應用程式啟動時 <code>new</code> 一個新實例，運行期間不會消失，直到應用程式停用才會釋放。</p>
<p><img loading="lazy" src="../../images/NetCore/NetCore001.png" alt=""  />
</p>
<p>再修改 View 代碼，使用 <code>@inject</code> 直接在 View 中注入 Service</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">@inject ITransient transient
@inject IScoped scoped
@inject ISingleton singleton

...

&lt;<span style="color:#f92672">hr</span>/&gt;

&lt;<span style="color:#f92672">table</span> <span style="color:#a6e22e">border</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>&gt;
    &lt;<span style="color:#f92672">thead</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Lifetime&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Hash Code&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">thead</span>&gt;
    &lt;<span style="color:#f92672">tbody</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Transient&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@transient.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Scoped&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@scoped.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Singleton&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@singleton.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">tbody</span>&gt;
&lt;/<span style="color:#f92672">table</span>&gt;
</code></pre></div><p>啟動應用程式如下圖，在同一個 Client Side 使用不同請求，<code>Scoped</code> 的 Hash Code 並未改變；比較在不同的 Client Side，<code>Scoped</code> 的 Hash Code 也不同。</p>
<p><img loading="lazy" src="../../images/NetCore/NetCore002.png" alt=""  />
</p>
<p>最後，自行定義一個服務，並注入上述三個 Service，觀察變化</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyService</span>
{
    <span style="color:#66d9ef">public</span> ITransient Transient { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
    <span style="color:#66d9ef">public</span> IScoped Scoped { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
    <span style="color:#66d9ef">public</span> ISingleton Singleton { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> MyService(
        ITransient transient, 
        IScoped scoped, 
        ISingleton singleton)
    {
        Transient = transient;
        Scoped = scoped;
        Singleton = singleton;
    }
}
</code></pre></div><p>在 <code>Startup.cs</code> 註冊自定義服務</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-CSharp" data-lang="CSharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    ...

    <span style="color:#75715e">// 註冊自定義服務
</span><span style="color:#75715e"></span>    services.AddScoped&lt;MyService, MyService&gt;();
}
</code></pre></div><p>使用 <code>@inject</code> 注入到 View</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">@inject ITransient transient
@inject IScoped scoped
@inject ISingleton singleton

@inject MyService myService

...

&lt;<span style="color:#f92672">hr</span>/&gt;

&lt;<span style="color:#f92672">table</span> <span style="color:#a6e22e">border</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>&gt;
    &lt;<span style="color:#f92672">thead</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Lifetime&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Hash Code&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">thead</span>&gt;
    &lt;<span style="color:#f92672">tbody</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Transient&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@myService.Transient.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Scoped&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@myService.Scoped.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
        &lt;<span style="color:#f92672">tr</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;Singleton&lt;/<span style="color:#f92672">td</span>&gt;
            &lt;<span style="color:#f92672">td</span>&gt;@myService.Singleton.GetHashCode()&lt;/<span style="color:#f92672">td</span>&gt;
        &lt;/<span style="color:#f92672">tr</span>&gt;
    &lt;/<span style="color:#f92672">tbody</span>&gt;
&lt;/<span style="color:#f92672">table</span>&gt;
</code></pre></div><p>啟動應用程式，觀察不同服務注入，在同一個請求內，對於 <code>Scoped</code> 來說會使用同一個實例；<code>Transient</code> 則是每次請求都重新建立實例，<code>Singleton</code> 在應用程式啟動時建立實例，往後該實例會一直存在並被使用，直到應用程式關閉才將其處置。</p>
<h1 id="note">Note<a hidden class="anchor" aria-hidden="true" href="#note">#</a></h1>
<p>實際了解相依性注入後，發現服務的 Lifetime 很有趣，對於動作的時間點有著更進一步的理解，John Wu 生命週期的實驗，對筆者來說有很大的收穫，動手做果然很有感。</p>
<h1 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h1>
<p><a href="https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0">Dependency Injection in ASP.NET Core</a></p>
<p><a href="https://docs.microsoft.com/zh-tw/dotnet/core/extensions/dependency-injection#service-lifetimes">Dependency injection in .NET</a></p>
<p><a href="https://www.tutorialsteacher.com/core/dependency-injection-in-aspnet-core">ASP.NET Core - Dependency Injection</a></p>
<p><a href="https://blog.johnwu.cc/article/asp-net-core-3-dependency-injection.html">ASP.NET Core 3 系列 - 依賴注入 (Dependency Injection)
</a></p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://fakestandard.github.io/tags/dotnet-core/">DotNET Core</a></li>
      <li><a href="https://fakestandard.github.io/tags/asp.net-core-5/">ASP.NET Core 5</a></li>
      <li><a href="https://fakestandard.github.io/tags/csharp/">CSharp</a></li>
      <li><a href="https://fakestandard.github.io/tags/di/">DI</a></li>
      <li><a href="https://fakestandard.github.io/tags/dependency-injection/">Dependency Injection</a></li>
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on twitter"
        href="https://twitter.com/intent/tweet/?text=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection&amp;url=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f&amp;hashtags=DotNETCore%2cASP.NETCore5%2cCSharp%2cDI%2cDependencyInjection">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f&amp;title=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection&amp;summary=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection&amp;source=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f&title=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on whatsapp"
        href="https://api.whatsapp.com/send?text=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection%20-%20https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 【.NET Core】相依性注入 Dependency Injection on telegram"
        href="https://telegram.me/share/url?text=%e3%80%90.NET%20Core%e3%80%91%e7%9b%b8%e4%be%9d%e6%80%a7%e6%b3%a8%e5%85%a5%20Dependency%20Injection&amp;url=https%3a%2f%2ffakestandard.github.io%2fnetcore%2fnetcore5-2-dependencyinjection%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://fakestandard.github.io/">How can I help</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
