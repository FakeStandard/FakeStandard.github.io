<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Algorithms on How can I help</title>
    <link>https://fakestandard.github.io/algorithm/</link>
    <description>Recent content in Algorithms on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Tue, 20 Jul 2021 12:15:10 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】陣列應用—稀疏矩陣演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-31-matrixsparse/</link>
      <pubDate>Tue, 20 Jul 2021 12:15:10 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-31-matrixsparse/</guid>
      <description>【5/26 閱讀紀錄】
根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 從數學角度來說，矩陣 m*n 的形式在電腦中可以利用二維陣列表示，而矩陣的相關運算與應用，也都是以陣列結構來解決。矩陣可應用於 3D 圖學中，用來表示模型資料的投影、擴大、縮小、平移、偏斜或旋轉等運算，在深度學習中也常遇到大量使用矩陣運算來提高效率。
接下來會透過陣列結構來演示稀疏矩陣演算法
稀疏矩陣 稀疏矩陣的定義是在一個矩陣中，有大部分的元素是 0，例如
在上述矩陣中，若以二維陣列來儲存，十分浪費記憶體空間，此時改進的方法就是利用三項式（3-tuple）的資料結構，來壓縮稀疏矩陣，以減少記憶體空間。
三項式的儲存方式，首先 A(0,1) 儲存稀疏矩陣的列數，A(0,2) 儲存稀疏矩陣的的行數，A(0,3) 則儲存稀疏矩陣非零的項目個數，接著依序將非零的項目以 A(i,j,item-value) 的方式儲存，如下
實際演練程式碼，將一稀疏矩陣利用三項式壓縮
先建立輸出矩陣方法
/// &amp;lt;summary&amp;gt; /// 輸出矩陣 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;matrix&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i &amp;lt; matrix.GetLength(0); i++) { for (j = 0; j &amp;lt; matrix.GetLength(1); j++) Write(matrix[i, j] + &amp;#34;\t&amp;#34;); WriteLine(); } } 在 Main 方法中直接執行壓縮</description>
    </item>
    
    <item>
      <title>【Algorithm】陣列應用—轉置矩陣演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-30-matrixtranspose/</link>
      <pubDate>Sun, 18 Jul 2021 14:45:37 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-30-matrixtranspose/</guid>
      <description>【5/26 閱讀紀錄】
根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 從數學角度來說，矩陣 m*n 的形式在電腦中可以利用二維陣列表示，而矩陣的相關運算與應用，也都是以陣列結構來解決。矩陣可應用於 3D 圖學中，用來表示模型資料的投影、擴大、縮小、平移、偏斜或旋轉等運算，在深度學習中也常遇到大量使用矩陣運算來提高效率。
接下來會透過陣列結構來演示轉置矩陣演算法
轉置矩陣 轉置矩陣非常好理解，就是將原矩陣的行座標元素與列座標元素互相對調，例如
可得結論
程式碼實現，先輸出矩陣方法
/// &amp;lt;summary&amp;gt; /// 輸出矩陣 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;matrix&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i &amp;lt; matrix.GetLength(0); i++) { for (j = 0; j &amp;lt; matrix.GetLength(1); j++) Write(matrix[i, j] + &amp;#34;\t&amp;#34;); WriteLine(); } } 轉置矩陣方法
/// &amp;lt;summary&amp;gt; /// 轉置矩陣方法 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;A&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;B&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;C&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; static void Matrix_Transpose(ref int[,] A, ref int[,] At) { int i, j; for (i = 0; i &amp;lt; A.</description>
    </item>
    
    <item>
      <title>【Algorithm】陣列應用—矩陣相加與相乘演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-29-matrixaddadnmultiply/</link>
      <pubDate>Sat, 17 Jul 2021 12:03:58 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-29-matrixaddadnmultiply/</guid>
      <description>【5/26 閱讀紀錄】
根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 從數學角度來說，矩陣 m*n 的形式在電腦中可以利用二維陣列表示，而矩陣的相關運算與應用，也都是以陣列結構來解決。矩陣可應用於 3D 圖學中，用來表示模型資料的投影、擴大、縮小、平移、偏斜或旋轉等運算，在深度學習中也常遇到大量使用矩陣運算來提高效率。
接下來會透過陣列結構來演示以下兩種演算法
 矩陣相加 矩陣相乘  矩陣相加 矩陣相加與相減的前提是兩矩陣的陣列數與行數必須相同，相加或相減後的陣列數與行數也必須相等，所以矩陣相加與相減的特性相同。
實際演練下列兩矩陣 A.B 相加之後得到 C 矩陣
建立靜態變數與輸出矩陣方法
static int ROWS = 3; static int COLS = 3; /// &amp;lt;summary&amp;gt; /// 輸出矩陣 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;matrix&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i &amp;lt; ROWS; i++) { for (j = 0; j &amp;lt; COLS; j++) Write(matrix[i, j] + &amp;#34;\t&amp;#34;); WriteLine(); } } 建立矩陣相加方法</description>
    </item>
    
    <item>
      <title>【Algorithm】佇列應用—雙向佇列（Deques）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-28-deques/</link>
      <pubDate>Thu, 15 Jul 2021 11:24:37 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-28-deques/</guid>
      <description>【5/30 閱讀紀錄】
根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 雙向佇列的全名是 Double-ends Queues，縮寫為 Deques。雙向佇列與一般說的佇列不太相同，不過也很容易理解，它是一種前後兩端都可以輸入或輸出資料的有序串列。
雙向佇列至少有以下工作行為
   Method Description     IsEmpty 檢查雙向佇列是否為空   PushFront 將資料從頂端推入，其大小加一   PushRear 將資料從末端推入，其大小加一   PopFront 將資料從頂端推出，其大小減一   PopRear 將資料從末端推出，其大小減一   PeekFront 存取頂端的資料，不改變其大小   PeekRear 存取末端的資料，不改變其大小    而雙向佇列依其應用還可分為多種存取模式，較常見的雙向佇列有
 輸入限制性雙佇列（Input Restricted Deque） - 限制存入資料只能在其中一端進行，取出資料則可在兩端執行 輸出限制性雙佇列（Output Restricted Deque） - 限制取出資料只能在其中一端進行，輸入資料則可在兩端執行  以串列結構實作雙向佇列程式碼，建立節點類別、雙向佇列串列結構類別，以及佇列相關方法（推入推出方法在下一步實作）
/// &amp;lt;summary&amp;gt; /// 節點類別 /// &amp;lt;/summary&amp;gt; class Node { public int data; public Node next; public Node(int data) { this.</description>
    </item>
    
    <item>
      <title>【Algorithm】佇列應用—串列實作佇列</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-27-queuelist/</link>
      <pubDate>Mon, 12 Jul 2021 11:07:41 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-27-queuelist/</guid>
      <description>【5/20 閱讀紀錄】
根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用串列結構模擬佇列工作，使用指標及相關方法實作佇列。
建立鏈結串列的節點類別
/// &amp;lt;summary&amp;gt; /// 鏈結串列節點類別 /// &amp;lt;/summary&amp;gt; class QueueNode { public int data; public QueueNode next; public QueueNode(int data) { this.data = data; next = null; } } 建立使用串列節點模擬佇列的類別，其中包含 Enqueue 和 Dequeue 方法。
/// &amp;lt;summary&amp;gt; /// 串列模擬佇列類別 /// &amp;lt;/summary&amp;gt; class QueueByLink { // 前端指標  public QueueNode front; // 末端指標  public QueueNode rear; public QueueByLink() { front = null; rear = null; } /// &amp;lt;summary&amp;gt;  /// 加入資料到佇列  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Enqueue(int value) { // 建立新節點  QueueNode node = new QueueNode(value); // 檢查是否為空佇列  if (rear == null) front = node; else rear.</description>
    </item>
    
    <item>
      <title>【Algorithm】佇列應用—陣列實作佇列</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-26-queuearray/</link>
      <pubDate>Sun, 11 Jul 2021 11:02:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-26-queuearray/</guid>
      <description>【5/20 閱讀紀錄】
根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用陣列簡單地時做佇列應用，宣告一個大小為 10 的佇列 queue[10]，設置 front 和 rear 作為頭尾的指標且預設為 -1。
static int front = -1; static int rear = -1; static int max = 10; static int val; static int[] queue = new int[max]; static void Main(string[] args) { int choice = 0; while (rear &amp;lt; max - 1 &amp;amp;&amp;amp; choice != 3) { Write(&amp;#34;請輸入 \n[1] 新增一個資料 \n[2] 取出資料 \n[3] 結束 :&amp;#34;); choice = int.Parse(Console.ReadLine()); switch (choice) { case 1: Write(&amp;#34;請輸入要新增的數值:&amp;#34;); val = int.</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—八皇后經典謎題</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-25-eightqueens/</link>
      <pubDate>Sat, 10 Jul 2021 16:02:17 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-25-eightqueens/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 八皇后謎題也是經典中的經典，該問題以西洋棋作為背景，如何在 8x8 的棋盤上擺放八個皇后，使任一皇后都無法吃掉其他皇后，屬於堆疊常見的應用實例。
西洋棋皇后擺放的規則為：因皇后可在一步內，不限格數的直行、橫行或斜線前行，若同一條線上同時有兩個皇后，則舊皇后可吃掉新來皇后，所以，皇后間不可處於同一個縱向、橫向或斜線（跟數獨的概念相似）
首先會先放置一個皇后，接著依據第一個皇后的位置，在不被吃掉的情況下，繼續放置第二個皇后、第三個皇后…直到放置某個新皇后時，都會被先前的皇后吃掉，此時，就必須變更前一個皇后放置的位置，在不被先前的皇后吃掉之情形下，找到第二個可以放置的位置，在繼續擺放新皇后；若在前一個擺放的皇后，也沒有新的位置可以擺放（都會被吃掉的情況），就在將前前皇后拿起，尋找新的可以擺放的位置，以此類推。
由上述可知，在放置新皇后或是拿起舊皇后的動作，是以堆疊的概念進行，而當新皇后無法擺放時，將舊皇后拿起尋找新的位置，是以回溯的概念進行。
本書程式碼範例
class Program { static void Main(string[] args) { number = 0; DecidePosition(0); ReadKey(); Console.ReadLine(); } static int TRUE = 1, FALSE = 0, EIGHT = 8; // 存放八個皇后的列位置  static int[] queen = new int[EIGHT]; // 計算共有幾組解答  static int number = 0; /// &amp;lt;summary&amp;gt;  /// 按下 Enter 鍵要執行方法  /// &amp;lt;/summary&amp;gt;  public static void PressEnter() { char ch; Write(&amp;#34;\n\n&amp;#34;); Write(&amp;#34;按下 Enter 鍵繼續.</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—經典河內塔</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-24-towerofhanoi/</link>
      <pubDate>Wed, 07 Jul 2021 16:59:27 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-24-towerofhanoi/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 這篇紀錄經典的智力遊戲—河內塔，使用遞迴式和堆疊概念來解決問題的經典範例。
河內塔的問題描述如下：在古老的印度神廟中，有三個木樁，在第一個木樁上，有數量和大小不同的圓盤，由大到小堆疊，最大的圓盤放在最下面，最小的圓盤在最上面，天神希望將第一個木樁的圓盤，全部移動到第三個木樁。
搬動時必須要遵守規則下列規則
 直徑較小的圓盤只能置於直徑大的圓盤上，比如直徑三的圓盤可以放置在直徑四或直徑五的上方 圓盤可以任意由一個木樁移動到其他木樁上，共有三個木樁可使用 每次只能移動一個圓盤，只能從最上方的圓盤開始移動（與堆疊相同）  【解析】
假設 n 為圓盤數量，逐步解析情境
  n = 1
當圓盤只有一個時，直接從第一個木樁移動到地三個木樁，完成天神願望。
  n = 2
當圓盤為兩個時，由上往下數，將第一個圓盤移動到第二個木樁，接著將第二個圓盤移動到第三個木樁，第一個圓盤從第二個木樁移動到第三個木樁，完成天神願望。
在這裡可以得到一個小結論
 圓盤移動的次數為 (2^2)-1 = 3 次，即 2 的平方-1 次 圓盤移動的次序為 1→2→1 木樁移動的次序為 1→2、1→3、2→3    n = 3
當圓盤為三個時，由上往下數
 第一個圓盤移動到第三個木樁 第二個圓盤移動到第二個木樁 第一個圓盤從第三個木樁移至第二個木樁，此時第二個木樁有兩個圓盤 第三個圓盤移動到第三個木樁 第一個圓盤從第二個木樁移動到第一個木樁 第二個圓盤從第二個木樁移動到第三個木樁 最後，將第一個圓盤從第一個木樁移動到第三個木樁  完成天神願望（懶得畫圖，請讀者發揮想像力…）
此情境得出以下結論
 圓盤移動的次數為 2^3-1 = 7 次，即 2 的次方-1 次 圓盤移動的次序為 1→2→1→3→1→2→1 木樁移動的次序為 1→3、1→2、3→2、1→3、2→1、2→3、1→3    【結論】</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—串列實作堆疊</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-23-stacklist/</link>
      <pubDate>Mon, 05 Jul 2021 14:06:01 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-23-stacklist/</guid>
      <description>【5/17 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 使用串列製作堆疊的好處是可以隨時動態改變串列長度，缺點則是設計較為複雜。相較於使用陣列製作堆疊設計上較為簡易，缺點則是陣列大小需事先宣告，無法動態改變。
利用串列結構模擬堆疊工作運算，使用迴圈控制推入或取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。
宣告一個鏈結串列節點的類別
/// &amp;lt;summary&amp;gt; /// 鏈結串列節點的類別 /// &amp;lt;/summary&amp;gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } 宣告串列模擬堆疊的類別，其中包含推入和取出的方法
/// &amp;lt;summary&amp;gt; /// 以串列模擬的堆疊 /// &amp;lt;/summary&amp;gt; class StackByLink { /// &amp;lt;summary&amp;gt;  /// 指向堆疊頂端的指標  /// &amp;lt;/summary&amp;gt;  public Node front; /// &amp;lt;summary&amp;gt;  /// 指向堆疊末端的指標  /// &amp;lt;/summary&amp;gt;  public Node rear; /// &amp;lt;summary&amp;gt;  /// 判斷堆別是否為空的方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool IsEmpty() { return front == null; } /// &amp;lt;summary&amp;gt;  /// 輸出堆疊內容  /// &amp;lt;/summary&amp;gt;  public void Display() { Node current = front; while (current !</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—陣列實作堆疊</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</link>
      <pubDate>Fri, 02 Jul 2021 15:50:31 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用陣列結構模擬堆疊工作運算，且使用迴圈控制推入與取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。
建立堆疊類別
/// &amp;lt;summary&amp;gt; /// 以陣列模擬堆疊的類別 /// &amp;lt;/summary&amp;gt; class StackArray { // 宣告陣列  private int[] stack; // 指向堆疊頂端的索引  private int top; /// &amp;lt;summary&amp;gt;  /// 建構子  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;stack_size&amp;#34;&amp;gt;堆疊大小&amp;lt;/param&amp;gt;  public StackArray(int size) { // 建立陣列  stack = new int[size]; top = -1; } /// &amp;lt;summary&amp;gt;  /// 判斷堆疊是否為空  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Empty() { if (top == -1) return true; else return false; } /// &amp;lt;summary&amp;gt;  /// 推入資料到頂端的方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Push(int data) { // 判斷堆疊頂端的索引是否大於陣列大小  if (top &amp;gt;= stack.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—費氏搜尋法（Fibonacci Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</link>
      <pubDate>Wed, 30 Jun 2021 13:28:24 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</guid>
      <description>【5/31 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  費氏搜尋演算法（Fibonacci Search） 費氏搜尋演算法又稱費伯納搜尋法，Fibonacci 還有其他譯名如斐波那契數列、費氏數列等等，該數列非常特別，對於大自然而言，整個自然界都存在這個的定律，它是一個神奇的黃金比例；對於數學而言，只不過是個公式—每個值是前兩項的總和，但是，每個值除以前一項的商數，都近似於 1.618…
OK. 我們也不能偏離主題太遠，不過 1.618 這個數字會存放於筆者內心的深處，近期受疫情的肆虐，筆者拾起達文西密碼，拜本書之賜，重新認識斐波那契數列這個「上帝之數」。
費氏級數如同先前所說，每個值都是前兩項的加總，故其公式為
雖然每個值都是前兩項的加總，其中並不包含第零個元素和第一個元素，第零個元素定義為 0，第一個元素定義為 1，從這兩個元素開始，每個值才是前兩項的總和，故該數列會是 0,1,1,2,3,5,8,13,21,34,55,89,144...
費氏樹列以遞迴程式碼表現方式為
static int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 了解費氏級數後，就來認識費氏搜尋數，所謂費氏搜尋數就是以費氏數列的特性，所建立的二元數，其建立原則如下</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—內插搜尋法（Interpolation Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</link>
      <pubDate>Mon, 28 Jun 2021 10:27:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  內插搜尋演算法（Interpolation Search） 內插搜尋法又稱插補搜尋法，是二分搜尋法的改良版，主要是針對以排序的資料進行搜尋，與二分法相同。其原理為透過斜率公式預測資料的所在位置，再以二分法逐漸逼近。
參考斜率公式說明
實作公式
Mid = left + ((key-data[left]) * (right - left) / (data[right] - data[left])) 演算法分析  資料需事先排序 資料分佈越平均，搜尋速度越快。時間複雜度取決於資料分佈情況，平均會優於 O(logn)  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作內插搜尋法的過程
建立靜態陣列物件及內插搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; static int Interpolation(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—二分搜尋法（Binary Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</link>
      <pubDate>Fri, 25 Jun 2021 12:37:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。
假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。
演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程
建立靜態陣列物件及二分搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; /// &amp;lt;summary&amp;gt; /// 二分搜尋方法 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;val&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</link>
      <pubDate>Wed, 23 Jun 2021 11:19:30 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。
它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。
假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。
利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。
演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n+1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</link>
      <pubDate>Mon, 21 Jun 2021 13:59:42 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。
假設有一陣列，陣列資料分別為
                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—基數排序法（Radix Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</link>
      <pubDate>Fri, 18 Jun 2021 13:58:45 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</guid>
      <description>【5/20 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例
LSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較
Step 1 將每個元素依照「個位數」放到相對應的串列中
                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—合併排序法（Merge Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</link>
      <pubDate>Wed, 16 Jun 2021 10:57:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。
步驟非常好理解，如下
 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—快速排序法（Quick Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</link>
      <pubDate>Sun, 13 Jun 2021 14:01:03 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</guid>
      <description>【5/17 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。
其步驟如下
 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I &amp;gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K
               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—謝耳排序法（Shell Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</link>
      <pubDate>Wed, 09 Jun 2021 10:34:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</guid>
      <description>【5/2 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  謝耳排序法（Shell Sort） 在插入排序法中，若大部分資料已經排序完成，該排序法會相當有效率，而謝耳排序法可以看作是一種使插入排序法減少資料搬移次數的衍伸排序法。
其原理為將資料區分成特定間隔的區塊，以插入排序法對區塊內資料進行排序，再漸漸減少間隔的距離。
舉例，有一陣列為 [50] [60] [10] [30] [20] [80] [40] [70]，以劃分數為 2，將資料分成四等份 (8/2)，得到下列區塊組合 (50,20)(60,80)(10,40)(30,70)，規則為第一個數與第五個數為一組，第二個數與第六個數為一組，以此類推。
接著透過插入排序法，對區塊內的資料做排序，使其成為 (20,50)(60,80)(10,40)(30,70)，排序完後，解散區塊組合，還原成原數列 [20] [60] [10] [30] [50] [80] [40] [70]
繼續縮小間隔為 (8/2)/2，得到下列區塊組合 (20,10,50,40)(60,30,80,70)，其規則為第一、三、五、七個數字為一組，二、四、六、八為一組，一樣以插入排序法對區塊內資料做排序，得結果為 (10,20,40,50)(30,60,70,80)，解散組合區塊，還原成原數列 [10] [30] [20] [60] [40] [70] [50] [80]
進行第三次排序，縮小間隔為 ((8/2)/2)/2，如此一來變成對每一個元素進行排序，直接使用插入排序法得結果為 [10] [20] [30] [40] [50] [60] [70] [80]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—插入排序法（Insert Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</link>
      <pubDate>Mon, 07 Jun 2021 12:31:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  插入排序法（Insert Sort） 插入排序法原理是將陣列中的元素，逐一與已經排序好的資料作比較，例如前兩個元素已經排序好，再將第三個元素與這兩個元素作比較，插入到適當的位置，接著將第四個元素，與前三個已排序好的元素進行比較，再插入到適當位置，重複此步驟，直到排序完成為止。
透過插入排序法，一樣對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先第一個元素 [30] 定義為已排序，取得第二個元素 [20]，與第一個元素進行比較，插入到適當位置
初始已排序序列 [30]
插入後結果序列 [20] [30]
Step 2 取得第三個元素 [40]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30]
插入後結果序列 [20] [30] [40]
Step 3 取得第四個元素 [50]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30] [40]
插入後結果序列 [20] [30] [40] [50]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—選擇排序法（Selection Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</link>
      <pubDate>Thu, 03 Jun 2021 15:19:41 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  選擇排序法（Selection Sort） 選擇排序法顧名思義是以選擇的概念來進行排序，也算是枚舉法的應用，原理為反覆從未排序的數列中取出最小元素，加入到另一個數列中，達到排序的結果。
選擇排序可以由大到小排序，將最大值放到第一位置；或是由小到大排序，將最大值放到最後一個位置。
透過選擇排序法，對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先進行第一次掃描，找到數列中最小值，直接與第一個元素交換
初始序列 [30] [20] [40] [50] [10]
結果序列 [10] [20] [40] [50] [30]
Step 2 進行第二次掃描，排除第一個元素，從第二個位置開始找起，找到最小值，與第二個位置元素交換，因為 [20] 是此次搜尋中最小值，其結果位置不變
上次結果 [10] [20] [40] [50] [30]
結果序列 [10] [20] [40] [50] [30]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—氣泡排序法（Bubble Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</link>
      <pubDate>Tue, 01 Jun 2021 13:56:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  氣泡排序法（Bubble Sort） 氣泡排序法可稱為交換排序法，其構思為觀察水中氣泡變化而成，甚至可稱為冒泡排序等類似名稱。
其原理為從第一個元素開始，比較相鄰元素的大小，如大小順序有誤，就將其對調，再與下一個元素進行比較，彷彿氣泡逐漸冒出水面上的概念，使用該方法掃描過一次後，就可以確保最後一個元素是位於正確的位置，進行第二次掃描，就能確認第二個元素的正確位置，逐步進行直到所有元素排序完成。
使用白話一點的說法，逐一拆解每一個步驟，首先有一個序列，初始的狀態和順序為 [30] [20] [40] [50] [10]，目標將此序列由小到大排列，變成 [10] [20] [30] [40] [50]
我們透過氣泡排序法進行排序，步驟解析如下
Step 1 首先進行第一次掃描，會先拿到第一個元素 [30]，接著與相鄰的元素 [20] 進行比較，如果第二個元素小於地一個元素，就進行位置交換。
初始序列 [30] [20] [40] [50] [10]
結果序列 [20] [30] [40] [50] [10]
Step 2 依然拿著 [30] 這個元素，繼續與相鄰的元素比較，因為該元素已經調換到第二個元素的位置，所以下一個相鄰的元素會是 [40]，接著進行比較，經比較後兩個元素順序不變，依然維持下列結果
結果序列 [20] [30] [40] [50] [10]</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—雜湊表（Hash Table）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-9-hashtable/</link>
      <pubDate>Sat, 29 May 2021 13:55:36 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-9-hashtable/</guid>
      <description>【5/24 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄雜湊表定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  雜湊表（Hash Table） 雜湊是一種電腦對資料的處理方式，它通過某種特定的雜湊函數應用，將鍵值轉換成相對應的資料儲存位址，形成一種快速存取與搜尋資料的資料結構—雜湊表，而雜湊表是一種儲存紀錄的連續記憶體。
相關專有名詞  雜湊函數（Hashing Function）
將未經雜湊的資料，透過特定的計算公式，轉換成對應的資料儲存位址，計算後的結果必須隨著明文改變而改變。 雜湊值（Hash Code）
原始資料經由雜湊函數計算的結果，稱為雜湊值，且雜湊值為不可逆。不可逆的意思是，轉換後的結果無法反推原來的資料，只能由 A 變成 B，無法從 B 找回 A，例如將蘋果透過果汁機打成蘋果汁，蘋果就是原始資料，果汁機是雜湊函數，蘋果汁是雜湊值，我們無法將蘋果汁再透過果汁機變回蘋果，這就是不可逆。 桶（Bucket）
雜湊表中儲存資料的位置，每個位置對應唯一的位址（Bucket Address） 槽（Slot）
每一筆紀錄可能包含多個欄位，Slot 指的就是 Bucket 的欄位 碰撞（Collision）
兩筆不同的資料，經雜湊函數運算後，對應到相同位址時，稱為碰撞 溢位（Overflow）
資料經過雜湊函數運算後，對應的 Bucket 已滿，則會使 Bucket 發生溢位 雜湊表（Hash Table）
儲存紀錄的連續記憶體，它類似於資料表的索引表格，可將 Column 和 Row 看待成 Slot 與 Bucket 完美雜湊（Perfect Hashing）
指沒有發生碰撞，也沒有發生溢位的雜湊函數  雜湊應用 雜湊通常應用於加密或驗證，但雜湊不等於加密，加密不等於雜湊。其應用有身份證字號是透過公式來驗證是否合法，或者是 MD5 密碼雜湊函式，將使用者的 password 經由 MD5 產生雜湊值，再將雜湊值儲存於資料庫中，等下次使用者登入時，將輸入的密碼經由 MD5 運算，將其結果與資料庫中儲存的雜湊值進行比對即可。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—圖形（Graph）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-8-graph/</link>
      <pubDate>Wed, 26 May 2021 09:27:51 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-8-graph/</guid>
      <description>【5/25 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄圖形定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  圖形（Graph） 圖形理論是由一位瑞士數學家所想出的一種資料結構，是比樹狀結構更複雜的非線性結構，許多問題都可以轉換成圖形資料結構，因此，圖形資料結構被廣泛應用於程式的實作，在所有資料結構中的應用也最為廣泛。
例如在網路的地圖上搜尋兩點之間的最短路徑，可以將地點轉換成圖形中的頂點，地點與地點之間的距離轉換成邊，最後使用最短路徑的演算法，即可以找出最短路徑。
圖的定義是由**頂點（Vertice）和邊（Edge）**所組成的集合，邊是連結圖形中的兩個頂點，可以有循環，也可以不跟其他頂點相連，通常以 G=(V,E) 來定義一個圖形
 G：圖（Graph） V：所有頂點（Vertice）的集合 E：所有邊（Edge）的集合  圖形的種類有兩種，分別是無向圖形和有向圖形
無向圖形（Undirected Graph） 無向圖形的邊只代表頂點之間是相連，不會標示方向箭頭，可以說是不具有方向性，無向圖以 (V1,V2) 來表示，例如 (V1,V2) 與 (V2,V1) 表示相同的邊。
以上圖來說
V = {A,B,C,D,E} E = {(A,B),(A,C),(B,D),(B,E),(C,D),(C,E)} 有向圖形（Directed Graph） 有向圖形的每個邊都具有方向性，以 &amp;lt;V1,V2&amp;gt; 來表示，若無向圖是不具方向性，那麼有向圖就是具有方向性的，V1 是指尾端，V2 是指頂端，&amp;lt;V1,V2&amp;gt; 則代表著由 V1 尾端指向 V2 頂端。例如 &amp;lt;V1,V2&amp;gt; 和 &amp;lt;V2,V1&amp;gt; 表示兩個不同方向的邊。
以上圖來說，與無向圖形的範例圖差異在於，該圖的邊是具有方向性箭頭，表示方式如下
V = {A,B,C,D,E} E = {&amp;lt;A,B&amp;gt;,&amp;lt;A,C&amp;gt;,&amp;lt;B,D&amp;gt;,&amp;lt;C,D&amp;gt;,&amp;lt;E,B&amp;gt;,&amp;lt;E,C&amp;gt;} 相關專有名詞   頂點（Vertice）</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—樹（Tree）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-7-tree/</link>
      <pubDate>Mon, 24 May 2021 09:54:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-7-tree/</guid>
      <description>【5/17 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。
上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。
對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。
樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）
樹的基本術語有許多種，利用上圖的樹狀圖一一解說
  根節點（Root）
先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點
  葉節點（Leaf）或終點節點（Terminal Nodes）
節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點
  非終端節點（Nonterminal Nodes）
除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H
  子節點（Children）
每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D
  父節點（Parent）
每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C
  祖先節點（Ancestor）
指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—佇列（Queue）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-6-queue/</link>
      <pubDate>Fri, 21 May 2021 10:54:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-6-queue/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。
佇列基本運算具備以下五種工作定義
   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—堆疊（Stack）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-5-stack/</link>
      <pubDate>Wed, 19 May 2021 13:53:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-5-stack/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。
堆疊基本運算具備以下五種工作定義
   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—鏈結串列（Linked List）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</link>
      <pubDate>Fri, 30 Apr 2021 16:09:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</guid>
      <description>【4/14 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。
在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成
 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。
日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。
對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。
Note 特性
 記憶體空間配置的儲存方式為不連續且隨機  優點
 刪除或插入資料無須移動大量資料  缺點
 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—陣列（Array）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-3-array/</link>
      <pubDate>Mon, 26 Apr 2021 16:34:39 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-3-array/</guid>
      <description>【4/11 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。
靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。
操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。
陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。
使用一維陣列尋找和儲存 1~num 之間的所有質數
const int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m &amp;lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i &amp;lt; num; i++) { if (prime[i]) { if (c == 10) { Console.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構定義與資料型態</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</link>
      <pubDate>Sun, 25 Apr 2021 13:26:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</guid>
      <description>【4/11 閱讀紀錄】
此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。
Start 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。
一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。
資料型態
 基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）  記憶體儲存方式
 靜態資料結構（Static data structure） 動態資料結構（Dynamic data structure）   資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。
  基本資料型態（Primitive Data Type）
基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。
  結構化資料型態（Structured Data Type）
結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。
  抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。
  記憶體儲存方式 若以記憶體儲存的方式來看資料結構，可以區分為兩種
  靜態資料結構（Static data structure）
靜態資料結構是將有序數列的資料，儲存於連續的記憶體空間，故在編譯時就得先配置記憶體空間，所以在初期須先宣告固定的記憶體空間，優點是連續記憶體設計時叫簡易，且讀取與修改任一元素的時間都是固定，缺點則是刪除或加入需要移動大量的資料，而最典型的靜態資料結構就是陣列。
  動態資料結構（Dynamic data structure）
動態資料結構是將有序數列的資料，儲存於不連續的記憶體空間，不須在編譯時先配置記憶體，因記憶體配置是發生在執行時，故能節省記憶體空間，在插入和刪除也相當方便，它不需要移動大量資料，缺點則是設計時較麻煩，讀取、修改或搜尋時，無法像靜態資料結構一樣直接取出資料，必須透過走訪找到目標資料為止。動態資料結構的代表是鏈結串列。
  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【Algorithm】經典演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</link>
      <pubDate>Mon, 05 Apr 2021 13:41:55 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</guid>
      <description>【3/28 閱讀紀錄】
此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。
Start 演算法種類很多，經典的演算法有以下幾種
 分治演算法（Divide and conquer） 迭代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Enumeration Algorithm） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。
像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。
然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。
所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。
迭代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為迭代演算法，像是透過迴圈去循環重複的程式碼來得到答案。
舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果
// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i &amp;lt;= n; i++) { for (int j = i; j &amp;gt; 0; j--) { sum = sum * j; } Console.</description>
    </item>
    
  </channel>
</rss>
