<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on How can I help</title>
    <link>https://fakestandard.github.io/post/</link>
    <description>Recent content in Posts on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Tue, 29 Jun 2021 21:47:25 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【OOP】物件導向設計的五大原則</title>
      <link>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</link>
      <pubDate>Tue, 29 Jun 2021 21:47:25 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</guid>
      <description>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$
graph TD; A--B; A--C; B--D; C--D;  graph TD; A--&amp;gt;B; A--&amp;gt;C; B--&amp;gt;D; C--&amp;gt;D; Start 前篇講解 OOP 的特性卻還沒介紹基本原則，馬上來惡補一下內功心法。
物件導向設計五大原則「SOLID」由羅伯特·C·馬丁在21世紀早期提出，SOLID分別為單一功能原則、開閉原則、里氏替換原則、介面隔離原則、依賴反轉原則。
了解物件導向基本原則及特性，透過不斷練習和思考就可寫出閱讀性、維護性、擴充性高的程式碼，然而開發易維護與擴展的系統也變得不難。
單一職責（Single Responsibility Principle） 對一個類別來說，應該只有一個引起他變化的理由，意為一個類別應只專注做一件事，當類別需要做兩件以上的工作時，就承擔了過多的職責，一旦需變更代碼，耦合度會比一件工作還要高，而當發生錯誤時很難快速定位錯誤原因，間接導致程式碼可閱讀性降低。
開放封閉（Open-Closed Principle） 增加新的代碼來擴充系統，而非修改原本已存在的代碼來擴充新功能。所以在設計類別時對擴充保持開放及對修改保持封閉。若面對需求變化時，有無法封閉的變化，此時就須建立抽象點來隔離那些變化。
里氏替換（Liskov Substitution Principle） 子類別必須可以替換父類別而不影響程式架構。若使用繼承，子類別實作的行為必須與父類別或介面所定義的行為一致，且子類別可完全取代父類別。
介面隔離（Interface Segregation Principle） 抽取相同的功能形成介面，再讓各類別去實作。即針對不同類別開放對應需求的介面，需抽換時只需實作介面類別即可，大量降低耦合度。
依賴反轉（Dependency Inversion Principle） 高階模組不應依賴低階模組，兩者都應依賴在抽象概念上；抽象概念不依賴細節，而細節依賴在抽象概念。模組之間若太過耦合，很容易出現修改A又被迫修改B的情況，若依賴抽象則兩只只要關注自己本身即可。
Reference 【大話設計模式】</description>
    </item>
    
    <item>
      <title>【OOP】物件導向特性—封裝、繼承、多型</title>
      <link>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</link>
      <pubDate>Tue, 22 Jun 2021 20:56:20 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</guid>
      <description>Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。
 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明
 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。
封裝的好處
 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。
static void Main(string[] args) { Swordman swordman = new Swordman(); } /// &amp;lt;summary&amp;gt; /// 封裝類別 /// &amp;lt;/summary&amp;gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。
原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。
/// &amp;lt;summary&amp;gt; /// 盜賊類別 /// &amp;lt;/summary&amp;gt; class Thief { private string name = string.</description>
    </item>
    
    <item>
      <title>【C#】位移運算元 &lt;&lt; 和 &gt;&gt;</title>
      <link>https://fakestandard.github.io/post/csharp/csharp-2-bitwiseshiftoperators/</link>
      <pubDate>Sat, 12 Jun 2021 16:00:21 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/csharp/csharp-2-bitwiseshiftoperators/</guid>
      <description>昨天在刷 LeetCode 時，發現解題方式可以使用位移運算元，雖然筆者早就看過這個運算元，卻沒實際了解過，也趁這個機會快速了解位移運算元是個什麼樣的概念。
首先，筆者遇到的題型非常簡單，將二進位制轉換為十進位制，如將二進位 1110 轉換成十進位，得解為 14，在 C# 中可直接使用 Convert 來實現進位之間的轉換
string binary = &amp;#34;1110&amp;#34;; // 二進位轉十進位, 第二個參數為 base Convert.ToInt32(binary, 2); 如此是透過現成方法來實現轉換，為了更了解二進制的應用，特意觀察不少的解法，其中不少解法是透過位移運算元，撰寫起來也非常簡潔且優雅，那什麼是位移運算元？
位移運算元有兩種
 左位移 &amp;lt;&amp;lt; 右位移 &amp;gt;&amp;gt;  區分方式也非常易懂，純粹是位移方向的不同，以 1110 為例，對此二進位制的所有位元進行左位移一個位元，即將所有位元往左邊移動一位，而最右邊的第一個數則補上 0，得到結果為 11100，若左位移兩個位元則為 111000；反之右位移則是向右移動，對 1110 右位移一個位元得到 0111，若右位移兩個位元則得 0011。
 左位移一個位元的表示方式為 num &amp;lt;&amp;lt; 1 左位移一個位元的表示方式為 num &amp;lt;&amp;lt; 2 右位移一個位元的表示方式為 num &amp;gt;&amp;gt; 1 右位移一個位元的表示方式為 num &amp;gt;&amp;gt; 1  實際使用程式碼測試，先宣告一個整數變數 num，因為該變數是以十進位表示之，故筆者特意註解 num 二進位的表示方式，接著透過位移運算元，向左搬移一位，最後得十進位的結果。
// 十進位 14, 二進位 1110 int num = 14; // 向左位移 1 位 num = num &amp;lt;&amp;lt; 1; // 得到十進位 28, 二進位 11100 Console.</description>
    </item>
    
    <item>
      <title>【OOP】物件導向基礎概念（Object Oriented Programming）</title>
      <link>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</link>
      <pubDate>Thu, 10 Jun 2021 14:08:57 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</guid>
      <description>Start 物件導向（Object-Oriented Programming），意為針對物件進行程式設計。而學習設計模式前必須先了解物件導向設計，不然難以體會設計模式的魅力。
接下來我們會知道
 類別（Class） 物件（Object） 實體（Instance） 建構式（Constructor） 多載（Overloading） 欄位（Field） 屬性（Property） 修飾詞（Modifiers）  類別（Class） 類別是具有相同「屬性（Attribute）」和 「功能（Method）」的物件之抽象集合。在 C# 中定義類別的關鍵字為 class，類別命名規則為第一個字母為大寫，多個單字命名時各個首字母為大寫。
// 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法使外部可以呼叫，修飾詞用 public  public string Attack() { return &amp;#34;基本攻擊！&amp;#34;; } } 物件（Object） 物件是一個獨立的實體，實體裡包含許多資料，資料彼此之間不會互相影響，每個皆為獨立的資料。物件與類別的關係，最簡單易懂又不抽象的解釋為—物件是類別的實體。
// 宣告一個Swordman 物件，物件名為 swordman Swordman swordman; // 先前建立的 Swordman 類別 class Swordman { ... }  在程式碼的世界裡，萬物皆為物件。
 實體（Instance） 實體就是一個真實的物件。實體化是建立物件的過程，使用 new 關鍵字建立。
// 實體化 swordman 物件 swordman = new Swordman(); 綜合上述介紹的類別、物件和實體，實際演練一次程式碼並觀察結果。 在 Swordman 有一個公開的 Attack 方法，當物件被實體化後，未來就能一直呼叫該方法</description>
    </item>
    
    <item>
      <title>【C#】不規則陣列（Jagged Array）</title>
      <link>https://fakestandard.github.io/post/csharp/csharp-1-jaggedarray/</link>
      <pubDate>Tue, 08 Jun 2021 10:18:14 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/csharp/csharp-1-jaggedarray/</guid>
      <description>最近在 LeetCode 刷題時，發現一個我不知道的東西—不規則陣列（Jagged Array）
從古自今，筆者對於陣列的認知不外乎就是一維與多維陣列，然而在工作上也從未遇過不規則陣列的使用，導致近日在刷題時，曾一度懷疑自己的眼睛，這是不是打錯了？井底之蛙的我馬上跪拜古哥，結果在 C# 程式設計手冊發現了它的蹤影，廢話不多說，馬上來看！
不規則陣列（Jagged Array）是陣列的一種，其陣列內的元素也是陣列，不規則陣列的元素可以具有不同維度及大小，也是與多維陣列明顯的差異之處。
不規則陣列的宣告及初始化
// 不規則陣列的宣告方式 int[][] array = new int[5][]; // 初始化元素 array[0] = new int[6]; array[1] = new int[5]; array[2] = new int[4]; array[3] = new int[3]; // 使用 Initializer 直接填入陣列元素的值，無須設置大小 array[0] = new int[]{ 1, 2, 3 }; array[1] = new int[]{ 4, 6 }; array[2] = new int[]{ 7 }; 從上述可知，多維陣列在同一維度下的元素大小必須相同，而不規則陣列的元素大小可以不同，不規則陣列內的元素是陣列，又稱為陣列中的陣列。
我們也可以在宣告時直接初始化元素
// 宣告時直接初始化 int[][] array = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; // 或是不使用 new 運算子的縮寫格式 int[][] array = { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; 其指派值的方式與多維陣列相同</description>
    </item>
    
    <item>
      <title>【.NET】使用 C# 操作檔案 I/O 與檔案系統（二）</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-9-filesystemandfileio-two/</link>
      <pubDate>Thu, 27 May 2021 11:04:04 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-9-filesystemandfileio-two/</guid>
      <description>在 .NET 框架中，命名空間System.IO已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西
 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。
流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。
Start 流（Stream）為所有資料流的基礎類別，繼承該類別的資料流常見的有
 FileStream StreamReader StreamWriter MemoryStream  FileStream FileStream可以用來讀取、寫入、開啟和關閉檔案系統上的檔案，或操縱其他與檔案相關的檔案處理系統。該類別主要是要操作位元組陣列， Stream 類別則直接操作字元，是兩者較不同的地方。
文字讀起來沒感覺，直接使用FileStream來讀寫二進位制檔案。
先建立一個含有文字內容的文字檔，透過FileStream開啟該文字檔，除了讀取出二進位制內容，也順便將 binary 轉換為字元打印出來。
/// &amp;lt;summary&amp;gt; /// 使用 FileStream 讀取檔案 /// &amp;lt;/summary&amp;gt; public static void FileStreamRead() { string path = @&amp;#34;D:\Test.txt&amp;#34;; // 建立 FileStream 並實例化  // 開啟或建立指定路徑檔案，訪問權限唯讀  FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Read); // 讀取 binary 檔案  byte[] array = new byte[fs.</description>
    </item>
    
    <item>
      <title>【.NET】使用 C# 操作檔案 I/O 與檔案系統（一）</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</link>
      <pubDate>Tue, 18 May 2021 11:11:56 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</guid>
      <description>在 .NET 框架中，命名空間 System.IO 已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西
 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。
流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。
Start FileSystemInfo 類別是檔案系統類別的基礎類別，繼承該類別的子類別有
 File - 負責檔案系統中的檔案，屬靜態類別 FileInfo - 負責檔案系統中的檔案 Directory - 負責檔案系統中的資料夾，屬靜態類別 DirectoryInfo - 負責檔案系統中的資料夾  另外還有位於 System.IO 命名空間下其餘相關的類別
 Path - 負責檔案系統中的路徑 DriveInfo - 負責磁碟機資訊的訪問  File 與 FileInfo 的區別在於 Info 類別需要實體化，而一般 File 是屬於靜態類別；Directory 與 DirectoryInfo 同理，Directory 是靜態類別，DirectoryInfo 需實體化類別。
FileInfo 使用 FileInfo 類別建立檔案，並且寫入資料
/// &amp;lt;summary&amp;gt; /// 建立檔案並寫入資料 /// &amp;lt;/summary&amp;gt; public static void CreateFileByFileInfo() { // 實體化 FileInfo 並指予路徑  FileInfo file = new FileInfo(@&amp;#34;D:\Test.</description>
    </item>
    
    <item>
      <title>【MSSQL】顯示 SQL 執行指令的時間</title>
      <link>https://fakestandard.github.io/post/mssql/mssql-2-setstatisticstime/</link>
      <pubDate>Fri, 14 May 2021 16:58:49 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/mssql/mssql-2-setstatisticstime/</guid>
      <description>紀錄一項非常基本的常識。
MS SQL 在預設的情況下執行查詢指令，會將結果訊息顯示在下方，如下圖
其實在預設情況下也是可以在右下角看到執行時間，不過這個執行時間只能讀到秒。某天無意間看到別人在執行查詢指令時，在結果訊息視窗竟能印出詳細資訊，特別紀錄一下這非常簡單我卻不會的技能。
Step 1 新增一個查詢視窗，在功能列表選擇查詢→查詢選項
Step 2 左側選擇執行→進階，勾選【SET STATISTICS TIME】
Step 3 左側選擇結果→文字，勾選【在結果集裡包含查詢】
Step 4 執行查詢指令查看結果訊息
非常簡單的操作，如果還想知道關於結果訊息的相關設定，也都在查詢選項裡面設置！</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯入 Excel</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</link>
      <pubDate>Tue, 11 May 2021 10:00:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</guid>
      <description>在網站開發時，總會遇到匯出 EXCEL 的需求，除了匯出之外，偶爾也會遇到匯入 EXCEL 這種懶人需求。
為何是懶人需求呢？通常使用者可以透過 UI 介面來維護資料，包括 CRUD 等功能，所以 Excel 資料會先透過前端介面在將資料傳遞到資料庫儲存。而匯入的方式，可以一次傳遞多筆資料，並且直達資料庫，過程中不需要使用 UI 介面逐筆輸入，非常省時又省力。
註：此篇使用 ASP.NET Core 5 實作
Start 首先到 NuGet 下載 NPOI 套件並安裝到專案中
建立 ImportController.cs
public class ImportController : Controller { public IActionResult Index() { return View(); } } 建立 Index.cshtml
&amp;lt;h2&amp;gt;Import&amp;lt;/h2&amp;gt; @using (Html.BeginForm(&amp;#34;Upload&amp;#34;, &amp;#34;Import&amp;#34;, FormMethod.Post, new { enctype = &amp;#34;multipart/form-data&amp;#34; })) { &amp;lt;input type=&amp;#34;file&amp;#34; class=&amp;#34;form-control&amp;#34; name=&amp;#34;file&amp;#34; /&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; class=&amp;#34;btn btn-primary&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; } 在 Controller 中新增一個接收 HttpPost 的 ActionResult Upload，除了返回頁面之外，沒有任何代碼。</description>
    </item>
    
    <item>
      <title>【.NET】將資料匯出成 CSV</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</link>
      <pubDate>Sun, 09 May 2021 14:31:15 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</guid>
      <description>前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。
Start 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下
Model public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable&amp;lt;Export_ClosedXML.</description>
    </item>
    
    <item>
      <title>【.NET】使用 ClosedXML 實現匯出 Excel 功能</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</link>
      <pubDate>Sat, 08 May 2021 10:28:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</guid>
      <description>開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。
這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub
【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用
Start 首先到 NuGet 安裝套件
Model 建立資料模型
public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料
public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕</description>
    </item>
    
    <item>
      <title>【Life Trip】五峰星空下露營區</title>
      <link>https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/</link>
      <pubDate>Thu, 29 Apr 2021 21:40:22 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/</guid>
      <description>【紀錄 2021/4/2-4/4】
2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）
這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～
話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！
因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。
出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka &amp;amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。
出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！
第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。
第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！
沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」
這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。
敲敲打打的一行人
因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。
努力掛內帳的孩子
第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！
度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！
麻辣鴛鴦鍋
晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。
山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！
因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。
無用配件
冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD
隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。
第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。
早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。
專業備料
專業煎牛排組
羅宋湯 &amp;amp; 牛排
結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！
大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。
打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。
這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。
W 老闆的下午茶
時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。
有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯出 Excel 的基本應用</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</link>
      <pubDate>Tue, 27 Apr 2021 14:08:05 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</guid>
      <description>開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。
代碼存放於 GitHub
Start 首先到 NuGet 套件添加 NPOI Package
建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable
/// &amp;lt;summary&amp;gt; /// 資料庫連線方法 /// &amp;lt;/summary&amp;gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = &amp;#34;.&amp;#34;; cnsb.InitialCatalog = &amp;#34;Northwind&amp;#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = &amp;#34;SELECT * FROM [Northwind].[dbo].[Orders]&amp;#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.</description>
    </item>
    
    <item>
      <title>【.NET】西元年與民國年相互轉換</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</link>
      <pubDate>Mon, 19 Apr 2021 14:58:59 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</guid>
      <description>這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。
一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。
西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。
Solution 有三種解決方案
 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間
引用命名空間
 System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $&amp;#34;{year}/{month}/{day}&amp;#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。
/// &amp;lt;summary&amp;gt; /// 靜態擴展類別 /// &amp;lt;/summary&amp;gt; public static class DateTimeExtend { /// &amp;lt;summary&amp;gt;  /// 靜態擴展方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;dateTime&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.</description>
    </item>
    
    <item>
      <title>【人森】如何計算個人綜合所得稅？</title>
      <link>https://fakestandard.github.io/post/other/other-2-incometax/</link>
      <pubDate>Wed, 14 Apr 2021 11:19:05 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/other/other-2-incometax/</guid>
      <description>一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。
首先要了解所得稅分為以下兩種
 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）
所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。
收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。
計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的
綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額
接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。
所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。
假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。
那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！
另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。
免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人
   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。</description>
    </item>
    
    <item>
      <title>【Windows】開啟運行程式的所在資料夾位置</title>
      <link>https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/</link>
      <pubDate>Mon, 12 Apr 2021 11:48:04 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/</guid>
      <description>Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。
還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。
Solution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！</description>
    </item>
    
    <item>
      <title>【.NET】適合初心者的 .NET Core MVC 實作</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/</link>
      <pubDate>Sat, 10 Apr 2021 14:06:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/</guid>
      <description>此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。
UI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。
代碼部分已上傳到 GitHub
Start  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。
Visual Studio IDE 建立 【ASP.NET Core Web 應用程式】</description>
    </item>
    
    <item>
      <title>【Windows】如何分割視窗/畫面</title>
      <link>https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/</link>
      <pubDate>Thu, 01 Apr 2021 12:59:03 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/</guid>
      <description>Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？
Solution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。
如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！
視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔
 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側
 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。
視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置
 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。</description>
    </item>
    
    <item>
      <title>【Windows】使用 DOS 指令切換當前硬碟</title>
      <link>https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/</link>
      <pubDate>Wed, 31 Mar 2021 15:53:25 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/</guid>
      <description>紀錄一下每次使用命令提示字元想從 C:\ 切換到 D:\ 時，都會喪失記憶，一直使用 CD D:\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。
其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。</description>
    </item>
    
    <item>
      <title>【MSSQL】如何改善 SQL 常見的效能問題</title>
      <link>https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/</link>
      <pubDate>Tue, 30 Mar 2021 10:42:18 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/</guid>
      <description>Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。
查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）
何謂全表掃描（Full Table Scan）？
簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。
以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。
  避免使用 NULL
SELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 &amp;lt;&amp;gt; 和 !=，使用 &amp;gt;= 或 &amp;lt;= 來取代
  避免使用 or 來連接條件
SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].</description>
    </item>
    
    <item>
      <title>【.NET】打造 Blazor ToDoList</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/</link>
      <pubDate>Sun, 28 Mar 2021 21:47:49 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/</guid>
      <description>Prerequisites .NET 5.0 SDK 或之後的版本
Start 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。
建立新專案 選擇【Blazor 應用程式】專案
選擇【Blazor Server 應用程式】樣板
建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。
建立 Razor 元件時要注意
 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page &amp;quot;/todo&amp;quot;
@page &amp;#34;/todo&amp;#34; &amp;lt;h3&amp;gt;Todo&amp;lt;/h3&amp;gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼
&amp;lt;ul class=&amp;#34;nav flex-column&amp;#34;&amp;gt; ... &amp;lt;li class=&amp;#34;nav-item px-3&amp;#34;&amp;gt; &amp;lt;NavLink class=&amp;#34;nav-link&amp;#34; href=&amp;#34;todo&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;oi oi-list-rich&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; Todo &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.</description>
    </item>
    
    <item>
      <title>【Windows】如何改變命令提示字元(cmd)視窗預設大小</title>
      <link>https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/</link>
      <pubDate>Sat, 27 Mar 2021 21:56:15 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/</guid>
      <description>Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！
Solution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】
Step2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。
Note 【OS】Win10</description>
    </item>
    
    <item>
      <title>【Windows】分享本地硬碟供遠端使用</title>
      <link>https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/</link>
      <pubDate>Fri, 26 Mar 2021 16:45:48 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/</guid>
      <description>Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C &amp;amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。
Solution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。
Step1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】
Step2 展開磁碟機選擇要與遠端分享的硬碟
Step3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享
Note OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。</description>
    </item>
    
    <item>
      <title>【Windows】遠端桌面連線無法複製貼上？</title>
      <link>https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/</link>
      <pubDate>Thu, 25 Mar 2021 16:13:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/</guid>
      <description>Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 &amp;amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。
Solution Step1 檢查剪貼簿功能是否有開啟
【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能
Step2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。
Note 那麼為何 File Copy 會當掉？
有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。</description>
    </item>
    
    <item>
      <title>【Windows】開啟遠端桌面連線剪貼簿/印表機功能</title>
      <link>https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/</link>
      <pubDate>Wed, 24 Mar 2021 20:25:01 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/</guid>
      <description>Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可
Note 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？
【傳送門】【Windows】遠端桌面連線無法複製貼上？</description>
    </item>
    
    <item>
      <title>【GitHub】在 GitHub Pages 建立靜態網站</title>
      <link>https://fakestandard.github.io/post/github/github-1-githubpage/</link>
      <pubDate>Mon, 22 Mar 2021 15:56:58 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/github/github-1-githubpage/</guid>
      <description>GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。
在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。
Create a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。
首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。
下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！
Git client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git</description>
    </item>
    
    <item>
      <title>【Life Trip】北投享溫泉/石牌老牌肉丸</title>
      <link>https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/</link>
      <pubDate>Sun, 21 Mar 2021 14:04:26 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/</guid>
      <description>【紀錄 2021/3/20】
美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。
這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～
想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～
周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…
本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～
正門口
建築物外觀
湯屋內設施
正門木頭椅
整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。
結論，下次想使用客房得提前先預訂。
BTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！
泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。
取自網路的招牌
美食享用
兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。
原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～
到家時間 am 2:30</description>
    </item>
    
    <item>
      <title>【Markdown】筆記神器</title>
      <link>https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/</link>
      <pubDate>Fri, 19 Mar 2021 09:46:52 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/</guid>
      <description>前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。
應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。
標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高
# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 &amp;lt;h1&amp;gt; 到 &amp;lt;h6&amp;gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。
斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 &amp;lt;em&amp;gt; 標籤包圍
*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 &amp;lt;strong&amp;gt;
**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現
***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 &amp;lt;p&amp;gt;。</description>
    </item>
    
    <item>
      <title>【賀】新開張！</title>
      <link>https://fakestandard.github.io/post/other/other-1-newblog/</link>
      <pubDate>Wed, 17 Mar 2021 17:10:35 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/other/other-1-newblog/</guid>
      <description>前言 恭賀本人的部落格又開張了！
歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…
OK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…
正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。
某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…
接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…
過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…
說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…
前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo &amp;amp; pick theme，終於大功造成！
結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。</description>
    </item>
    
  </channel>
</rss>
