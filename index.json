[{"content":"前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。\nStart 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下\nModel public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable\u0026lt;Export_ClosedXML.Models.Employee\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-success\u0026#34; asp-action=\u0026#34;csvExport\u0026#34;\u0026gt;csv Export\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026#34;table table-hover\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.ID) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.FirstName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.LastName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.City) \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var item in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.ID) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.FirstName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.LastName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.City) \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; OK. 前置作業準備完成。\n接著在 EmployeeController 添加一個 csvExport 的 Action，在動作方法內撰寫匯出的代碼，特別注意 ContentType 的部分是 text/csv，收工！\n/// \u0026lt;summary\u0026gt; /// 匯出 csv /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult csvExport() { try { StringBuilder sb = new StringBuilder(); // 取得類別的欄位名稱  var headerList = typeof(Employee).GetProperties().Select(m =\u0026gt; m.Name).ToList(); // 添加所有欄位  sb.AppendLine(String.Join(\u0026#39;,\u0026#39;, headerList)); // 添加內容  foreach (Employee employee in employees) { sb.AppendLine($\u0026#34;{employee.ID}, {employee.FirstName}, {employee.LastName}, {employee.Title}, {employee.City}\u0026#34;); } byte[] buffer = Encoding.UTF8.GetBytes(sb.ToString()); return File(buffer, \u0026#34;text/csv\u0026#34;, \u0026#34;EmployeeExport.csv\u0026#34;); } catch (Exception ex) { return File(Encoding.Unicode.GetBytes(ex.Message), \u0026#34;application/x-unknown\u0026#34;, \u0026#34;error.txt\u0026#34;); } } Reference Common MIME types\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/","summary":"前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。\nStart 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下\nModel public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable\u0026lt;Export_ClosedXML.","title":"【.NET】將資料匯出成 CSV"},{"content":"開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。\n這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub\n【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用\nStart 首先到 NuGet 安裝套件\nModel 建立資料模型\npublic class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料\npublic class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕\n@model IEnumerable\u0026lt;Export_ClosedXML.Models.Employee\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-success\u0026#34; asp-action=\u0026#34;Export\u0026#34;\u0026gt;Simple Export\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026#34;table table-hover\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.ID) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.FirstName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.LastName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.City) \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var item in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.ID) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.FirstName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.LastName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.City) \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 截至目前為止資料的前置作業已完成，為了不做資料庫設定，這邊直接快速產生資料並呈現。\n下一步為匯出按鈕建立一個具有 HttpPost 的 Export 動作方法，記得引用命名空間 using ClosedXML.Excel;\n/// \u0026lt;summary\u0026gt; /// 匯出 Excel /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult Export() { try { // 取得類別的欄位名稱  var headerList = typeof(Employee).GetProperties().Select(m =\u0026gt; m.Name).ToList(); string contentType = \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;; //string contentType = \u0026#34;application/vnd.ms-excel\u0026#34;;  string fileName = \u0026#34;EmployeeExport.xlsx\u0026#34;; // 建立工作簿  IXLWorkbook wb = new XLWorkbook(); // 建立工作表  IXLWorksheet sheet = wb.Worksheets.Add(\u0026#34;Employee\u0026#34;); // 合併儲存格  sheet.Range(1, 1, 1, headerList.Count()).Merge(); sheet.Cell(1, 1).Value = \u0026#34;Employee Report\u0026#34;; // 樣式-背景色  sheet.Cell(1, 1).Style.Fill.SetBackgroundColor(XLColor.AppleGreen); // 字體大小  sheet.Cell(1, 1).Style.Font.SetFontSize(12); // 粗體  sheet.Cell(1, 1).Style.Font.SetBold(); // 水平垂直對齊方式  sheet.Cell(1, 1).Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Center; sheet.Cell(1, 1).Style.Alignment.Vertical = XLAlignmentVerticalValues.Center; // 標題列寫入 / ClosedXML 的 row 或 cell 都是從 1 開始  for (int i = 1; i \u0026lt;= headerList.Count(); i++) { sheet.Cell(2, i).Value = headerList[i - 1]; // 上框線  sheet.Cell(2, i).Style.Border.SetTopBorder(XLBorderStyleValues.Double); } // 內容寫入  for (int i = 1; i \u0026lt;= employees.Count(); i++) { sheet.Cell(i + 2, 1).Value = employees[i - 1].ID; sheet.Cell(i + 2, 2).Value = employees[i - 1].FirstName; sheet.Cell(i + 2, 3).Value = employees[i - 1].LastName; sheet.Cell(i + 2, 4).Value = employees[i - 1].Title; sheet.Cell(i + 2, 5).Value = employees[i - 1].City; } // 自適應欄寬  sheet.Columns().AdjustToContents(); using (MemoryStream ms = new MemoryStream()) { // 將檔案存入記憶流  wb.SaveAs(ms); // 記憶流轉換成 byte[]  var content = ms.ToArray(); return File(content, contentType, fileName); } } catch (Exception ex) { return File(System.Text.Encoding.Unicode.GetBytes(ex.Message), \u0026#34;application/x-unknown\u0026#34;, \u0026#34;error.txt\u0026#34;); } } 這樣就完成簡易的匯出，順便補充 ContentType 的對應\n   Extension ContentType     .xls application/vnd.ms-excel   .xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet    Reference ClosedXML\nCommon MIME types\nGitHub ClosedXML\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/","summary":"開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。\n這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub\n【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用\nStart 首先到 NuGet 安裝套件\nModel 建立資料模型\npublic class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料\npublic class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕","title":"【.NET】使用 ClosedXML 實現匯出 Excel 功能"},{"content":"【4/14 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。\n在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成\n 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。\n日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。\n對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。\nNote 特性\n 記憶體空間配置的儲存方式為不連續且隨機  優點\n 刪除或插入資料無須移動大量資料  缺點\n 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/","summary":"【4/14 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。\n在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成\n 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。\n日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。\n對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。\nNote 特性\n 記憶體空間配置的儲存方式為不連續且隨機  優點\n 刪除或插入資料無須移動大量資料  缺點\n 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】","title":"【Algorithm】資料結構—鏈結串列（Linked List）"},{"content":"【紀錄 2021/4/2-4/4】\n2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）\n這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～\n話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！\n因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。\n出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka \u0026amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。\n出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！\n第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。\n第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！\n沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」\n這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。\n敲敲打打的一行人\n因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。\n努力掛內帳的孩子\n第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！\n度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！\n麻辣鴛鴦鍋\n晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。\n山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！\n因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。\n無用配件\n冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD\n隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。\n第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。\n早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。\n專業備料\n專業煎牛排組\n羅宋湯 \u0026amp; 牛排\n結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！\n大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。\n打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。\n這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。\nW 老闆的下午茶\n時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。\n有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。\n到了晚餐時光，這一天吃飯彷彿接力賽，嘴巴也沒停過，不停的吃喝。晚餐直接選用前一晚的食材，直接涮起壽喜燒，壽喜燒的醬調配的挺好，值得回鍋購入。不過，好像沒有人有拍照，照片只好從缺。\n在收碗盤的過程中，朋友 B 買了營火，對男士而言，營火散發一種獨特魅力，會想待在營火旁，不停地看著，必要時燒個木柴，此趟也不免俗地來玩一下，營火還有個好處，晚上圍繞著它取暖超舒服。\n男士熱愛的營火\n收拾完，一行人念念不忘昨晚的獵巫，戀戰的他們，今晚，廝殺到三點…\n連續兩晚的獵巫鎮，過程中不斷地出現狼人術語，各種表水、對跳、高玩等等，一直出現要獵狼，你就是狼等等有關狼的話語，可獵巫的核心是女巫阿，這票人狼人殺中毒太深了！\n時光飛逝，來到第三日早晨，這天大夥隨意吃個早餐，吃完就要慢慢收拾，準備收心回家。\n最後，此趟所有餐點都與大夥共食，食材準備和烹飪部分以分工為主，不得不說，這次主廚團太強了，除了準備食材外，還附上各種美學的鍋碗瓢盆，五星級的擺盤技術，配上一流的專業攝影，口味的部分也讓人豎起大拇指讚賞一番！\n美學小物\n公共桌\n在詞彙有限的狀態下，想仔細紀錄每個細節，不小心寫得如此冗長，宛如露營，出發前準備的齊全，到頭來不一定都能派上用場，難道這就是所謂的甘願做歡喜受？\n","permalink":"https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/","summary":"【紀錄 2021/4/2-4/4】\n2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）\n這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～\n話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！\n因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。\n出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka \u0026amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。\n出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！\n第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。\n第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！\n沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」\n這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。\n敲敲打打的一行人\n因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。\n努力掛內帳的孩子\n第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！\n度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！\n麻辣鴛鴦鍋\n晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。\n山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！\n因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。\n無用配件\n冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD\n隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。\n第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。\n早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。\n專業備料\n專業煎牛排組\n羅宋湯 \u0026amp; 牛排\n結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！\n大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。\n打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。\n這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。\nW 老闆的下午茶\n時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。\n有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。","title":"【Life Trip】五峰星空下露營區"},{"content":"開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。\n代碼存放於 GitHub\nStart 首先到 NuGet 套件添加 NPOI Package\n建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable\n/// \u0026lt;summary\u0026gt; /// 資料庫連線方法 /// \u0026lt;/summary\u0026gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = \u0026#34;.\u0026#34;; cnsb.InitialCatalog = \u0026#34;Northwind\u0026#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = \u0026#34;SELECT * FROM [Northwind].[dbo].[Orders]\u0026#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.Fill(ds); // 將 DataSet 的資料倒入 DataTable  DataTable dt = ds.Tables[0]; return dt; } 引用命名空間\nusing NPOI; using NPOI.SS.UserModel; using NPOI.XSSF.UserModel; using NPOI.HSSF.UserModel; 匯出資料 建立 SimpleExport 方法，該方法具有兩個參數，\n DataTable ：要匯出的資料 path ：要匯出的目的地路徑  /// \u0026lt;summary\u0026gt; /// 匯出 Excel 簡易方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;dt\u0026#34;\u0026gt;要匯出的資料\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;path\u0026#34;\u0026gt;要匯出的目的地路徑\u0026lt;/param\u0026gt; static void SimpleExport(DataTable dt, string path) { // 建立工作簿  IWorkbook wb = new XSSFWorkbook(); // .xls  // IWorkbook wb = new HSSFWorkbook();  using (FileStream fs = File.Create(path)) { // 建立名為 Simple 的工作表  ISheet sheet = wb.CreateSheet(\u0026#34;Simple\u0026#34;); int i = 0; int j = 0; #region Title  // 建立新的 row 給標題用  sheet.CreateRow(0); for (i = 0; i \u0026lt; dt.Columns.Count; i++) { // 取得已建立的 row ，再建立 cell，最後再配置值給 cell  sheet.GetRow(0).CreateCell(i).SetCellValue(dt.Columns[i].ColumnName); } #endregion  #region Content  // 走訪 dt  for (i = 1; i \u0026lt;= dt.Rows.Count; i++) { sheet.CreateRow(i); for (j = 0; j \u0026lt; dt.Columns.Count; j++) { // 因為建立過的 row 或 cell 再次建立會覆蓋原有的值，所以建立過的物件使用 Get 取得再設置 Value  sheet.GetRow(i).CreateCell(j).SetCellValue(dt.Rows[i-1][j].ToString()); } } #endregion  // 將 wb 寫出到檔案流  wb.Write(fs); // 釋放資源  wb.Close(); wb = null; sheet = null; } } 該方法先建立工作簿（Workbook），工作簿下建立工作表（Sheet），接著建立資料行（row），資料行內建立單元格（cell），依此階層順序將資料填入到單元格內。\n值得注意一開始建立工作簿使用的 XSSFWorkbook 物件，該物件為操作 Excel 2007 開始且包含之後的版本，產出的副檔名為 .xlsx，相對的 HSSFWorkbook 物件為操作 Excel 97-2003 之間的版本，產出的副檔名為 .xls，建立工作簿時可依需求決定要產出版本。\n   Namespace Class Extension     NPOI.XSSF.UserModel XSSFWorkbook .xlsx   NPOI.HSSF.UserModel HSSFWorkbook .xls    版面設置 紀錄常用設置\n列印 紙張大小 sheet.PrintSetup.PaperSize = (short)PaperSize.A4;\n版面方向 sheet.PrintSetup.Landscape = true;\n 橫向：true 縱向：false  設置列印標題（上側）\nsheet.RepeatingRows = new NPOI.SS.Util.CellRangeAddress(fRow, lRow, fCol, lCol);\n fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  設置列印標題（左側）\nsheet.RepeatingColumns = new NPOI.SS.Util.CellRangeAddress(fRow, lRow, fCol, lCol);\n fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  頁尾頁碼 sheet.Footer.Center = \u0026quot;\u0026amp;P\u0026quot;;\n Left：靠左 Center：置中 Right：靠右  格線 顯示狀態 sheet.DisplayGridlines = true;\n 顯示：true 不顯示：false  欄寬和行高 設置欄寬大小 sheet.SetColumnWidth(0, 20 * 256);\n自動調整欄寬\nfor (i = 0; i \u0026lt; dt.Columns.Count; i++) { sheet.AutoSizeColumn(i); } 設置行高 sheet.GetRow(0).Height = 30 * 20;\n合併儲存格 CellRangeAddress region = new CellRangeAddress(fRow, lRow, fCol, lCol); sheet.AddMergedRegion(region);  fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  儲存格樣式 先建立 XSSFCellStyle 物件\nXSSFCellStyle style = (XSSFCellStyle)wb.CreateCellStyle(); 多行文字(自動換行) style.WrapText = true;\n文字水平置中 style.Alignment = HorizontalAlignment.Center;\n文字垂直置中 style.VerticalAlignment = VerticalAlignment.Center;\n背景色 style.FillForegroundColor = new XSSFColor(Color.Red).Index;\n背景色樣式 style.FillPattern = FillPattern.SparseDots;\n框線樣式\n 上 style.BorderTop = BorderStyle.DashDot; 下 style.BorderBottom = BorderStyle.Double; 左 style.BorderLeft = BorderStyle.Hair; 右 style.BorderRight = BorderStyle.Thick;  框線顏色\n 上 style.TopBorderColor = new XSSFColor(Color.Chocolate).Index; 下 style.BottomBorderColor = new XSSFColor(Color.DarkOrange).Index; 左 style.LeftBorderColor = new XSSFColor(Color.Pink).Index; 右 style.RightBorderColor = new XSSFColor(Color.Purple).Index;  最後將自定義 Style 賦給單元格\nfor (i = 1; i \u0026lt; dt.Columns.Count; i++) { sheet.GetRow(0).GetCell(i).CellStyle = style; } 字體樣式 先建立 XSSFFont 物件\nXSSFFont font = (XSSFFont)wb.CreateFont(); 字體樣式 font.FontName = \u0026quot;Arial\u0026quot;;\n字體顏色 font.SetColor(new XSSFColor(Color.Blue));\n粗體 font.IsBold = true;\n斜體 font.IsItalic = true;\n刪除線 font.IsStrikeout = true;\n字體大小 font.FontHeightInPoints = 20;\n最後將自定義 Font 賦給自定義 Style\nstyle.SetFont(font); 凍結窗格 凍結頂端列 sheet.CreateFreezePane(0, 1, 0, 1);\n凍結左欄 sheet.CreateFreezePane(1, 0, 1, 0);\nReference https://github.com/nissl-lab/npoi\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/","summary":"開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。\n代碼存放於 GitHub\nStart 首先到 NuGet 套件添加 NPOI Package\n建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable\n/// \u0026lt;summary\u0026gt; /// 資料庫連線方法 /// \u0026lt;/summary\u0026gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = \u0026#34;.\u0026#34;; cnsb.InitialCatalog = \u0026#34;Northwind\u0026#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = \u0026#34;SELECT * FROM [Northwind].[dbo].[Orders]\u0026#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.","title":"【.NET】使用 NPOI 匯出 Excel 的基本應用"},{"content":"【4/11 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。\n靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。\n操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。\n陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。\n使用一維陣列尋找和儲存 1~num 之間的所有質數\nconst int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m \u0026lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i \u0026lt; num; i++) { if (prime[i]) { if (c == 10) { Console.WriteLine(); c = 0; } Console.Write(i + \u0026#34; \u0026#34;); c++; count++; } } Console.WriteLine(); Console.WriteLine($\u0026#34;總共 {count} 個質數\u0026#34;); 使用先前判斷質數的方法\nstatic bool IsPrime(int n) { int i = 2; while (i \u0026lt; n) { // 如果整除, i 為 n 的因數  if (n % i == 0) return false; i++; } return true; } 書籍撰寫代碼參考\nconst int MAX = 300; bool[] prime = new bool[MAX]; prime[0] = true; prime[1] = true; int num = 2, i; while (num \u0026lt; MAX) { if (!prime[num]) { for (i = num + num; i \u0026lt; MAX; i += num) { if (prime[i]) continue; prime[i] = true; } } num++; } for (i = 2, num = 0; i \u0026lt; MAX; i++) { if (!prime[i]) { Console.Write(i + \u0026#34;\\t\u0026#34;); num++; } } Console.WriteLine($\u0026#34;總共 {num} 個質數\u0026#34;); Note 特性\n 空間所配置的儲存方式為連續記憶體 提供索引功能 為靜態資料結構，編譯時必須先配置記憶體空間  優點\n 讀取和修改速度快  缺點\n 刪除和新增必須移動大量資料  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-3-array/","summary":"【4/11 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。\n靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。\n操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。\n陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。\n使用一維陣列尋找和儲存 1~num 之間的所有質數\nconst int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m \u0026lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i \u0026lt; num; i++) { if (prime[i]) { if (c == 10) { Console.","title":"【Algorithm】資料結構—陣列（Array）"},{"content":"【4/11 閱讀紀錄】\n此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。\nStart 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。\n一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。\n 資料型態  基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）    資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。\n基本資料型態（Primitive Data Type） 基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。\n結構化資料型態（Structured Data Type） 結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。\n抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-2-datastructure/","summary":"【4/11 閱讀紀錄】\n此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。\nStart 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。\n一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。\n 資料型態  基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）    資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。\n基本資料型態（Primitive Data Type） 基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。\n結構化資料型態（Structured Data Type） 結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。\n抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。\nReference 【圖說演算法 C#】","title":"【Algorithm】資料結構定義與資料型態"},{"content":"這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。\n一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。\n西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。\nSolution 有三種解決方案\n 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間\n引用命名空間\n System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $\u0026#34;{year}/{month}/{day}\u0026#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。\n/// \u0026lt;summary\u0026gt; /// 靜態擴展類別 /// \u0026lt;/summary\u0026gt; public static class DateTimeExtend { /// \u0026lt;summary\u0026gt;  /// 靜態擴展方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;dateTime\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; return $\u0026#34;{year}/{month}/{day}\u0026#34;; } } 替換當前執行緒的文化特性 不想在每次遇到時間時，才透過方法來轉換民國年與西元年，那直接設定執行緒的 Cultrue 最便利。\n引用命名空間\n System.Globalization System.Threading  // 指定 zh-TW CultureInfo culture = new CultureInfo(\u0026#34;zh-TW\u0026#34;); // 西曆 culture.DateTimeFormat.Calendar = new GregorianCalendar(); // 民國曆 //culture.DateTimeFormat.Calendar = new TaiwanCalendar();  // 將自建物件指給當前執行緒使用 Thread.CurrentThread.CurrentCulture = culture; Thread.CurrentThread.CurrentUICulture = culture; Console.WriteLine(DateTime.Now.ToShortDateString()); 由上列的代碼可以看到分別使用的物件為\n 西曆 GregorianCalendar 民國曆 TaiwanCalendar  在做轉換時，只需建立欲轉換的物件並指給 Culture，最後在將自訂的 Culture 指給執行緒使用，即可達到效果。\nNote 如何取得 DateTime 型別的日期部分？\nDateTime dateTime = new DateTime(2020, 2, 29); Console.WriteLine(dateTime.Date); 使用 Date 屬性，結案！\nReference TaiwanCalendar Class\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/","summary":"這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。\n一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。\n西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。\nSolution 有三種解決方案\n 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間\n引用命名空間\n System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $\u0026#34;{year}/{month}/{day}\u0026#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。\n/// \u0026lt;summary\u0026gt; /// 靜態擴展類別 /// \u0026lt;/summary\u0026gt; public static class DateTimeExtend { /// \u0026lt;summary\u0026gt;  /// 靜態擴展方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;dateTime\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.","title":"【.NET】西元年與民國年相互轉換"},{"content":"一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。\n首先要了解所得稅分為以下兩種\n 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）\n所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。\n收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。\n計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的\n綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額\n接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。\n所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。\n假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。\n那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！\n另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。\n免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人\n   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。\n標準扣除額 標準扣除額非常好理解，只分為兩種\n   身份 可扣除額度     單身者 120,000/人   已婚者 240,000/人    如果你是單身者，該項目就為 120,000，已婚者就是乘二為 240,000\n列舉扣除額 先說結論，標準扣除額和列舉扣除額兩者是擇一扣除，可以先試算兩者的金額，在選擇對自己有利的項目申報，選擇較高的金額作為扣除項目較有利。\n列舉扣除額有以下項目可申報\n 捐贈 保險 自宅 租屋 醫藥及生育費 災害損失  因為列舉扣除額包含的的項目較多，每個項目也就不一一說明，筆者大概看了一下，並在心中試算額度，比標準扣除額的 12 萬來的低，就不多花時間在此，詳細內容請參考下方的財政部連結。\n財政部稅務入口網-扣除額篇\n特別扣除額 該特別扣除額包含報稅的納稅義務人，若有配偶或受扶養親屬也適用下列條件\n   項目 扣除額 適用條件     薪資所得特別扣除額 200,000/人 有薪資收入者   身心障礙特別扣除額 200,000/人 具備身心障礙證明者   幼兒學前特別扣除額 120,000/人 育有學齡前幼兒   教育學費特別扣除額 25,000/人 受扶養子女就讀經教育部認可之國內外大專院校   儲蓄投資特別扣除額 270,000/戶 有金額機構存款利息、儲蓄性質信託資金等收益   長期照顧特別扣除額 120,000/人 符合身心失能條件    以筆者的情況來說，可以先扣除一人份的薪資所得 200,000，假設有配偶且具有薪資收入並一同申報，則可扣除兩人份的薪資所得扣除額 200,000 * 2 = 400,000，值得注意儲蓄投資特別扣除額是以每申報戶為單位，申報上限為 270,000，與先前扣除額不同之處是有多少計多少，假設去年度存款利息有 3,000，該項目應計入 3,000，以此類推。\n基本生活費差額 首先先計算基本生活費總額，每人以 175,000 計算，納稅義務人若同時有配偶和一位扶養眷屬，則基本生活費總額為 175,000 * 3 = 525,000。\n得知基本生活費總額之後，再計算基本生活費差額，公式為\n基本生活費差額 = 基本生活費總額 - 免稅額 - 一般(標準/列舉)扣除額 - 儲蓄投資特別扣除額 - 身心障礙特別扣除額 - 教育學費特別扣除額 - 幼兒學前扣除額 - 長期照顧特別扣除額\n看起來非常攏長，原因是特別扣除額的部分並非全部都能是減項，計算基本生活費差額時，「薪資所得特別扣除額」不能納入計算。\n如果基本生活費差額算出來為負數，則該項目金額則以 0 計算，反之，算出來為正數，則可從所得稅中扣除。\n綜合所得稅額級距與累進差額試算表 綜合所得稅淨額參考對應的稅率，計算應繳納稅額，計算公式為\n所得稅應納稅額 = 綜合所得淨額 * 稅率 - 累進差額\n根據上述林林總總所計算出的的綜合所得淨額，依照此公式及對應下表應有的級距，得以計算出當年度綜合所得稅額，就是今年度要繳納的稅額！\n   綜合所得淨額區間 適用稅率 累進差額     0 - 540,000 5% 0   540,001 - 1,210,000 12% 37,800   1,210,001 - 2,420,000 20% 134,600   2,420,001 - 4,530,000 30% 376,600   4,530,001 以上 40% 829,600    案例 小明是位年收 60 萬的單身貴族，沒有其他收入所得，也未有撫養的眷屬，他當年度的稅額計算方式為\n基本生活費差額 = ( 17.5 萬 - 8.8 萬 - 12 萬) = -3.3 萬，所以該項目以 0 計算\n綜合所得淨額 = 薪資所得 60 萬 - 免稅額 8.8 萬 - 標準扣除額 12 萬 - 薪資所得特別扣除額 20 萬 - 基本生活費差額 0 萬 = 19.2 萬\n所得稅應納稅額 = 19.2 萬 * 稅率 5% - 累進差額 0 = 9,600\n此案例的小明最終須繳交 9,600 元的個人綜合所得稅。\n最後，筆者也算出今年度需要繳納的稅額，因為也沒什麼好扣的，計算方式同上案例非常簡單，但看到要繳納的金額，覺得心在淌血…（哭）\n","permalink":"https://fakestandard.github.io/post/other/other-2-incometax/","summary":"一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。\n首先要了解所得稅分為以下兩種\n 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）\n所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。\n收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。\n計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的\n綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額\n接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。\n所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。\n假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。\n那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！\n另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。\n免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人\n   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。","title":"【人森】如何計算個人綜合所得稅？"},{"content":"Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。\n還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。\nSolution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！\n","permalink":"https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/","summary":"Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。\n還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。\nSolution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！","title":"【Windows】開啟運行程式的所在資料夾位置"},{"content":"此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。\nUI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。\n代碼部分已上傳到 GitHub\nStart  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。\nVisual Studio IDE 建立 【ASP.NET Core Web 應用程式】\n選擇 【ASP.NET Core Web 應用程式(Model-View-Controller)】\n下拉選單選擇 .Net Core 和 ASP.NET Core 5.0\n執行 Ctrl + F5 啟動 IIS Express 以執行應用程式，並且不執行偵錯。不啟用偵錯工作的好處是可隨時變更程式碼並且隨時儲存，當程式碼變更可重新整理瀏覽器快速查看。\n觀察瀏覽器網址列顯示 localhost:{port}，本機電腦的 hostname 為 localhost，{port} 是當 Visual Studio 建立 Web project 時，會自動分配一個隨機通訊埠號給網頁伺服器。\nCommand Shell 開啟終端機或 VS Code 終端機，切換到欲新增專案的目錄\n在當前目錄建立新的 ASP.NET Core MVC 專案\n$ dotnet new mvc -o MvcMovie 如果是使用 VS Code，下列指令可在 VS Code 直接載入 MvcMovie.csproj 專案檔\n$ code -r MvcMovie 信任 Https 開發憑證\n$ dotnet dev-certs https --trust 接著同上述執行 Ctrl + F5 啟動應用程式，詳細內容請往回參考。\n新增控制器（Controller） 在方案總管中，對 Controllers 資料夾執行右鍵→選擇加入→控制器。\n選擇【MVC 控制器 - 空白】\n將控制器名稱更改為 HelloWorldController.cs，並且新增。\n此時啟動應用程式瀏覽 https://localhost:{Port}/HelloWorld/ 會返回錯誤，因為我們還沒建立檢視器（View）。\n新增檢視器（View） 建立檢視器方法有兩種，一種是從方案總管中建立，一種是快速建立。筆者推薦使用快速建立。\n方案總管 對 Views 資料夾執行右鍵→加入→資料夾，該資料夾名稱命名為欲建立 View 的控制器名稱，這邊將它命名為 HelloWorld。\n對新增的 HelloWorld 資料夾，執行右鍵→加入→檢視，選擇 Razor 檢視 - 空白。\nView 的名稱應命名為控制器之動作方法名稱，與動作方法與之對應。開啟 HelloWorldController.cs 可以看見預設建立的 Index() 動作方法，該方法就是這次要建立檢視器的名稱 Index.cshtml。\n快速建立 開啟 HelloWorldControll.cs，在 Index() 方法上執行右鍵，選擇新增檢視。接著就與上述建立方法相同，選擇 Razor 檢視 - 空白，建立名為 Index.cshtml 檢視器。\n變更檢視及版面配置 打開剛剛建立的 View 修改代碼以變更呈現內容\n\u0026lt;!--index.cshtml--\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;h2\u0026gt;Index\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Hello from our View Template!\u0026lt;/p\u0026gt; 在版面配置中添加 HelloWorld Controller 的導航配置，開啟 Views/Shared/_Layout.cshtml 找到配置導航的位置添加以下代碼\n\u0026lt;div class=\u0026#34;navbar-collapse collapse d-sm-inline-flex justify-content-between\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav flex-grow-1\u0026#34;\u0026gt; ... \u0026lt;!--要添加的代碼--\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;HelloWorld\u0026#34; asp-action=\u0026#34;Index\u0026#34;\u0026gt;HelloIndex\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;!--先添加 Movies，後續在新增 Movies Controller--\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34;\u0026gt;Movies\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 效果\n新增模型（Model） 模型以實際層面來說即是類別，建立模型實際動作就是建立一個類別，將建立的類別作為 Model 使用。\nEntity Framework Core（EF Core） 是一種物件關聯式架構（Object-relational mapping, ORM），在撰寫資料存取的代碼時，透過 ORM 可簡化這些代碼。所以你可以將類別與 EF Core 搭配使用以操作資料庫。\n這些自行建立的類別被稱為 POCO（Plain Old CLR Objects），因為它們只定義儲存在資料庫中的資料屬性，對 EF Core 不具有任何相依性。\n建立類別 在 Models 資料夾執行右鍵→選擇加入→類別，將類別命名為 Movie.cs，在類別內添加下列代碼\nusing System; using System.ComponentModel.DataAnnotations; namespace CoreMVCMovieList.Models { public class Movie { public int Id { get; set; } public string Title { get; set; } [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } public string Genre { get; set; } public decimal Price { get; set; } } } 新增 NuGet 套件 在 ASP.NET Core 中欲使用 Entity Framework Core 需安裝 Microsfot.EntityFrameworkCore Package，使用下列指令來安裝套件\n$ dotnet add package Microsoft.EntityFrameworkCore EF 通常都是搭配 SQL Server，開啟套件管理器主控台，執行下列指令，以添加 EF Core SQL Server Provider\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer 建立 DbContext DbContext 類別為 EF Core 與資料庫的溝通橋樑，在專案下建立 MvcMovieContext.cs 類別，並繼承 DbContext 類別以定義與資料庫的溝通行為，同時建立 DbSet\u0026lt;Movie\u0026gt;　實體集（Entity Set）。\n在 Entity Framework 下，通常實體集（Entity Set）對應於資料表，實體（Entity）對應於資料表中的資料列，EF Core 會自動幫我們轉換實體集與實體的部分。\nusing CoreMVCMovieList.Models; using Microsoft.EntityFrameworkCore; namespace CoreMVCMovieList { public class MvcMovieContext : DbContext { public MvcMovieContext(DbContextOptions\u0026lt;MvcMovieContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Movie\u0026gt; Movie { get; set; } } } 新增 ConnectionString 以往應用程式有 app.config 可以設定，Web 則有 web.config 可以設置連線字串，在 .Net Core 下 .config 配置文件已經消失，改成使用 JSON 格式的 appsettings.json 配置相關設定。\n添加 ConnectionString 節點的代碼\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MvcMovieContext\u0026#34;: \u0026#34;Server=(localdb)\\\\mssqllocaldb;Database=MvcMovieContext;Trusted_Connection=True;MultipleActiveResultSets=true\u0026#34; } } 註冊 DbContext ASP.NET Core 建構於相依性注入（Dependency Injection, DI）概念，所有服務必須在應用程式啟動期間向 DI 進行註冊，透過建構函數提供服務給需要服務的元件（如 Razor Page），開啟 Startup.cs 向 DI 容器註冊 DbContext。\n// 添加引用 using MvcMovie.Data; using Microsoft.EntityFrameworkCore; public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews(); // DI 注入  services.AddDbContext\u0026lt;MvcMovieContext\u0026gt;(options =\u0026gt; options.UseSqlServer(Configuration.GetConnectionString(\u0026#34;MvcMovieContext\u0026#34;))); } 在 DbContextOptions 物件上調用方法將連線字串傳遞到 context，而在目前開發中，ASP.NET Core Configuration System 會從 appsetting.json 來取得連線字串。\n使用 Scaffold 在方案總管對 Controllers 資料夾執行右鍵→加入→選擇 新增 Scaffold 項目\n選擇 使用 Entity Framework 執行檢視的 MVC 控制器\n將模型類別與資料內容類別 調整為與下圖相同選項，並勾選檢視的三個複選框，控制器名稱為預設。\n此時已添加 MoviesController.cs 該控制下項已經添加所有 CRUD 等動作方法（Action），但目前未能使用該頁面，因為資料庫還不存在，下一步我們將會建立資料庫。\n 如果使用 Scaffold 建立失敗\n嘗試到 NuGet 安裝 Microsoft.VisualStudio.Web.CodeGeneration.Utils\n 進行初始移轉（Initial Migration） 使用 EF Core 的遷移功能來建立資料庫，Migration 可建立和更新與資料模型相符的資料庫。在套件管理器主控台輸入下列命令\n產生 /{timestamp}_InitialCreate.cs 遷移檔案，因為是第一次移轉，所以產生的類別會以 MvcMovieContext 類別的資料庫結構為基礎。\nAdd-Migration InitialCreate 此命令會執行 Migrations/{time-stamp}_InitialCreate.cs 檔案中的 Up 方法，以建立資料庫。\nUpdate-Database 此時可以啟動應用程式操作新增、刪除、修改等方法，可以發現在執行 CRUD 時都會使用到資料庫，因為在建立 MoviesController.cs 時，已經添加下列的建構函式，然而先前在 DI 容器中已註冊 MvcMovieContext，所以在 Controller 的建構子就可透過 DI 來取得 Context 實例。\nprivate readonly MvcMovieContext _context; public MoviesController(MvcMovieContext context) { _context = context; } 植入資料以初始資料庫 在 Models 資料夾下建立 SeedData.cs 類別，在類別內添加下列代碼\npublic static class SeedData { public static void Initialize(IServiceProvider serviceProvider) { using (var context = new MvcMovieContext( serviceProvider.GetRequiredService\u0026lt; DbContextOptions\u0026lt;MvcMovieContext\u0026gt;\u0026gt;())) { // Look for any movies.  if (context.Movie.Any()) { return; // DB has been seeded  } context.Movie.AddRange( new Movie { Title = \u0026#34;When Harry Met Sally\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1989-2-12\u0026#34;), Genre = \u0026#34;Romantic Comedy\u0026#34;, Price = 7.99M }, new Movie { Title = \u0026#34;Ghostbusters \u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1984-3-13\u0026#34;), Genre = \u0026#34;Comedy\u0026#34;, Price = 8.99M }, new Movie { Title = \u0026#34;Ghostbusters 2\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1986-2-23\u0026#34;), Genre = \u0026#34;Comedy\u0026#34;, Price = 9.99M }, new Movie { Title = \u0026#34;Rio Bravo\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1959-4-15\u0026#34;), Genre = \u0026#34;Western\u0026#34;, Price = 3.99M } ); context.SaveChanges(); } } } 其中這段代表植入資料前，先判斷資料庫中是否已經資料，沒有資料才初始化資料，有的話直接返回，不新增任何資料。\n// Look for any movies. if (context.Movie.Any()) { // DB has been seeded  return; } 開啟 Program.cs 新增初始設定，將 Main 方法內的原始代碼替換成下列代碼\npublic class Program { public static void Main(string[] args) { // CreateHostBuilder(args).Build().Run();  var host = CreateHostBuilder(args).Build(); using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; try { SeedData.Initialize(services); } catch (Exception ex) { var logger = services.GetRequiredService\u0026lt;ILogger\u0026lt;Program\u0026gt;\u0026gt;(); logger.LogError(ex, \u0026#34;An error occurred seeding the DB.\u0026#34;); } } host.Run(); } ... } 啟動應用程式，查看上述的設定，資料庫在有資料的情況下，不做新增資料的動作，將所有資料刪除使得資料庫資料為零，這時再啟動應用程式會發現，資料庫會新增預設的資料。\n使用資料註釋 Data Annotations 目前清單的標題列上顯示的是 Model 的名稱，使用 Data Annotations 來變更顯示名稱。開啟 Models/Movie.cs 替換成下列代碼\n// 需引用的命名空間 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; ... public class Movie { public int Id { get; set; } [Display(Name = \u0026#34;電影名稱\u0026#34;)] public string Title { get; set; } [Display(Name = \u0026#34;放映日期\u0026#34;)] [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } [Display(Name = \u0026#34;類型\u0026#34;)] public string Genre { get; set; } [Display(Name = \u0026#34;價格\u0026#34;)] [Column(TypeName = \u0026#34;decimal(18, 2)\u0026#34;)] public decimal Price { get; set; } } 結果如下\n新增搜尋引擎 目前的清單沒有搜尋引擎，當資料量一多，一頁頁的翻找會很耗時，接下來我們要新增一個搜尋引擎，讓使用者可以搜尋「電影名稱」、「類型」以快速查找。\n搜尋電影名稱 開啟 Vies/Movies/Index.cshtml 添加下列 \u0026lt;form\u0026gt;...\u0026lt;/form\u0026gt; 代碼\n\u0026lt;p\u0026gt; \u0026lt;a asp-action=\u0026#34;Create\u0026#34;\u0026gt;Create New\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!--要添加的代碼--\u0026gt; \u0026lt;form asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 電影名稱: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;SearchString\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Filter\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; ... 開啟 MoviesController.cs 變更 Index 動作方法\n[HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Index(string searchString) { // LINQ 查詢  var movies = from m in _context.Movie select m; if (!String.IsNullOrEmpty(searchString)) { movies = movies.Where(k =\u0026gt; k.Title.Contains(searchString)); } return View(await movies.ToListAsync()); } 效果\n搜尋類型 搜尋類型要以下拉選單的方式呈現，因此先新增 ViewModels 資料夾，再資料夾下新增 MovieGenerViewModel.cs 類別\npublic class MovieGenerViewModel { public List\u0026lt;Movie\u0026gt; Movies { get; set; } public SelectList Genres { get; set; } public string MovieGenre { get; set; } public string SearchString { get; set; } } 進一步修改剛剛的 MoviesController.cs 的 Index 方法\npublic async Task\u0026lt;IActionResult\u0026gt; Index(string movieGenre, string searchString) { var movies = from m in _context.Movie select m; if (!String.IsNullOrEmpty(searchString)) { movies = movies.Where(k =\u0026gt; k.Title.Contains(searchString)); } if (!string.IsNullOrEmpty(movieGenre)) { movies = movies.Where(k =\u0026gt; k.Genre == movieGenre); } // LINQ 取類型資料  IQueryable\u0026lt;string\u0026gt; genreQuery = from m in _context.Movie orderby m.Genre select m.Genre; var movieGenreVM = new MovieGenerViewModel { Genres = new SelectList(await genreQuery.Distinct().ToListAsync()), Movies = await movies.ToListAsync() }; return View(movieGenreVM); } 更新 Views/Movies/Index.cshtml\n\u0026lt;!--將原本傳入的 Model 替換成 MovieGenerViewModel--\u0026gt; @model CoreMVCMovieList.ViewModels.MovieGenerViewModel ... \u0026lt;form asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;!--添加下拉選單--\u0026gt; \u0026lt;select asp-for=\u0026#34;MovieGenre\u0026#34; asp-items=\u0026#34;Model.Genres\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;All\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;!--End--\u0026gt; 電影名稱: \u0026lt;input type=\u0026#34;text\u0026#34; asp-for=\u0026#34;SearchString\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Filter\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; ... \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--因傳入的 Model 結構不同，所以將原本 model.Title 替換成 model.Movies[0].Title--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].ReleaseDate) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Genre) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Price) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; ... \u0026lt;!--同理將要走訪的數組改為 Model.Movies--\u0026gt; @foreach (var item in Model.Movies) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; ... \u0026lt;/tr\u0026gt; } 觀察效果\n新增資料驗證 使用 DataAnnotations Namespace 提供的的驗證屬性，套用到類別或屬性中，開啟 Movie 類別，將 Required、StringLength、RegularExpression、Range 添加到各個屬性上\npublic class Movie { public int Id { get; set; } [Required] [StringLength(60, MinimumLength =3)] [Display(Name = \u0026#34;電影名稱\u0026#34;)] public string Title { get; set; } [Display(Name = \u0026#34;放映日期\u0026#34;)] [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } [Required] [RegularExpression(@\u0026#34;^[A-Z]+[a-zA-Z]*$\u0026#34;)] [Display(Name = \u0026#34;類型\u0026#34;)]  public string Genre { get; set; } [Range(1, 100)] [DataType(DataType.Currency)] [Display(Name = \u0026#34;價格\u0026#34;)] [Column(TypeName = \u0026#34;decimal(18, 2)\u0026#34;)] public decimal Price { get; set; } } 啟動應用程式新增一筆資料，在未填任何資料的情況下按下「新增」按鈕，觀察結果，同樣在編輯頁面若資料不符合驗證規則，會有錯誤提示產生。\n使用 Bootstrap 增強外觀效果 最後一步，由於 .NET Core 已經不會內建樣式，要添加 Bootstrap 等套件需自行到 NuGet 添加，這邊隨手添加一下 Bootstrap 的 Button 及 Table 樣式，使得外觀好看一點。\n完成！\nNote 在 Step by step 過程中，實作的部分很快就能完成，其中有很多原理必須深入研究，待研究有心得再來記錄。\nReference Part 1 - Get started with ASP.NET Core MVC\nPart 2 - Add a controller to an ASP.NET Core MVC app\nPart 3 - Add a view to an ASP.NET Core MVC app\nPart 4 - Add a model to an ASP.NET Core MVC app\nPart 5 - Work with a database in an ASP.NET Core MVC app\nPart 6 - Controller methods and views in ASP.NET Core\nPart 7 - Add search to an ASP.NET Core MVC app\nPart 8 - Add a new field to an ASP.NET Core MVC app\nPart 9 - Add validation to an ASP.NET Core MVC app\nPart 10 - Examine the Details and Delete methods of an ASP.NET Core app\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/","summary":"此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。\nUI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。\n代碼部分已上傳到 GitHub\nStart  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。\nVisual Studio IDE 建立 【ASP.NET Core Web 應用程式】","title":"【.NET】適合初心者的 .NET Core MVC 實作"},{"content":"【3/28 閱讀紀錄】\n此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。\nStart 演算法種類很多，經典的演算法有以下幾種\n 分治演算法（Divide and conquer） 疊代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Exhaustive Searching） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。\n像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。\n然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。\n所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。\n疊代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為疊代演算法，像是透過迴圈去循環重複的程式碼來得到答案。\n舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果\n// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { sum = sum * j; } Console.WriteLine($\u0026#34;{i} != {sum}\u0026#34;); // 重設計算結果  sum = 1; } 執行結果\n1!=1 2!=2 3!=6 4!=24 5!=120 除了上述介紹固定執行次數的疊代法之外，還可以使用 while 迴圈，來執行不確定執行次數的疊代法。使用 while 迴圈必須注意不可讓迴圈一直循環，若執行無法停止就會導致「無窮迴圈」，所以 while 迴圈結構需要具備三個條件\n 變數初始值 迴圈條件式 調整變數增減值  設置一個變數初始值使迴圈得以開始，明確設置迴圈條件式，在符合該條件下迴圈得以循環執行，最終一定要調整變數增減值做為可以離開迴圈的出口。\n// 變數出使值 int i = 1; // 迴圈條件式 while (i \u0026lt;= 10) { Console.WriteLine(i); // 調整變數增減值  i += 1; } 巴斯卡三角形 也是經典中之一，這邊不做進一步介紹。\n遞迴演算法（Recursion Algorithm） 遞迴演算法跟疊代演算法在循環上相似，卻又跟分治演算法的概念類似，遞迴法與分治法相同地將大問題拆解成小問題來解決，又跟疊代法的循環有異曲同工之妙。\n在程式設計裡，設計一種方法並將其封裝起來稱為函數或副程式，通過外部來呼叫函數或副程式執行封裝後的代碼，以定義而言，透過自己來呼叫自己的過程稱為遞迴，可以想像為函數內部又在調用一次函數。遞迴必須具備兩個條件\n 可以反覆執行的程式碼 結束執行過程的出口  遞迴的經典範例「階乘」，階乘的運算式 n! = n*(n-1)*(n-2)...*1，透過階乘運算過程可觀察出一定的規律性，就可以使用遞迴演算法來達成\nstatic int Function(int n) { if (n == 0) // 終止的條件  return 1; else return n * Function(n - 1); // 遞迴呼叫自己 } 經典的費伯那序列（Fibonacci Polynomial）\n參照上圖公式，n 為正整數，第零項為 0、第一項為 1、第二項為本身前兩項的值相加所得，第二項可得 1、第三項為 2，以此類推。找出規律後可嘗試設計出遞迴程式。\nstatic int Fibonacci(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2); } 動態規劃演算法（Dynamic Programming Algorithm） 動態規劃演算法（DPA）與分治法十分相似，先將大問題拆解成小問題，不同的是動態規劃演算法將每個子問題的答案儲存起來，以供下次求解時直接取用，減少相同子問題再次被計算的時間，所以動態規劃法解決了重複計算的缺點。\n依據上述提到的費伯那序列，從上面的路徑圖看到 Fib[2] 被計算過兩次，透過動態規劃演算法將第一次 Fib[2] 的計算結果儲存於陣列，第二次要計算時就可直接從陣列取出結果，不用再計算一次。上述明顯地得知，將每次的計算結果先儲存，供後續使用，以減少效能開銷是其演算法之精神。\n改良先前的費伯那序列代碼\n// 計算結果暫存區 static int[] output = new int[100]; static int Fibonacci(int n) { int result; result = output[n]; if (result == 0) { if (n == 0) result = 0; else if (n == 1) result = 1; else result = (Fibonacci(n - 1) + Fibonacci(n - 2)); } // 將計算結果儲存到暫存區  output[n] = result; return result; } 枚舉演算法（Exhaustive Searching） 又稱窮舉法，一種常見的數學基礎方法，高頻率的在日常生活中使用到，主要核心概念為依據問題需求，逐一枚舉出所有解答，達到解決問題的目的，缺點為速度太慢。\n舉例：當 1000 依次減去 1,2,3\u0026hellip;直到結果為負數，代碼如下\nint num = 1000; int count = 0; while (num \u0026gt;= 0) { count++; num -= count; } Console.WriteLine(count); 上述範例中可看到，每執行一次相減就檢查結果是否為負數，在不遺漏的情況下，一一枚舉出所有項目，在從枚舉的項目中找到自己所需的項目。\n再舉個例：從 1-500 之間列舉出所有 3 的倍數的整數\nfor (int num = 0; num \u0026lt;= 500; num++) { if (num % 3 == 0) Console.WriteLine(num); } 枚舉演算法還有一個經典題型，如何得知某數是否為質數，在此推薦使用 Eratosthenes 方法，將某數逐一除以 2 至某數減一之間的所有數字，若有其中一個可以整除，就能斷定某數是否為質數。\nstatic bool IsPrime(int n) { int i = 2; while (i \u0026lt; n) { // 如果整除, i 為 n 的因數  if (n % i == 0) return false; i++; } return true; } 貪心演算法（Greedy Algorithm） 貪心演算法又稱貪婪演算法，主要核心概念如同名稱一樣，在每個解決問題的步驟遵循貪心原則，採取最有利或最優化的選項，意即只求局部解決辦法，而不考慮大局影響，不斷改進解答。\n雖然貪心演算法都是選擇當前最有利，但不能保證最終結果也是最佳的，因為貪心法在原理上容易過早做決定，此演算法很適合用來尋找最短路徑或是機器學習等方面。\n回溯演算法（Backtracking Algorithm） 最後一個回溯演算法也是枚舉法的一種，顧名思義為步驟可回溯的概念，當枚舉出不正確答案時，可以透過回溯來回到上一層，接著找尋出尚未執行過的路徑，再遞迴至下一層。\n老鼠走迷宮就是經典例子，利用二維陣列模擬出一個迷宮，而老鼠行進時遵循以下三個原則\n 一次只能走一格 遇到牆壁無法前行時，則退回到上一步尋找其他可走路徑 走過的路不再走第二遍  二維陣列的迷宮規則為\nMaze[i][j] = 1 --表示該位置為牆壁，無法通行 Maze[i][j] = 0 --表示該位置為不為牆壁，可前行 Maze[1][1] --該處為入口 Maze[m][n] --該處為出口 虛擬碼解析迷宮搜尋概念\nif (上一格可走) { 加入方格編號到堆疊; 往上走; 判斷是否為出口; } else if (下一格可走) { 加入方格編號到堆疊; 往下走; 判斷是否為出口; } else if (左一格可走) { 加入方格編號到堆疊; 往左走; 判斷是否為出口; } else if (右一格可走) { 加入方格編號到堆疊; 往右走; 判斷是否為出口; } else { 從堆疊中刪除一個方格編號; 從堆疊中取出一個方格編號; 往回走; } 實際代碼\n建立座標類別\n/// \u0026lt;summary\u0026gt; /// 座標 /// \u0026lt;/summary\u0026gt; public class Node { public int X { get; set; } public int Y { get; set; } public Node(int x, int y) { this.X = x; this.Y = y; } } 建立記錄路經追蹤的類別\n/// \u0026lt;summary\u0026gt; /// 紀錄追蹤路徑類別 /// \u0026lt;/summary\u0026gt; public class TraceRecord { public Node[] nodes = new Node[120]; public Node Pre; public int num = 1; public bool IsEmpty() { return nodes[0] == null; } // 新增路徑到堆疊  public void Insert(int x, int y) { Node newNode = new Node(x, y); if (this.IsEmpty()) // 剛從入口出發  { nodes[0] = newNode; } else { num = num + 1; nodes[num] = newNode; } } // 刪除堆疊中的路徑  public void Delete() { if (this.IsEmpty()) { Console.WriteLine(\u0026#34;佇列已經空了\u0026#34;); return; } nodes[num] = null; num = num - 1; Pre = nodes[num]; } } 建立檢查出口的方法\npublic static bool ChkExit(int x, int y, int ex, int ey) { if (x == ex \u0026amp;\u0026amp; y == ey) return true; return false; } 開始前的預定義\n// 定義出口 X 座標 public static int ExitX = 8; // 定義出口 Y 座標 public static int ExitY = 10; // 定義二維陣列迷宮 public static int[,] Maze = { { 1,1,1,1,1,1,1,1,1,1,1,1 }, { 1,0,0,0,1,1,1,1,1,1,1,1 }, { 1,1,1,0,1,1,0,0,0,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,0,0,0,0,1,1,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,1,1,1,0,1,1,0,1,1 }, { 1,1,0,0,0,0,0,0,1,0,0,1 }, { 1,1,1,1,1,1,1,1,1,1,1,1 } }; Main 方法\nstatic void Main(string[] args) { int i, j; int x = 1; int y = 1; TraceRecord path = new TraceRecord(); Console.WriteLine(\u0026#34;迷宮路徑\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 12; j++) { Console.Write(Maze[i, j]); } Console.WriteLine(); } Thread.Sleep(1000); Console.WriteLine(\u0026#34;\\n老鼠開始走迷宮...\\n\u0026#34;); while (x \u0026lt;= ExitX \u0026amp;\u0026amp; y \u0026lt;= ExitY) { // 將當前路徑設置成已經走過  Maze[x, y] = 2; if (Maze[x - 1, y] == 0) // 左邊  { x -= 1; path.Insert(x, y); } else if (Maze[x + 1, y] == 0) // 右邊  { x += 1; path.Insert(x, y); } else if (Maze[x, y - 1] == 0) // 下方  { y -= 1; path.Insert(x, y); } else if (Maze[x, y + 1] == 0) // 上方  { y += 1; path.Insert(x, y + 1); } else if (ChkExit(x, y, ExitX, ExitY)) // 判斷是否為出口  { break; } else // 遇到死路  { path.Delete(); x = path.Pre.X; y = path.Pre.Y; } } Thread.Sleep(1000); Console.WriteLine(\u0026#34;老鼠走過的路徑(以2表示)\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 12; j++) { Console.Write(Maze[i, j]); } Console.WriteLine(); } Console.ReadKey(); } 執行結果\n迷宮路徑 111111111111 100011111111 111011000011 111011011011 111000011011 111011011011 111011011011 111111011011 110000001001 111111111111 老鼠開始走迷宮... 老鼠走過的路徑(以2表示) 111111111111 122211111111 111211222211 111211211211 111222211211 111211011211 111211011211 111111011211 110000001221 111111111111 Note 這次趁著假日時間，回憶一下經典演算法，閱讀過程中，意外發現此書作者有些筆誤的地方，文字的部分到還好，沒特別注意還是能順暢的讀過（中文字就算兩個字顛倒也能辨識，神奇～），倒是老鼠走迷宮代碼的部分，讓筆者疑惑很久，最後依照筆者自己的想法做了些改良，一樣是使用堆疊概念來實作，其實還可進階地使用遞迴，有興趣的人可以試試看。\n收工！\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/","summary":"【3/28 閱讀紀錄】\n此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。\nStart 演算法種類很多，經典的演算法有以下幾種\n 分治演算法（Divide and conquer） 疊代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Exhaustive Searching） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。\n像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。\n然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。\n所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。\n疊代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為疊代演算法，像是透過迴圈去循環重複的程式碼來得到答案。\n舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果\n// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { sum = sum * j; } Console.","title":"【Algorithm】經典演算法"},{"content":"Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？\nSolution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。\n如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！\n視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔\n 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側\n 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。\n視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置\n 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。\n","permalink":"https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/","summary":"Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？\nSolution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。\n如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！\n視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔\n 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側\n 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。\n視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置\n 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。","title":"【Windows】如何分割視窗/畫面"},{"content":"紀錄一下每次使用命令提示字元想從 C:\\ 切換到 D:\\ 時，都會喪失記憶，一直使用 CD D:\\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。\n其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。\n","permalink":"https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/","summary":"紀錄一下每次使用命令提示字元想從 C:\\ 切換到 D:\\ 時，都會喪失記憶，一直使用 CD D:\\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。\n其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。","title":"【Windows】使用 DOS 指令切換當前硬碟"},{"content":"Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。\n查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）\n何謂全表掃描（Full Table Scan）？\n簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。\n以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。\n  避免使用 NULL\nSELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 \u0026lt;\u0026gt; 和 !=，使用 \u0026gt;= 或 \u0026lt;= 來取代\n  避免使用 or 來連接條件\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 UNION ALL SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 5   避免使用 IN 或 NOT IN\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID IN (3,4,5) -- 若是連續數值，能用 BETWEEN 就不要用 IN SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID BETWEEN 3 AND 5   使用 EXISTS 來代替 IN\nSELECT ID FROM A WHERE ID IN (SELECT ID FROM B) -- 將 IN 替換成 EXISTS 語句 SELECT ID FROM A WHERE ID EXISTS (SELECT 1 FROM B WHERE NUM = A.NUM)   避免使用 Like\n  避免使用 %\n  避免在子句對欄位進行運算\nSELECT ID FROM A WHERE NUM/2 = 100 -- 應更改為 SELECT ID FROM A WHERE NUM = 100*2   避免在子句對欄位進行函數操作\nSELECT ID FROM A WHERE SUBSTRING(ProductName, 1, 3)=\u0026#39;abc\u0026#39; SELECT ID FROM A WHERE DATEDIFF(DAY, CreateDate, \u0026#39;2021-03-26\u0026#39;) = 0 -- 應更改為 SELECT ID FROM A WHERE ProductName Like \u0026#39;abc\u0026#39; SELECT ID FROM A WHERE CreateDate \u0026gt;= \u0026#39;2021-03-26\u0026#39; AND CreateDate \u0026lt; \u0026#39;2021-03-27\u0026#39;   避免再子句中的 = 左邊進行函數、算術運算或其他運算式，因系統可能無法正確的使用索引\n  索引優化 欲對查詢進行優化，首先應考慮在 WHERE 和 ORDER BY 涉及的欄位建立索引。\n但也不是所有索引對查詢都有效，當索引列有大量資料重複時，SQL Agent 也會放棄使用索引改為使用 Full Table scan。如對某欄位建立索引，而該欄位只有 true \u0026amp; false，資料量分別為各半，那該索引在查詢時無法有作用，SQL Agent 最終會走 Full Table scan。\n在使用索引欄位為條件時，如果索引為複合式索引，那麼在搜尋時的條件必須以複合式索引中的欄位順序來查詢，否則索引將不會被使用到。\n索引並非越多越好，索引固然能提高查詢效率，但同時也會降低 INSERT 和 UPDATE 的效率，因為這兩個動作有可能會重建索引。一般來說一個資料表的索引不超過六個，若太多則應考慮剔除一些非必要索引。\n其他優化   盡量不使用星號查詢 SELECT * FROM A，用具體的欄位來替代星號，只返回需要使用的欄位，減少返回用不到的資料\n  Table Name 給予 Alias Name，使用時連同別名一起給予，如 [AliasName].[ColumnName]\n  UNION ALL 效能會優於 UNION，因為不用排序\n  FROM 之後的資料表來源在 JOIN 時，由左到右依序 JOIN RECORD 由多到少的 TABLE\n  避免向 Client Side 返回大量數據\n  能用 DISTINCT 就不用 GROUP BY\nSELECT OrderID FROM Order WHERE UnitPrice \u0026gt; 10 GROUP BY OrderID -- 應改為 SELECT DISTINCT OrderID FROM Order WHERE UnitPrice \u0026gt; 10   用 EXISTS 替代 DISTINCT\n  避免使用 SELECT INTO 語句 因為 SELECT INTO 語句會造成資料表鎖定，其他使用者則無法訪問該資料表。\n  Note 前陣子在工作上遇到需要效能調教問題，在解決的過程中得知有些基礎的效能優化方法，就誕生了這篇文章，至於工作上遇到的問題，模擬情境需要點時間思考，之後有空會在記錄。\n","permalink":"https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/","summary":"Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。\n查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）\n何謂全表掃描（Full Table Scan）？\n簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。\n以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。\n  避免使用 NULL\nSELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 \u0026lt;\u0026gt; 和 !=，使用 \u0026gt;= 或 \u0026lt;= 來取代\n  避免使用 or 來連接條件\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].","title":"【MSSQL】如何改善 SQL 常見的效能問題"},{"content":"Prerequisites .NET 5.0 SDK 或之後的版本\nStart 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。\n建立新專案 選擇【Blazor 應用程式】專案\n選擇【Blazor Server 應用程式】樣板\n建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。\n建立 Razor 元件時要注意\n 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page \u0026quot;/todo\u0026quot;\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼\n\u0026lt;ul class=\u0026#34;nav flex-column\u0026#34;\u0026gt; ... \u0026lt;li class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Todo \u0026lt;/NavLink\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.cs 類別，以保存待辦清單集合\npublic class TodoItem { public string Title { get; set; } public bool IsDone { get; set; } } 在 UI 渲染清單 在 Pages/Todo.razor 變更下列代碼\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!--走訪 todo 集合，添加清單標記--\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt;@todo.Title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; @code { // 建立 todo 清單集合  private IList\u0026lt;TodoItem\u0026gt; todos = new List\u0026lt;TodoItem\u0026gt;(); } 此時還不會有任何清單呈現，因為在 todos 集合中尚未添加項目。\n添加新增功能 繼續在 Pages/Todo.razor 新增文字輸入框及按鈕\n\u0026lt;ul\u0026gt; ... \u0026lt;/ul\u0026gt; \u0026lt;!--bind:屬性繫結--\u0026gt; \u0026lt;input placeholder=\u0026#34;Something todo\u0026#34; @bind=\u0026#34;newTodo\u0026#34;/\u0026gt; \u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; 在 @code 區塊內加入一個與文字輸入框綁定的 string，以及按下 Add Todo 按鈕後呼叫的 AddTodo 方法\n@code { ... // 取得新的 todo 標題  private string newTodo; /// \u0026lt;summary\u0026gt;  /// 新增清單項目  /// \u0026lt;/summary\u0026gt;  private void AddTodo() { // Todo: Add the todo  // 將綁定的 newTodo 文字新增至 todos 集合中  if (!string.IsNullOrWhiteSpace(newTodo)) { todos.Add(new TodoItem { Title = newTodo }); newTodo = string.Empty; } } } 變更清單呈現方式  每個清單項目前添加核取方塊 checkbox ，供使用者紀錄已完成項目 每個清單項目的文字輸入框設定為可編輯  \u0026lt;!--走訪 todo 集合，添加清單標記--\u0026gt; @foreach(var todo in todos) { \u0026lt;li\u0026gt; \u0026lt;!--綁定 todo 屬性--\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; @bind=\u0026#34;todo.IsDone\u0026#34; /\u0026gt; \u0026lt;input @bind=\u0026#34;todo.Title\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; } 標題顯示未完成項目數量 更新 \u0026lt;h3\u0026gt; 標頭為可計算未完成項目的數量\n\u0026lt;h3\u0026gt;Todo (@todos.Count(todo =\u0026gt; !todo.IsDone))\u0026lt;/h3\u0026gt; Done 啟動本地瀏覽，享受成品！\n使用 command shell 建立專案 前面建立專案時是使用 IDE 介面，這裡補充一下如何使用指令來建立專案。\n建立 Blazor 專案 先 CD 到欲建立資料夾的目錄，使用下列指令來建立 Blazor 專案，執行完後會看到該目錄下已建立 TodoList 資料夾\n$ dotnet new blazorserver -o TodoList 將當前目錄更換到 TodoList 資料夾\n$ cd TodoList 新增 Razor Component -n 為建立元件的名稱， -o 為輸出的位置，下列該指令會在 Pages 資料夾下建立一個 Todo.razor 的元件\n$ dotnet new razorcomponent -n Todo -o Pages 到目前為止已經建立一個 Blazor 專案，並為專案內建立 Razor 元件，接下來的程式碼修改如同上述操作，這邊就不再重複介紹。\n完成後使用下列代碼來啟用本地伺服器瀏覽\n$ dotnet watch run Reference Build a Blazor todo list app\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/","summary":"Prerequisites .NET 5.0 SDK 或之後的版本\nStart 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。\n建立新專案 選擇【Blazor 應用程式】專案\n選擇【Blazor Server 應用程式】樣板\n建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。\n建立 Razor 元件時要注意\n 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page \u0026quot;/todo\u0026quot;\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼\n\u0026lt;ul class=\u0026#34;nav flex-column\u0026#34;\u0026gt; ... \u0026lt;li class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Todo \u0026lt;/NavLink\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.","title":"【.NET】打造 Blazor ToDoList"},{"content":"Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！\nSolution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】\nStep2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。\nNote 【OS】Win10\n","permalink":"https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/","summary":"Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！\nSolution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】\nStep2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。\nNote 【OS】Win10","title":"【Windows】如何改變命令提示字元(cmd)視窗預設大小"},{"content":"Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C \u0026amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。\nSolution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。\nStep1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】\nStep2 展開磁碟機選擇要與遠端分享的硬碟\nStep3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享\nNote OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。\n","permalink":"https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/","summary":"Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C \u0026amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。\nSolution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。\nStep1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】\nStep2 展開磁碟機選擇要與遠端分享的硬碟\nStep3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享\nNote OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。","title":"【Windows】分享本地硬碟供遠端使用"},{"content":"Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 \u0026amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。\nSolution Step1 檢查剪貼簿功能是否有開啟\n【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能\nStep2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。\nNote 那麼為何 File Copy 會當掉？\n有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。\n","permalink":"https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/","summary":"Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 \u0026amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。\nSolution Step1 檢查剪貼簿功能是否有開啟\n【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能\nStep2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。\nNote 那麼為何 File Copy 會當掉？\n有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。","title":"【Windows】遠端桌面連線無法複製貼上？"},{"content":"Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可\nNote 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？\n【傳送門】【Windows】遠端桌面連線無法複製貼上？\n","permalink":"https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/","summary":"Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可\nNote 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？\n【傳送門】【Windows】遠端桌面連線無法複製貼上？","title":"【Windows】開啟遠端桌面連線剪貼簿/印表機功能"},{"content":"GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。\n在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。\nCreate a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。\n首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。\n下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！\nGit client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git\n Terminal GitHub Desktop  使用 Terminal 要了解 git 操作指令，而 GitHub Desktop 對新手較為友善，提供 UI 介面來操作 git 指令。兩者相較下，前者需要了解的指令相對多，且對指令的熟悉度必須較高，才能適時的選出合適的指令進行操作。\n下列介紹終端機的使用方法，移動到專案要儲存的位置，將剛剛建立的倉儲 clone 到該路徑下，記得替換 username 為自己的 GitHub 帳戶。\n$ git clone https://github.com/username/username.github.io 此時該路徑會建立名為 username.github.io 的資料夾，進入到新建的目錄下，建立內容為 Hello world 的 index.html 作為首頁。\n$ cd username.github.io $ echo \u0026#34;Hello world\u0026#34; \u0026gt; index.html 使用 git 指令 add、commit、push 將專案推送到 GitHub repository.\n# 將全部檔案添加到欲提交的暫存區域 $ git add --all # 將暫存區域的檔案提交出去 $ git commit -m \u0026#34;Initial commit\u0026#34; # 將本地儲存庫推送到遠端儲存庫 $ git push -u origin main 開啟瀏覽器進入到 https://username.github.io 即可看到剛剛 Hello world 的畫面！\nChoose a theme 目前我們只新增一個 index.html 的頁面，還只是個簡陋的靜態網站，GitHub Pages 提供幾個佈景主題可供套用，進入 repository 的 Setting，往下拉會看到 GitHub Pages 的 panel，此 panel 為靜態網站提供一些設置，找到 Choose a theme 按鈕，從中挑選一個主題套用，套用後會看到主題的代碼已經存放在 repository 內，而不單單只有先前建立的 index.html，再次打開瀏覽器進入 https://username.github.io 就可看到剛剛套用的 theme。\n恭喜，完成了一個靜態網站！\nReference GitHub Pages\n","permalink":"https://fakestandard.github.io/post/github/github-1-githubpage/","summary":"GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。\n在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。\nCreate a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。\n首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。\n下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！\nGit client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git","title":"【GitHub】在 GitHub Pages 建立靜態網站"},{"content":"【紀錄 2021/3/20】\n美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。\n這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～\n想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～\n周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…\n本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～\n正門口\n建築物外觀\n湯屋內設施\n正門木頭椅\n整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。\n結論，下次想使用客房得提前先預訂。\nBTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！\n泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。\n取自網路的招牌\n美食享用\n兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。\n原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～\n到家時間 am 2:30\n","permalink":"https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/","summary":"【紀錄 2021/3/20】\n美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。\n這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～\n想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～\n周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…\n本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～\n正門口\n建築物外觀\n湯屋內設施\n正門木頭椅\n整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。\n結論，下次想使用客房得提前先預訂。\nBTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！\n泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。\n取自網路的招牌\n美食享用\n兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。\n原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～\n到家時間 am 2:30","title":"【Life Trip】北投享溫泉/石牌老牌肉丸"},{"content":"前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。\n應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。\n標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高\n# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。\n斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 \u0026lt;em\u0026gt; 標籤包圍\n*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 \u0026lt;strong\u0026gt;\n**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現\n***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 \u0026lt;p\u0026gt;。\nThis is the first paragraph. This is the second paragraph. 清單 分為無序清單及有序清單兩種，無序清單使用 * 、 + 或 - 作為清單標記，有序清單使用數字接著一個英文句點做為清單標記\n* Red * Green * Blue + Red + Green + Blue - Red - Green - Blue 1. Apple 2. Bird 3. Candy 上面無序清單和有序清單所產生的 HTML 標記分別為\n\u0026lt;!--無序清單--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Red\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Green\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Blue\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!--有序清單--\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Apple\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Bird\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Candy\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 若要使用多層級清單，可在下一層級使用一個縮排或是兩個半形空白\n- Red - Green - Blue - Sub red - Sub green - three CheckBox CheckBox 常用於待辦事項或確認項目，使用 -[] 符號放到項目開頭，中括號內有 x 代表被選取。\n- [x] This is a complete item - [ ] This is an incomplete item 分隔線 在一行內使用三個或以上的 *、-、_ 來建立分隔線，符號內不可有其他東西，但可以在符號內插入空白。\n*** --- ___ 效果 下列寫法都可建立分隔線\n******** * * * ---------- - - - 圖片 使用語法如下\n 一個驚嘆號 ! 開頭 一對中括號，放置圖片的替代文字 一對小括號，放置圖片的路徑或網址，另外還可選擇性的添加 prompt，當滑鼠停留在圖片上時，會自動顯示這段文字，並使用雙引號包住。  ![Text](/path/image.jpg) ![Text](/path/image.jpg \u0026#34;title\u0026#34;)  路徑可使用絕對路徑或相對路徑\n 連結 使用語法如下\n 一個中括號，放置連結文字 一個小括號，放置連結路徑或網址，一樣可使用雙引號來添加 prompt 文字  [Github](https://fakestandard.github.io \u0026#34;my github\u0026#34;) 效果 自動連結 Markdown 使用一組括號 \u0026lt; \u0026gt; 支援較簡易的連結，如網址或信箱。與連結不同之處就是自動連結不產出連結文字。\n\u0026lt;https://fakestandard.github.io\u0026gt; 效果 表格 Markdown 表格有點囉嗦，排版上也不是很美觀，若非必要盡量不做大張表格，實際運用時不太親民。\n 最外圍的豎線不一定需要。 靠左對齊的寫法是添加 : 在左側，如 :---，同理靠右對齊為在右側添加冒號 ---: 置中對齊呈現的方式為在兩側都添加冒號 :--:。  | Plugin | README | | ------ | ------ | | Dropbox | [plugins/dropbox/README.md][PlDb] | | GitHub | [plugins/github/README.md][PlGh] | | Google Drive | [plugins/googledrive/README.md][PlGd] | | OneDrive | [plugins/onedrive/README.md][PlOd] | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | 效果\n程式碼  要標記一小段程式碼，可以使用反引號 ` 包起來。 如果想在程式碼內插入反引號，可以使用兩個反引號來開啟和結束程式碼  Example\nUse the `print()` function ``There is a literal backtick (`) here.`` A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 效果\n程式碼區塊 要標記多行的程式碼，可簡單的使用 4 個空白或一個 tab 縮排即可\nHere is an example of AppleScript: tell application \u0026#34;Foo\u0026#34; beep end tell 效果\n也可連續使用三個反引號 ``` 把程式碼包起來，並在首行的三個反引號後面加上該段程式碼的語言，就可輸出 Highlight 效果，例如 ```html。\n\u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; \u0026amp;copy; 2004 Foo Corporation \u0026lt;/div\u0026gt; 區塊引言 Markdown 使用 email 形式的 blockquotes，在每行前面加上 \u0026gt;，區塊引言與清單一樣可以有階層，只要根據階層加上不同數量的 \u0026gt; 即可完成\n\u0026gt; This is the first quoting. \u0026gt; This is the second quoting. \u0026gt; This is the first level of quoting. \u0026gt;\u0026gt; This is the second level of quoting. \u0026gt;\u0026gt;\u0026gt; This is the third level of quoting. \u0026gt; Back to the first level. 效果\n列表縮進  黃鶴樓送孟浩然之廣陵 故人西辭黃鶴樓，煙花三月下揚州。 孤帆遠影碧山盡，唯見長江天際流。  黃鶴樓送孟浩然之廣陵 : 故人西辭黃鶴樓，煙花三月下揚州。 孤帆遠影碧山盡，唯見長江天際流。 跳脫字元 前面介紹那麼多格式所使用的符號，若要將這些符號呈現出來，而非作為有意義的符號使用，可使用反斜線 \\ 來插入普通的符號。\n\\\\ 反斜線 \\` 反引號 \\* 星號 \\_ 底線 \\{} 大括號 \\[] 方括號 \\() 括號 \\# 井字號 \\+ 加號 \\- 減號 \\. 英文句點 \\! 驚嘆號 效果\n結語 首發先來記錄 Markdown 語法，因 Hugo 寫作時也支援 Markdown，順手先記錄一篇常用到的，有空再寫一篇較進階的用法。下次見囉！\n題外話，部落格新開張那天，筆者裝了矯正牙套，那晚真是有苦說不出，有香雞排難下嚥，上排和下排牙齒能分多開就多開，要是碰再一起可得酸個三秒五秒。能咬的東西越來越少，太硬的咬不動，而菜梗也成為較硬的食物，我還天真地以為可以吃它（泣）…\nReference Markdown\nMastering Markdown\n","permalink":"https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/","summary":"前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。\n應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。\n標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高\n# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。\n斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 \u0026lt;em\u0026gt; 標籤包圍\n*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 \u0026lt;strong\u0026gt;\n**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現\n***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 \u0026lt;p\u0026gt;。","title":"【Markdown】筆記神器"},{"content":"前言 恭賀本人的部落格又開張了！\n歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…\nOK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…\n正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。\n某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…\n接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…\n過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…\n說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…\n前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo \u0026amp; pick theme，終於大功造成！\n結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。\n隨著年紀增長，大腦效能逐漸降低，也該是時候有個小角落來記錄技術疑難雜症，以及生活點滴，再加上筆者未點到寫作技能，現在點不知來不來得及（笑）\n期許，2022 年這部落格還能存活著\nReference Hugo offcial website\n","permalink":"https://fakestandard.github.io/post/other/other-1-newblog/","summary":"前言 恭賀本人的部落格又開張了！\n歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…\nOK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…\n正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。\n某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…\n接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…\n過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…\n說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…\n前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo \u0026amp; pick theme，終於大功造成！\n結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。","title":"【賀】新開張！"},{"content":"","permalink":"https://fakestandard.github.io/zone/example/","summary":"","title":"Example"}]