[{"content":"【5/26 閱讀紀錄】\n根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 從數學角度來說，矩陣 m*n 的形式在電腦中可以利用二維陣列表示，而矩陣的相關運算與應用，也都是以陣列結構來解決。矩陣可應用於 3D 圖學中，用來表示模型資料的投影、擴大、縮小、平移、偏斜或旋轉等運算，在深度學習中也常遇到大量使用矩陣運算來提高效率。\n接下來會透過陣列結構來演示以下兩種演算法\n 矩陣相加 矩陣相乘  矩陣相加 矩陣相加與相減的前提是兩矩陣的陣列數與行數必須相同，相加或相減後的陣列數與行數也必須相等，所以矩陣相加與相減的特性相同。\n實際演練下列兩矩陣 A.B 相加之後得到 C 矩陣\n建立靜態變數與輸出矩陣方法\nstatic int ROWS = 3; static int COLS = 3; /// \u0026lt;summary\u0026gt; /// 輸出矩陣 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;matrix\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt; COLS; j++) Write(matrix[i, j] + \u0026#34;\\t\u0026#34;); WriteLine(); } } 建立矩陣相加方法\n/// \u0026lt;summary\u0026gt; /// 矩陣相加方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;A\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;B\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;C\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Matrix_Add(ref int[,] A, ref int[,] B, ref int[,] C) { int i; int j; for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt; COLS; j++) C[i, j] = A[i, j] + B[i, j]; } } 在 Main 方法中執行\nstatic void Main(string[] args) { // 宣告並建立 A.B 兩矩陣  int[,] A = { { 2, 4, 6 }, { 8, 10, 12 }, { 14, 16, 18 }}; int[,] B = { { 9, 8, 7 }, { 6, 5, 4 }, { 3, 2, 1 }}; // 宣告並建立 C 矩陣  int[,] C = new int[ROWS, COLS]; // 輸出 A.B 矩陣  WriteLine(\u0026#34;\\n=======矩陣 A 元素=======\\n\u0026#34;); Print(ref A); WriteLine(\u0026#34;\\n=======矩陣 B 元素=======\\n\u0026#34;); Print(ref B); // 進行矩陣相加  Matrix_Add(ref A, ref B, ref C); // 輸出 C 矩陣結果  WriteLine(\u0026#34;\\n=======矩陣 C 元素=======\\n\u0026#34;); Print(ref C); ReadLine(); } 輸出結果\n矩陣相乘 矩陣相乘就沒有相加來的簡單，而相乘的矩陣也必須符合：A 是 m*n 的矩陣、B 是 n*p 的矩陣、乘積後的矩陣 C 是 m*p 的矩陣。\nC 矩陣的計算方法為\n實際演練下列兩矩陣 A.B 相乘之後得到 C 矩陣\n轉換成向量內積來看\n套數字計算\n得到結果（數字開太大QQ）\n利用程式碼實作矩陣相乘，一樣先建立靜態變數與輸出矩陣方法\nstatic int ROWS = 3; static int COLS = 3; /// \u0026lt;summary\u0026gt; /// 輸出矩陣 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;matrix\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt; COLS; j++) Write(matrix[i, j] + \u0026#34;\\t\u0026#34;); WriteLine(); } } 建立矩陣相乘方法\n/// \u0026lt;summary\u0026gt; /// 矩陣相乘方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;A\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;B\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;C\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Matrix_Multiply(ref int[,] A, ref int[,] B, ref int[,] C) { int i, j, k, tmp; int m = 3; int n = 3; int p = 3; for (i = 0; i \u0026lt; m; i++) { for (j = 0; j \u0026lt; p; j++) { tmp = 0; for (k = 0; k \u0026lt; n; k++) tmp += A[i, k] * B[k, j]; C[i, j] = tmp; } } } 在 Main 方法執行\nstatic void Main(string[] args) { // 宣告並建立 A.B 兩矩陣  int[,] A = { { 2, 4, 6 }, { 8, 10, 12 }, { 14, 16, 18 }}; int[,] B = { { 9, 8, 7 }, { 6, 5, 4 }, { 3, 2, 1 }}; // 宣告並建立 C 矩陣  int[,] C = new int[ROWS, COLS]; // 輸出 A.B 矩陣  WriteLine(\u0026#34;\\n=======矩陣 A 元素=======\\n\u0026#34;); Print(ref A); WriteLine(\u0026#34;\\n=======矩陣 B 元素=======\\n\u0026#34;); Print(ref B); // 進行矩陣相乘  Matrix_Multiply(ref A, ref B, ref C); // 輸出 C 矩陣結果  WriteLine(\u0026#34;\\n=======矩陣 C 元素=======\\n\u0026#34;); Print(ref C); ReadLine(); } 輸出結果 Note 離開學校後就沒有再碰過矩陣，現在重拾矩陣基礎概念，在利用程式計算矩陣相關題型，別有一番樂趣。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-29-matrixaddadnmultiply/","summary":"【5/26 閱讀紀錄】\n根據先前文章介紹的陣列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 從數學角度來說，矩陣 m*n 的形式在電腦中可以利用二維陣列表示，而矩陣的相關運算與應用，也都是以陣列結構來解決。矩陣可應用於 3D 圖學中，用來表示模型資料的投影、擴大、縮小、平移、偏斜或旋轉等運算，在深度學習中也常遇到大量使用矩陣運算來提高效率。\n接下來會透過陣列結構來演示以下兩種演算法\n 矩陣相加 矩陣相乘  矩陣相加 矩陣相加與相減的前提是兩矩陣的陣列數與行數必須相同，相加或相減後的陣列數與行數也必須相等，所以矩陣相加與相減的特性相同。\n實際演練下列兩矩陣 A.B 相加之後得到 C 矩陣\n建立靜態變數與輸出矩陣方法\nstatic int ROWS = 3; static int COLS = 3; /// \u0026lt;summary\u0026gt; /// 輸出矩陣 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;matrix\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Print(ref int[,] matrix) { int i; int j; for (i = 0; i \u0026lt; ROWS; i++) { for (j = 0; j \u0026lt; COLS; j++) Write(matrix[i, j] + \u0026#34;\\t\u0026#34;); WriteLine(); } } 建立矩陣相加方法","title":"【Algorithm】陣列應用—矩陣相加與相乘演算法"},{"content":"【5/30 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 雙向佇列的全名是 Double-ends Queues，縮寫為 Deques。雙向佇列與一般說的佇列不太相同，不過也很容易理解，它是一種前後兩端都可以輸入或輸出資料的有序串列。\n雙向佇列至少有以下工作行為\n   Method Description     IsEmpty 檢查雙向佇列是否為空   PushFront 將資料從頂端推入，其大小加一   PushRear 將資料從末端推入，其大小加一   PopFront 將資料從頂端推出，其大小減一   PopRear 將資料從末端推出，其大小減一   PeekFront 存取頂端的資料，不改變其大小   PeekRear 存取末端的資料，不改變其大小    而雙向佇列依其應用還可分為多種存取模式，較常見的雙向佇列有\n 輸入限制性雙佇列（Input Restricted Deque） - 限制存入資料只能在其中一端進行，取出資料則可在兩端執行 輸出限制性雙佇列（Output Restricted Deque） - 限制取出資料只能在其中一端進行，輸入資料則可在兩端執行  以串列結構實作雙向佇列程式碼，建立節點類別、雙向佇列串列結構類別，以及佇列相關方法（推入推出方法在下一步實作）\n/// \u0026lt;summary\u0026gt; /// 節點類別 /// \u0026lt;/summary\u0026gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } /// \u0026lt;summary\u0026gt; /// 串列結構的雙向佇列 /// \u0026lt;/summary\u0026gt; class LinkedListDeques { // 佇列頂端指標  public Node front; // 佇列末端指標  public Node rear; // 建構函式  public LinkedListDeques() { this.front = null; this.rear = null; } /// \u0026lt;summary\u0026gt;  /// 判斷佇列是否為空  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return front == null; } /// \u0026lt;summary\u0026gt;  /// 由頂端開始輸出雙向佇列  /// \u0026lt;/summary\u0026gt;  public void Print() { if (!IsEmpty()) { Node current = front; while (current != null) { Write($\u0026#34;[{current.data}] \u0026#34;); current = current.next; } WriteLine(); } } /// \u0026lt;summary\u0026gt;  /// 從頂端推入資料  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void PushFront(int data) { // do something...  } /// \u0026lt;summary\u0026gt;  /// 從末端推入資料  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void PushRear(int data) { // do something...  } /// \u0026lt;summary\u0026gt;  /// 從頂端取出資料  /// \u0026lt;/summary\u0026gt;  public void PopFront() { // do something...  } /// \u0026lt;summary\u0026gt;  /// 從末端取出資料  /// \u0026lt;/summary\u0026gt;  public void PopRear() { // do something...  } } 實作從頂端推入資料 /// \u0026lt;summary\u0026gt; /// 從頂端推入資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void PushFront(int data) { Node newNode = new Node(data); if (IsEmpty()) { rear = newNode; front = newNode; } else { Node current = front; newNode.next = current; front = newNode; } } 實作從末端推入資料 /// \u0026lt;summary\u0026gt; /// 從末端推入資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void PushRear(int data) { Node newNode = new Node(data); if (IsEmpty()) { front = newNode; rear = newNode; } else { Node current = front; while (current.next != null) current = current.next; current.next = newNode; rear = newNode; } } 實作從頂端取出資料 /// \u0026lt;summary\u0026gt; /// 從頂端取出資料 /// \u0026lt;/summary\u0026gt; public void PopFront() { WriteLine($\u0026#34;從頂端取出資料: {front.data}\u0026#34;); front = front.next; } 實作從末端取出資料 /// \u0026lt;summary\u0026gt; /// 從末端取出資料 /// \u0026lt;/summary\u0026gt; public void PopRear() { Node current = front; while (current.next != rear) current = current.next; WriteLine($\u0026#34;從末端取出資料: {rear.data}\u0026#34;); current.next = null; rear = current; } 在 Main 方法實際調用方法\nstatic void Main(string[] args) { LinkedListDeques deques = new LinkedListDeques(); // 從末端插入資料  deques.PushRear(1); deques.PushRear(2); deques.PushRear(3); deques.PushRear(4); deques.PushRear(5); deques.Print(); // 從頂端插入資料  deques.PushFront(6); deques.PushFront(7); deques.PushFront(8); deques.PushFront(9); deques.PushFront(10); deques.Print(); deques.PopRear(); deques.Print(); deques.PopRear(); deques.Print(); deques.PopFront(); deques.Print(); deques.PopFront(); deques.Print(); ReadLine(); } Note 對於限制性雙佇列而言，只要針對限制的特性不實作方法即可達到目的。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-28-deques/","summary":"【5/30 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 雙向佇列的全名是 Double-ends Queues，縮寫為 Deques。雙向佇列與一般說的佇列不太相同，不過也很容易理解，它是一種前後兩端都可以輸入或輸出資料的有序串列。\n雙向佇列至少有以下工作行為\n   Method Description     IsEmpty 檢查雙向佇列是否為空   PushFront 將資料從頂端推入，其大小加一   PushRear 將資料從末端推入，其大小加一   PopFront 將資料從頂端推出，其大小減一   PopRear 將資料從末端推出，其大小減一   PeekFront 存取頂端的資料，不改變其大小   PeekRear 存取末端的資料，不改變其大小    而雙向佇列依其應用還可分為多種存取模式，較常見的雙向佇列有\n 輸入限制性雙佇列（Input Restricted Deque） - 限制存入資料只能在其中一端進行，取出資料則可在兩端執行 輸出限制性雙佇列（Output Restricted Deque） - 限制取出資料只能在其中一端進行，輸入資料則可在兩端執行  以串列結構實作雙向佇列程式碼，建立節點類別、雙向佇列串列結構類別，以及佇列相關方法（推入推出方法在下一步實作）\n/// \u0026lt;summary\u0026gt; /// 節點類別 /// \u0026lt;/summary\u0026gt; class Node { public int data; public Node next; public Node(int data) { this.","title":"【Algorithm】佇列應用—雙向佇列（Deques）"},{"content":"【5/20 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用串列結構模擬佇列工作，使用指標及相關方法實作佇列。\n建立鏈結串列的節點類別\n/// \u0026lt;summary\u0026gt; /// 鏈結串列節點類別 /// \u0026lt;/summary\u0026gt; class QueueNode { public int data; public QueueNode next; public QueueNode(int data) { this.data = data; next = null; } } 建立使用串列節點模擬佇列的類別，其中包含 Enqueue 和 Dequeue 方法。\n/// \u0026lt;summary\u0026gt; /// 串列模擬佇列類別 /// \u0026lt;/summary\u0026gt; class QueueByLink { // 前端指標  public QueueNode front; // 末端指標  public QueueNode rear; public QueueByLink() { front = null; rear = null; } /// \u0026lt;summary\u0026gt;  /// 加入資料到佇列  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Enqueue(int value) { // 建立新節點  QueueNode node = new QueueNode(value); // 檢查是否為空佇列  if (rear == null) front = node; else rear.next = node; rear = node; return true; } /// \u0026lt;summary\u0026gt;  /// 從佇列中取出資料  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public int Dequeue() { int value; // 檢查是否為空佇列  if (front != null) { if (front == rear) rear = null; // 取出資料  value = front.data; // 將指標指向下一個  front = front.next; return value; } else return -1; } } 撰寫 Main 方法\nstatic void Main(string[] args) { // 建立佇列物件  QueueByLink queue = new QueueByLink(); int tmp; WriteLine(\u0026#34;以鏈結串列實作佇列\u0026#34;); WriteLine(\u0026#34;=============================\u0026#34;); WriteLine(\u0026#34;在佇列中加入資料 2\u0026#34;); queue.Enqueue(2); WriteLine(\u0026#34;在佇列中加入資料 4\u0026#34;); queue.Enqueue(4); WriteLine(\u0026#34;在佇列中加入資料 6\u0026#34;); queue.Enqueue(6); WriteLine(\u0026#34;在佇列中加入資料 8\u0026#34;); queue.Enqueue(8); WriteLine(\u0026#34;在佇列中加入資料 10\u0026#34;); queue.Enqueue(10); WriteLine(\u0026#34;=============================\u0026#34;); while (true) { if (!(queue.front == null)) { tmp = queue.Dequeue(); WriteLine($\u0026#34;從佇列中取出資料 {tmp}\u0026#34;); } else break; } Console.ReadLine(); } Note 實作的過程中，發現一問題，在加入資料方法中，其中檢查是否為空陣列判斷的 else 區塊，在 rear.next = node 執行完後，front.next 也添加了新的節點，真是匪夷所思，先記錄起來。\n/// \u0026lt;summary\u0026gt; /// 加入資料到佇列 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool Enqueue(int value) { ... // 檢查是否為空佇列  if (rear == null) front = node; else rear.next = node; ...  【7/12 問題排解】\n一開始檢查rear是否為空佇列，如果為空則front = node，接著rear = node，此時front與rear都同時指向node，故兩者配置的記憶體位置是相同的，下次新增資料時，else區塊的rear.next = node，也等同於將front.next指向node\n /// \u0026lt;summary\u0026gt; /// 加入資料到佇列 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public bool Enqueue(int value) { // 建立新節點  QueueNode node = new QueueNode(value); // 檢查是否為空佇列  if (rear == null) front = node; else rear.next = node; rear = node; return true; } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-27-queuelist/","summary":"【5/20 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用串列結構模擬佇列工作，使用指標及相關方法實作佇列。\n建立鏈結串列的節點類別\n/// \u0026lt;summary\u0026gt; /// 鏈結串列節點類別 /// \u0026lt;/summary\u0026gt; class QueueNode { public int data; public QueueNode next; public QueueNode(int data) { this.data = data; next = null; } } 建立使用串列節點模擬佇列的類別，其中包含 Enqueue 和 Dequeue 方法。\n/// \u0026lt;summary\u0026gt; /// 串列模擬佇列類別 /// \u0026lt;/summary\u0026gt; class QueueByLink { // 前端指標  public QueueNode front; // 末端指標  public QueueNode rear; public QueueByLink() { front = null; rear = null; } /// \u0026lt;summary\u0026gt;  /// 加入資料到佇列  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Enqueue(int value) { // 建立新節點  QueueNode node = new QueueNode(value); // 檢查是否為空佇列  if (rear == null) front = node; else rear.","title":"【Algorithm】佇列應用—串列實作佇列"},{"content":"【5/20 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用陣列簡單地時做佇列應用，宣告一個大小為 10 的佇列 queue[10]，設置 front 和 rear 作為頭尾的指標且預設為 -1。\nstatic int front = -1; static int rear = -1; static int max = 10; static int val; static int[] queue = new int[max]; static void Main(string[] args) { int choice = 0; while (rear \u0026lt; max - 1 \u0026amp;\u0026amp; choice != 3) { Write(\u0026#34;請輸入 \\n[1] 新增一個資料 \\n[2] 取出資料 \\n[3] 結束 :\u0026#34;); choice = int.Parse(Console.ReadLine()); switch (choice) { case 1: Write(\u0026#34;請輸入要新增的數值:\u0026#34;); val = int.Parse(Console.ReadLine()); rear++; queue[rear] = val; WriteLine(); break; case 2: if (rear \u0026gt; front) { front++; WriteLine($\u0026#34;取出的樹值為 {queue[front]}\u0026#34;); queue[front] = 0; } else { WriteLine(\u0026#34;佇列已空\u0026#34;); } break; default: WriteLine(); break; } } if (rear == max - 1) WriteLine(\u0026#34;佇列已滿\u0026#34;); Write(\u0026#34;目前佇列的資料:\u0026#34;); if (front \u0026gt;= rear) { Write(\u0026#34;沒有資料，空佇列\u0026#34;); } else { while (rear \u0026gt; front) { front++; Write($\u0026#34;[{queue[front]}] \u0026#34;); } } Console.ReadLine(); } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-26-queuearray/","summary":"【5/20 閱讀紀錄】\n根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用陣列簡單地時做佇列應用，宣告一個大小為 10 的佇列 queue[10]，設置 front 和 rear 作為頭尾的指標且預設為 -1。\nstatic int front = -1; static int rear = -1; static int max = 10; static int val; static int[] queue = new int[max]; static void Main(string[] args) { int choice = 0; while (rear \u0026lt; max - 1 \u0026amp;\u0026amp; choice != 3) { Write(\u0026#34;請輸入 \\n[1] 新增一個資料 \\n[2] 取出資料 \\n[3] 結束 :\u0026#34;); choice = int.Parse(Console.ReadLine()); switch (choice) { case 1: Write(\u0026#34;請輸入要新增的數值:\u0026#34;); val = int.","title":"【Algorithm】佇列應用—陣列實作佇列"},{"content":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 八皇后謎題也是經典中的經典，該問題以西洋棋作為背景，如何在 8x8 的棋盤上擺放八個皇后，使任一皇后都無法吃掉其他皇后，屬於堆疊常見的應用實例。\n西洋棋皇后擺放的規則為：因皇后可在一步內，不限格數的直行、橫行或斜線前行，若同一條線上同時有兩個皇后，則舊皇后可吃掉新來皇后，所以，皇后間不可處於同一個縱向、橫向或斜線（跟數獨的概念相似）\n首先會先放置一個皇后，接著依據第一個皇后的位置，在不被吃掉的情況下，繼續放置第二個皇后、第三個皇后…直到放置某個新皇后時，都會被先前的皇后吃掉，此時，就必須變更前一個皇后放置的位置，在不被先前的皇后吃掉之情形下，找到第二個可以放置的位置，在繼續擺放新皇后；若在前一個擺放的皇后，也沒有新的位置可以擺放（都會被吃掉的情況），就在將前前皇后拿起，尋找新的可以擺放的位置，以此類推。\n由上述可知，在放置新皇后或是拿起舊皇后的動作，是以堆疊的概念進行，而當新皇后無法擺放時，將舊皇后拿起尋找新的位置，是以回溯的概念進行。\n本書程式碼範例\nclass Program { static void Main(string[] args) { number = 0; DecidePosition(0); ReadKey(); Console.ReadLine(); } static int TRUE = 1, FALSE = 0, EIGHT = 8; // 存放八個皇后的列位置  static int[] queen = new int[EIGHT]; // 計算共有幾組解答  static int number = 0; /// \u0026lt;summary\u0026gt;  /// 按下 Enter 鍵要執行方法  /// \u0026lt;/summary\u0026gt;  public static void PressEnter() { char ch; Write(\u0026#34;\\n\\n\u0026#34;); Write(\u0026#34;按下 Enter 鍵繼續...\u0026#34;); ch = (char)Read(); } /// \u0026lt;summary\u0026gt;  /// 決定皇后存放的位置  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public static void DecidePosition(int value) { int i = 0; while (i \u0026lt; EIGHT) { // 判斷是否遭受攻擊  if (Attack(i, value) != 1) { queen[value] = i; if (value == 7) PrintChessBoard(); else DecidePosition(value + 1); } i++; } } /// \u0026lt;summary\u0026gt;  /// 攻擊測試，若皇后遭受攻擊則返回值為 1，反之  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;row\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static int Attack(int row, int col) { int i = 0, atk = FALSE; int offsetRow = 0, offsetCol = 0; while ((atk != 1) \u0026amp;\u0026amp; i \u0026lt; col) { offsetCol = Math.Abs(i - col); offsetRow = Math.Abs(queen[i] - row); // 判斷兩皇后是否在同一列或同一對角線  if ((queen[i] == row) || (offsetRow == offsetCol)) atk = TRUE; i++; } return atk; } /// \u0026lt;summary\u0026gt;  /// 輸出棋盤結果  /// \u0026lt;/summary\u0026gt;  public static void PrintChessBoard() { number += 1; WriteLine(); Write($\u0026#34;八皇后問題之第 {number} 組解\\n\\t\u0026#34;); for (int i = 0; i \u0026lt; EIGHT; i++) { for (int j = 0; j \u0026lt; EIGHT; j++) if (i == queen[j]) Write(\u0026#34;[*]\u0026#34;); else Write(\u0026#34;[ ]\u0026#34;); Write(\u0026#34;\\n\\t\u0026#34;); } PressEnter(); } } Note 之後會在參考有關八皇后的其他程式碼寫法，本書範例理解到一半就斷了思緒，筆者感到挫折…\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-25-eightqueens/","summary":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 八皇后謎題也是經典中的經典，該問題以西洋棋作為背景，如何在 8x8 的棋盤上擺放八個皇后，使任一皇后都無法吃掉其他皇后，屬於堆疊常見的應用實例。\n西洋棋皇后擺放的規則為：因皇后可在一步內，不限格數的直行、橫行或斜線前行，若同一條線上同時有兩個皇后，則舊皇后可吃掉新來皇后，所以，皇后間不可處於同一個縱向、橫向或斜線（跟數獨的概念相似）\n首先會先放置一個皇后，接著依據第一個皇后的位置，在不被吃掉的情況下，繼續放置第二個皇后、第三個皇后…直到放置某個新皇后時，都會被先前的皇后吃掉，此時，就必須變更前一個皇后放置的位置，在不被先前的皇后吃掉之情形下，找到第二個可以放置的位置，在繼續擺放新皇后；若在前一個擺放的皇后，也沒有新的位置可以擺放（都會被吃掉的情況），就在將前前皇后拿起，尋找新的可以擺放的位置，以此類推。\n由上述可知，在放置新皇后或是拿起舊皇后的動作，是以堆疊的概念進行，而當新皇后無法擺放時，將舊皇后拿起尋找新的位置，是以回溯的概念進行。\n本書程式碼範例\nclass Program { static void Main(string[] args) { number = 0; DecidePosition(0); ReadKey(); Console.ReadLine(); } static int TRUE = 1, FALSE = 0, EIGHT = 8; // 存放八個皇后的列位置  static int[] queen = new int[EIGHT]; // 計算共有幾組解答  static int number = 0; /// \u0026lt;summary\u0026gt;  /// 按下 Enter 鍵要執行方法  /// \u0026lt;/summary\u0026gt;  public static void PressEnter() { char ch; Write(\u0026#34;\\n\\n\u0026#34;); Write(\u0026#34;按下 Enter 鍵繼續.","title":"【Algorithm】堆疊應用—八皇后經典謎題"},{"content":"Start 接續先前物件導向的紀錄，此篇會著重於下列三部份\n 重構（Refactoring） 抽象（Abstract） 介面（Interface）  重構（Refactoring） 重構的概念是將原本重複的地方改寫，使程式碼更精簡且更好維護。\n接續前篇的範例，定義一個父類別 CareerBasic，該父類別內有一個虛擬方法可以讓子類別複寫。\n/// \u0026lt;summary\u0026gt; /// 職業基礎類別 /// \u0026lt;/summary\u0026gt; class CareerBasic { // something...  /// \u0026lt;summary\u0026gt;  /// 父類別虛擬方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public virtual string PassiveSkill() { return \u0026#34; 使出被動技能： \u0026#34;; } } 定義兩個子類別分別為 Swordman 和 Thief，並繼承 CareerBasic 類別，使其成為父類別。在子類別裡，分別複寫父類別方法 PassiveSkill()\n/// \u0026lt;summary\u0026gt; /// 盜賊類別 /// \u0026lt;/summary\u0026gt; class Thief : CareerBasic { // ...  // Thief 複寫 父類別方法  public override string PassiveSkill() { return name + base.PassiveSkill() + \u0026#34;二刀連擊\u0026#34;; } } /// \u0026lt;summary\u0026gt; /// 劍士類別 /// \u0026lt;/summary\u0026gt; class Swordman : CareerBasic { // ...  // Swordman 複寫 父類別方法  public override string PassiveSkill() { return name + base.PassiveSkill() + \u0026#34;攻擊弱點\u0026#34;; } } 從子類別中可以發現 PassiveSkill() 該方法除了技能名稱不一樣之外，其它都一樣。接著我們欲透過重構的概念—將其它一樣的地方抽取出來放到父類別下，讓子類別只在乎自己的技能名稱，對子類別內的 PassiveSkill() 方法進行重構。\n首先，在父類別中添加一個取得技能名稱的方法 GetSkillName()，且提供子類別進行複寫，接著將父類別 PassiveSkill() 改為普通公共方法，該方法內調用 GetSkillName() 方法以獲取技能名稱。\n/// \u0026lt;summary\u0026gt; /// 職業基礎類別 /// \u0026lt;/summary\u0026gt; class CareerBasic { // something...  /// \u0026lt;summary\u0026gt;  /// 公共方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string PassiveSkill() { return name + \u0026#34; 使出被動技能：\u0026#34; + GetSkillName(); } /// \u0026lt;summary\u0026gt;  /// 取得技能名稱方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  protected virtual string GetSkillName() { return \u0026#34;\u0026#34;; } } 最後，分別讓子類別複寫父類別的GetSkillName()虛擬方法，並提供自己的技能名稱。\n/// \u0026lt;summary\u0026gt; /// 盜賊類別 /// \u0026lt;/summary\u0026gt; class Thief : CareerBasic { // ...  // Thief 複寫 父類別方法  protected override string GetSkillName() { return \u0026#34;二刀連擊\u0026#34;; } } /// \u0026lt;summary\u0026gt; /// 劍士類別 /// \u0026lt;/summary\u0026gt; class Swordman : CareerBasic { // ...  // Swordman 複寫 父類別方法  protected override string GetSkillName() { return \u0026#34;攻擊弱點\u0026#34;; } } 抽象（Abstract） 抽象類別應擁有共同程式碼，而盡可能地擁有較少的資料。對於抽象而言須注意的幾點：\n 抽象類別不能被實體化 抽象方法必須被子類別重寫 如果類別中包含抽象方法，那類別就必須定義為抽象類別，不論是否包含其他的一般方法。  所以抽象類別通常代表一個抽象方法，它提供一個繼承的出發點；在以繼承關係形成的等級結構裡，樹葉節點應是具體類別，樹枝節點應是抽象類別。在 C# 中欲將類別或方法宣告為抽象時，需使用 abstract 關鍵字。\n假想CareerBasic不能為具體類別，它其實是抽象類別，而盜賊才足夠讓職業類別實體。\n// 加上 abstract 為抽象類別 abstract class CareerBasic { ... // 去掉 virtual 加上 abstract 成為抽象方法，而抽象方法沒有方法體  protected abstract string GetSkillName(); } 介面（Interface） 把隱式公共方法和屬性組合起來，封裝特定功能的集合稱為介面。介面可以支援多個類別，一個類別也可支援多個介面，類別一旦實現介面，則類別就可支援介面內所有屬性和成員，且類別也必須實現介面中所有方法和屬性。宣告時需注意不允許提供介面中任何成員的執行方法。\n介面宣告的關鍵字為 interface，宣告的命名規範必須在第一個字母加上大寫I，介面中的方法或屬性前面不能有修飾子或方法沒有方法體。\n建立一個服事類別Acolyte，需繼承 CareerBasic 父類別。\n/// \u0026lt;summary\u0026gt; /// 服事類別 /// \u0026lt;/summary\u0026gt; class Acolyte : CareerBasic { public Acolyte(string name) : base(name) { } public Acolyte() : base() { } protected override string GetSkillName() { return \u0026#34;天使之擊\u0026#34;; } } 因 Acolyte 的職業性質具有自動回血技能，而 Swordman 和 Thief 沒有該技能也不能擁有該技能，故得建立一個IPoint介面，讓擁有該技能的職業來實現介面類別。\n// 建立 IPoint 介面 interface IPoint { // 建立 Recovery 方法，傳入數值參數，回傳字串  string Recovery(int num); } 讓 Acolyte 擁有該介面的方法，讓類別實現介面來支援該介面成員。\n// 實現 IPonit 介面（使用逗號） class Acolyte : CareerBasic, IPoint { ... // 實現介面  public string Recovery(int num) { return name + \u0026#34;回復血量\u0026#34; + num + \u0026#34;點\u0026#34;; } } 若還是不太了解介面的讀者，可以想像目前有一個鳥類的父類別，接著建立一些子類別並繼承鳥類的父類別：候鳥、燕子、八哥、喜鵲；這四個子類別的鳥類都是會飛的，故牠們都應該要有一個fly()的方法，所以我們在父類別鳥類添加fly()的方法，這樣大家都可以飛了。\nOK！現在我們在定義一個鳥類的子類別—企鵝！\n 謎之音—\n「欸！糟糕…這樣不行啦！企鵝不會飛，不能繼承父類別鳥類啦！這樣牠會有fly()方法，很怪欸！」\n 那該怎麼辦？\n此時我們就可以使用介面，讓會飛的鳥類來實現介面類別；定義一個IFly()介面，讓會飛的鳥類類別來實現IFly()介面，這樣就不用擔心企鵝會飛起來的怪異現象囉！\nNote 抽象與介面一時半會兒不是很能釐清，兩者容易模糊，必須透過不斷的思考劃清兩者的區別。本書作者提供三點幫助區分抽象類別和介面：\n 類別是對物件的抽象；抽象類別是對類別的抽象；介面是對行為的抽象 如果行為跨越不同類別的物件，可使用介面；對於一些相似的類別物件，用繼承抽象類別 從設計角度來說，抽象類別是從子類別中發現了公共的東西，泛化出父類別，然後子類別繼承父類別，而介面是根本不知道子類別的存在，方法如何實現還不確認，只是預先定義介面  Reference 【大話設計模式】\n","permalink":"https://fakestandard.github.io/post/oop/oop-4-refactoring-abstract-interface/","summary":"Start 接續先前物件導向的紀錄，此篇會著重於下列三部份\n 重構（Refactoring） 抽象（Abstract） 介面（Interface）  重構（Refactoring） 重構的概念是將原本重複的地方改寫，使程式碼更精簡且更好維護。\n接續前篇的範例，定義一個父類別 CareerBasic，該父類別內有一個虛擬方法可以讓子類別複寫。\n/// \u0026lt;summary\u0026gt; /// 職業基礎類別 /// \u0026lt;/summary\u0026gt; class CareerBasic { // something...  /// \u0026lt;summary\u0026gt;  /// 父類別虛擬方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public virtual string PassiveSkill() { return \u0026#34; 使出被動技能： \u0026#34;; } } 定義兩個子類別分別為 Swordman 和 Thief，並繼承 CareerBasic 類別，使其成為父類別。在子類別裡，分別複寫父類別方法 PassiveSkill()\n/// \u0026lt;summary\u0026gt; /// 盜賊類別 /// \u0026lt;/summary\u0026gt; class Thief : CareerBasic { // ...  // Thief 複寫 父類別方法  public override string PassiveSkill() { return name + base.","title":"【OOP】重構、抽象和介面（Refactoring、Abstract and Interface）"},{"content":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 這篇紀錄經典的智力遊戲—河內塔，使用遞迴式和堆疊概念來解決問題的經典範例。\n河內塔的問題描述如下：在古老的印度神廟中，有三個木樁，在第一個木樁上，有數量和大小不同的圓盤，由大到小堆疊，最大的圓盤放在最下面，最小的圓盤在最上面，天神希望將第一個木樁的圓盤，全部移動到第三個木樁。\n搬動時必須要遵守規則下列規則\n 直徑較小的圓盤只能置於直徑大的圓盤上，比如直徑三的圓盤可以放置在直徑四或直徑五的上方 圓盤可以任意由一個木樁移動到其他木樁上，共有三個木樁可使用 每次只能移動一個圓盤，只能從最上方的圓盤開始移動（與堆疊相同）  【解析】\n假設 n 為圓盤數量，逐步解析情境\n  n = 1\n當圓盤只有一個時，直接從第一個木樁移動到地三個木樁，完成天神願望。\n  n = 2\n當圓盤為兩個時，由上往下數，將第一個圓盤移動到第二個木樁，接著將第二個圓盤移動到第三個木樁，第一個圓盤從第二個木樁移動到第三個木樁，完成天神願望。\n在這裡可以得到一個小結論\n 圓盤移動的次數為 (2^2)-1 = 3 次，即 2 的平方-1 次 圓盤移動的次序為 1→2→1 木樁移動的次序為 1→2、1→3、2→3    n = 3\n當圓盤為三個時，由上往下數\n 第一個圓盤移動到第三個木樁 第二個圓盤移動到第二個木樁 第一個圓盤從第三個木樁移至第二個木樁，此時第二個木樁有兩個圓盤 第三個圓盤移動到第三個木樁 第一個圓盤從第二個木樁移動到第一個木樁 第二個圓盤從第二個木樁移動到第三個木樁 最後，將第一個圓盤從第一個木樁移動到第三個木樁  完成天神願望（懶得畫圖，請讀者發揮想像力…）\n此情境得出以下結論\n 圓盤移動的次數為 2^3-1 = 7 次，即 2 的次方-1 次 圓盤移動的次序為 1→2→1→3→1→2→1 木樁移動的次序為 1→3、1→2、3→2、1→3、2→1、2→3、1→3    【結論】\n從上述觀察到，河內塔的問題可歸納成三步驟\n 將 n-1 個圓盤，從木樁１移動到木樁２ 將第 n 個最大的圓盤，從木樁１移動到木樁２ 將 n-1 個圓盤，從木樁２移動到木樁３  當 n 很大時，就無法逐步解決，下列利用遞迴與堆疊概念來撰寫程式碼\n/// \u0026lt;summary\u0026gt; /// 河內塔遞迴方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;n\u0026#34;\u0026gt;圓盤數量\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p1\u0026#34;\u0026gt;木樁 1\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p2\u0026#34;\u0026gt;木樁 2\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;p3\u0026#34;\u0026gt;木樁 3\u0026lt;/param\u0026gt; public static void Hanoi(int n, int p1, int p2, int p3) { if (n == 1) Console.WriteLine($\u0026#34;圓盤 {n} 從木樁 {p1} 移動到木樁 {p3}\u0026#34;); else { Hanoi(n - 1, p1, p3, p2); Console.WriteLine($\u0026#34;圓盤 {n} 從木樁 {p1} 移動到木樁 {p3}\u0026#34;); Hanoi(n - 1, p2, p1, p3); } } Main 方法\nstatic void Main(string[] args) { while (true) { Console.WriteLine(\u0026#34;請輸入要搬移的圓盤數量\u0026#34;); int num = int.Parse(Console.ReadLine()); Hanoi(num, 1, 2, 3); Console.WriteLine(); Console.WriteLine(\u0026#34;按下Enter鍵繼續或是Esc鍵退出\u0026#34;); if (Console.ReadKey().Key == ConsoleKey.Escape) return; Console.WriteLine(); } } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-24-towerofhanoi/","summary":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 這篇紀錄經典的智力遊戲—河內塔，使用遞迴式和堆疊概念來解決問題的經典範例。\n河內塔的問題描述如下：在古老的印度神廟中，有三個木樁，在第一個木樁上，有數量和大小不同的圓盤，由大到小堆疊，最大的圓盤放在最下面，最小的圓盤在最上面，天神希望將第一個木樁的圓盤，全部移動到第三個木樁。\n搬動時必須要遵守規則下列規則\n 直徑較小的圓盤只能置於直徑大的圓盤上，比如直徑三的圓盤可以放置在直徑四或直徑五的上方 圓盤可以任意由一個木樁移動到其他木樁上，共有三個木樁可使用 每次只能移動一個圓盤，只能從最上方的圓盤開始移動（與堆疊相同）  【解析】\n假設 n 為圓盤數量，逐步解析情境\n  n = 1\n當圓盤只有一個時，直接從第一個木樁移動到地三個木樁，完成天神願望。\n  n = 2\n當圓盤為兩個時，由上往下數，將第一個圓盤移動到第二個木樁，接著將第二個圓盤移動到第三個木樁，第一個圓盤從第二個木樁移動到第三個木樁，完成天神願望。\n在這裡可以得到一個小結論\n 圓盤移動的次數為 (2^2)-1 = 3 次，即 2 的平方-1 次 圓盤移動的次序為 1→2→1 木樁移動的次序為 1→2、1→3、2→3    n = 3\n當圓盤為三個時，由上往下數\n 第一個圓盤移動到第三個木樁 第二個圓盤移動到第二個木樁 第一個圓盤從第三個木樁移至第二個木樁，此時第二個木樁有兩個圓盤 第三個圓盤移動到第三個木樁 第一個圓盤從第二個木樁移動到第一個木樁 第二個圓盤從第二個木樁移動到第三個木樁 最後，將第一個圓盤從第一個木樁移動到第三個木樁  完成天神願望（懶得畫圖，請讀者發揮想像力…）\n此情境得出以下結論\n 圓盤移動的次數為 2^3-1 = 7 次，即 2 的次方-1 次 圓盤移動的次序為 1→2→1→3→1→2→1 木樁移動的次序為 1→3、1→2、3→2、1→3、2→1、2→3、1→3    【結論】","title":"【Algorithm】堆疊應用—經典河內塔"},{"content":"【5/17 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 使用串列製作堆疊的好處是可以隨時動態改變串列長度，缺點則是設計較為複雜。相較於使用陣列製作堆疊設計上較為簡易，缺點則是陣列大小需事先宣告，無法動態改變。\n利用串列結構模擬堆疊工作運算，使用迴圈控制推入或取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。\n宣告一個鏈結串列節點的類別\n/// \u0026lt;summary\u0026gt; /// 鏈結串列節點的類別 /// \u0026lt;/summary\u0026gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } 宣告串列模擬堆疊的類別，其中包含推入和取出的方法\n/// \u0026lt;summary\u0026gt; /// 以串列模擬的堆疊 /// \u0026lt;/summary\u0026gt; class StackByLink { /// \u0026lt;summary\u0026gt;  /// 指向堆疊頂端的指標  /// \u0026lt;/summary\u0026gt;  public Node front; /// \u0026lt;summary\u0026gt;  /// 指向堆疊末端的指標  /// \u0026lt;/summary\u0026gt;  public Node rear; /// \u0026lt;summary\u0026gt;  /// 判斷堆別是否為空的方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return front == null; } /// \u0026lt;summary\u0026gt;  /// 輸出堆疊內容  /// \u0026lt;/summary\u0026gt;  public void Display() { Node current = front; while (current != null) { Write($\u0026#34;[{current.data}]\u0026#34;); current = current.next; } WriteLine(); } /// \u0026lt;summary\u0026gt;  /// 從堆疊頂端加入資料  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public void Insert(int data) { Node newNode = new Node(data); if (this.IsEmpty()) { front = newNode; rear = newNode; } else { rear.next = newNode; rear = newNode; } } /// \u0026lt;summary\u0026gt;  /// 從堆疊頂端刪除資料  /// \u0026lt;/summary\u0026gt;  public void Pop() { Node newNode; if (this.IsEmpty()) { Write(\u0026#34;=====目前堆疊為空=====\\n\u0026#34;); return; } newNode = front; if (newNode == rear) { front = null; rear = null; Write(\u0026#34;=====目前堆疊為空=====\\n\u0026#34;); } else { while (newNode.next != rear) newNode = newNode.next; newNode.next = rear.next; rear = newNode; } } } Main 方法代碼\nstatic void Main(string[] args) { StackByLink stack = new StackByLink(); int choice = 0; while (true) { Write(\u0026#34;請輸入 [0:結束]、[1:在堆疊加入資料]、[2:取出堆疊資料]：\u0026#34;); choice = int.Parse(Console.ReadLine()); if (choice == 0) break; else if (choice == 1) { Write(\u0026#34;請輸入要加入堆疊的資料內容:\u0026#34;); choice = int.Parse(Console.ReadLine()); WriteLine(\u0026#34;頂端新增資料後的堆疊內容\u0026#34;); stack.Insert(choice); stack.Display(); } else if (choice == 2) { WriteLine(\u0026#34;刪除頂端資料後的堆疊內容\u0026#34;); stack.Pop(); stack.Display(); } else WriteLine(\u0026#34;輸入錯誤！\u0026#34;); WriteLine(); } ReadKey(); Console.ReadLine(); } Note 在加入資料的 Insert 方法中，else 的部分有點疑惑，實際走到 rear.next = newNode 後，front 最後的節點也添加了新的節點，筆者以為會是 front.next = newNode 去更新 front 串列，結果卻不是，這裡值得在思考，先記錄一下問題。\n/// \u0026lt;summary\u0026gt; /// 從堆疊頂端加入資料 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public void Insert(int data) { //...  rear.next = newNode; rear = newNode; } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-23-stacklist/","summary":"【5/17 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 使用串列製作堆疊的好處是可以隨時動態改變串列長度，缺點則是設計較為複雜。相較於使用陣列製作堆疊設計上較為簡易，缺點則是陣列大小需事先宣告，無法動態改變。\n利用串列結構模擬堆疊工作運算，使用迴圈控制推入或取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。\n宣告一個鏈結串列節點的類別\n/// \u0026lt;summary\u0026gt; /// 鏈結串列節點的類別 /// \u0026lt;/summary\u0026gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } 宣告串列模擬堆疊的類別，其中包含推入和取出的方法\n/// \u0026lt;summary\u0026gt; /// 以串列模擬的堆疊 /// \u0026lt;/summary\u0026gt; class StackByLink { /// \u0026lt;summary\u0026gt;  /// 指向堆疊頂端的指標  /// \u0026lt;/summary\u0026gt;  public Node front; /// \u0026lt;summary\u0026gt;  /// 指向堆疊末端的指標  /// \u0026lt;/summary\u0026gt;  public Node rear; /// \u0026lt;summary\u0026gt;  /// 判斷堆別是否為空的方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool IsEmpty() { return front == null; } /// \u0026lt;summary\u0026gt;  /// 輸出堆疊內容  /// \u0026lt;/summary\u0026gt;  public void Display() { Node current = front; while (current !","title":"【Algorithm】堆疊應用—串列實作堆疊"},{"content":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用陣列結構模擬堆疊工作運算，且使用迴圈控制推入與取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。\n建立堆疊類別\n/// \u0026lt;summary\u0026gt; /// 以陣列模擬堆疊的類別 /// \u0026lt;/summary\u0026gt; class StackArray { // 宣告陣列  private int[] stack; // 指向堆疊頂端的索引  private int top; /// \u0026lt;summary\u0026gt;  /// 建構子  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;stack_size\u0026#34;\u0026gt;堆疊大小\u0026lt;/param\u0026gt;  public StackArray(int size) { // 建立陣列  stack = new int[size]; top = -1; } /// \u0026lt;summary\u0026gt;  /// 判斷堆疊是否為空  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Empty() { if (top == -1) return true; else return false; } /// \u0026lt;summary\u0026gt;  /// 推入資料到頂端的方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Push(int data) { // 判斷堆疊頂端的索引是否大於陣列大小  if (top \u0026gt;= stack.Length) { Console.WriteLine(\u0026#34;堆疊已滿，無法再加入\u0026#34;); return false; } else { // 先將堆疊指標往上移，再將資料放入堆疊  stack[++top] = data; return true; } } public int Pop() { if (Empty()) return -1; else return stack[top--]; // 先將資料取出，再將堆疊指標往下移  } } Main 方法\nstatic void Main(string[] args) { int value; StackArray stack = new StackArray(10); Console.WriteLine(\u0026#34;請依序輸入 10 筆資料\u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { value = int.Parse(Console.ReadLine()); stack.Push(value); } Console.WriteLine(\u0026#34;===========================\u0026#34;); // 將堆疊內的資料陸續從頂端取出  while (!stack.Empty()) { Console.WriteLine($\u0026#34;堆疊資料: {stack.Pop()}\u0026#34;); } Console.ReadLine(); } 撲克牌發牌應用 接著嘗試實務應用，模擬撲克牌發牌以及洗牌過程，先以亂數取得撲克牌，再放入堆疊中，放滿 52 張牌後，使用堆疊來發牌給四個人。\n小小改良本書的程式碼範例，將堆疊應用封裝成類別\n/// \u0026lt;summary\u0026gt; /// 宣告陣列實作堆疊類別 /// \u0026lt;/summary\u0026gt; class StackArray { int[] stack; public int top = -1; public StackArray(int size) { stack = new int[size]; } public void Push(int val) { if (top \u0026gt;= stack.Length) Console.WriteLine(\u0026#34;堆疊已滿\u0026#34;); else stack[++top] = val; } public int Pop() { if (top \u0026lt; 0) Console.WriteLine(\u0026#34;堆疊已空\u0026#34;); else top--; return top == -1 ? -1 : stack[top]; } } Main 方法模擬洗牌與發牌\nstatic void Main(string[] args) { // 建立撲克牌陣列  int[] card = new int[52]; for (int i = 0; i \u0026lt; 52; i++) { card[i] = i; } Console.WriteLine(\u0026#34;洗牌中, 請稍後...\u0026#34;); Thread.Sleep(2000); // 隨機洗牌 30 次  int k = 0; int tmp = 0; Random r = new Random(); while (k \u0026lt; 30) { for (int i = 0; i \u0026lt; 51; i++) { for (int j = i + 1; j \u0026lt; 52; j++) { if ((r.Next(10000) % 52) == 2) { tmp = card[i]; card[i] = card[j]; card[j] = tmp; } } } k++; } // 建立堆疊類別實例  StackArray stack = new StackArray(52); // 將撲克牌的值推入堆疊中  k = 0; while (k != 52) { stack.Push(card[k]); k++; } Console.WriteLine(\u0026#34;逆時針發牌...\u0026#34;); Thread.Sleep(500); Console.WriteLine(); Console.WriteLine(\u0026#34;顯示各家的牌\u0026#34;); Thread.Sleep(500); Console.WriteLine(\u0026#34;===============================================\u0026#34;); Thread.Sleep(500); Console.WriteLine(\u0026#34;東家 \\t 北家 \\t 西家 \\t 南家\u0026#34;); Thread.Sleep(500); Console.WriteLine(\u0026#34;===============================================\u0026#34;); Thread.Sleep(500); // 紀錄撲克牌花色變數  tmp = 0; string fourSuits = \u0026#34;\u0026#34;; // 發牌  while (stack.top \u0026gt;= 0) { tmp = card[stack.top] / 13; switch (tmp) { case 0: fourSuits = \u0026#34;梅花\u0026#34;; break; case 1: fourSuits = \u0026#34;方塊\u0026#34;; break; case 2: fourSuits = \u0026#34;紅心\u0026#34;; break; case 3: fourSuits = \u0026#34;黑桃\u0026#34;; break; } Console.Write($\u0026#34;[{fourSuits}{(stack.Pop()) % 13 + 1}] \u0026#34;); if ((stack.top + 1) % 4 == 0) Console.WriteLine(); Thread.Sleep(200); } Console.WriteLine(\u0026#34;===============================================\u0026#34;); Console.WriteLine(); Console.WriteLine(\u0026#34;發完了\u0026#34;); Console.ReadLine(); } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-22-stackarray/","summary":"【5/16 閱讀紀錄】\n根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。\n程式碼已放上 GitHub\nStart 利用陣列結構模擬堆疊工作運算，且使用迴圈控制推入與取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。\n建立堆疊類別\n/// \u0026lt;summary\u0026gt; /// 以陣列模擬堆疊的類別 /// \u0026lt;/summary\u0026gt; class StackArray { // 宣告陣列  private int[] stack; // 指向堆疊頂端的索引  private int top; /// \u0026lt;summary\u0026gt;  /// 建構子  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;stack_size\u0026#34;\u0026gt;堆疊大小\u0026lt;/param\u0026gt;  public StackArray(int size) { // 建立陣列  stack = new int[size]; top = -1; } /// \u0026lt;summary\u0026gt;  /// 判斷堆疊是否為空  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Empty() { if (top == -1) return true; else return false; } /// \u0026lt;summary\u0026gt;  /// 推入資料到頂端的方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public bool Push(int data) { // 判斷堆疊頂端的索引是否大於陣列大小  if (top \u0026gt;= stack.","title":"【Algorithm】堆疊應用—陣列實作堆疊"},{"content":"【5/31 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  費氏搜尋演算法（Fibonacci Search） 費氏搜尋演算法又稱費伯納搜尋法，Fibonacci 還有其他譯名如斐波那契數列、費氏數列等等，該數列非常特別，對於大自然而言，整個自然界都存在這個的定律，它是一個神奇的黃金比例；對於數學而言，只不過是個公式—每個值是前兩項的總和，但是，每個值除以前一項的商數，都近似於 1.618…\nOK. 我們也不能偏離主題太遠，不過 1.618 這個數字會存放於筆者內心的深處，近期受疫情的肆虐，筆者拾起達文西密碼，拜本書之賜，重新認識斐波那契數列這個「上帝之數」。\n費氏級數如同先前所說，每個值都是前兩項的加總，故其公式為\n雖然每個值都是前兩項的加總，其中並不包含第零個元素和第一個元素，第零個元素定義為 0，第一個元素定義為 1，從這兩個元素開始，每個值才是前兩項的總和，故該數列會是 0,1,1,2,3,5,8,13,21,34,55,89,144...\n費氏樹列以遞迴程式碼表現方式為\nstatic int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 了解費氏級數後，就來認識費氏搜尋數，所謂費氏搜尋數就是以費氏數列的特性，所建立的二元數，其建立原則如下\n 費氏樹的左右子樹皆為費氏樹 當資料個數為 n，若想決定費氏樹的階層 k 值，必須找到最小的 k 值，使得費氏級數 F(k+1)\u0026gt;=(n+1) 費氏樹的樹根定為一費氏樹，子節點與父節點的差值絕對是費氏數 當 k\u0026gt;=2 時，費氏樹的樹根為 Fib(k)，左子樹為 (k-1) 階的費氏樹，其樹根為 Fib(k-1)；右子樹則為 (k-2) 階的費氏樹，其樹根為 Fib(k)+Fib(k-2) 若 n+1 值不為費氏樹的值, 則可以找出一個 m 使用 Fib(k+1) - m = n+1, m = Fib(k+1)-(n+1), 再依費氏樹的建立原則完成費氏樹的建立, 最後費氏樹的各節點再減去差值 m 即可, 並把小於 1 的節點去掉即可  費氏數列\n二元樹（去掉小於 1 的節點）\n將二元樹轉換成費氏樹（去掉小於 1 的節點）\n將資料存放於費氏樹中，不過資料的放置順序應該怎麼放？我們使用中序走訪來訪問費氏樹，而訪問的順序就會相對地變成資料存放的位置，如下（圖中節點內的數字為中序走訪節點的順序）\n另外由上圖還可觀察到父節點與左右子節點之間，都會有固定的差值，左子樹的差值為減項，右子樹是加項，如下\n使用一個實際案例套用這些原則，假設有一數列由大到小排序為 2, 5, 17, 26, 38, 42, 59, 60, 65 ,72 ,87, 93，共 12 筆資料，從第二項原則「當資料個數為 n，若想決定費氏樹的階層 k 值，必須找到最小的 k 值，使得費氏級數 F(k+1)\u0026gt;=(n+1)」開始著手。首先已知資料個數 n = 12，接著滿足運算式 F(k+1)\u0026gt;=(n+1) 找到費氏樹階層 k，將 n 帶入運算式得到 F(k+1)\u0026gt;=13，透過查表找到 F(7)\u0026gt;=13，故 F(k+1)=F(6+1)，得到 k=6，樹根位置則為 F(6)=8。\n筆者認為第二點的原則必須找到最小的 k 值，更明確的意思應是找到最小費氏樹 F(k+1)，然後使得 F(k+1)\u0026gt;=(n+1)，接著得到樹根 F(k)\n已知樹根位置為索引 8 的位置，將數列拿出來看（索引 0 不放資料），找出索引 8 是哪個資料，使其成為樹根\n找到索引 8 的值是 60，將 60 作為樹根，將搜尋資料依照中序走訪的順序放置於費氏樹中（參考先前中序走訪樹圖），如下\n最後搜尋資料，將資料與樹根比較，比樹根大的往右子樹找，比樹根小的往左子樹找。\n 將費氏樹填入相對應的節點值，供範例查找使用  假設欲找尋數列中的 59\n 將 59 與索引 8 的樹根值 60 進行比較，比樹根小，往左子樹找 左子樹等於索引 8 減去差值 3 等於 5，故找出索引 5 的值為 38，將資料 59 與 38 進行比較，59 大於 38，故往右子樹找 索引 5 加上差值 2 等於 7，故找出索引 7 的值為 59，即完成搜尋。  演算法分析  費氏搜尋較為複雜，需額外產生費氏樹 在最壞的情況下，比二元搜尋法來得慢 在平均情況下，比較次數會少於二元搜尋法，會比二元搜尋法還快  實際撰寫程式碼 實作費氏搜尋法過程與步驟程式碼\n建立費氏數列遞迴方法\n/// \u0026lt;summary\u0026gt; /// 費氏數列遞迴方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 建立費氏搜尋法\n/// \u0026lt;summary\u0026gt; /// 費氏搜尋法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;SearchKey\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int Fibonacci_Search(int[] data, int SearchKey) { int index = 2; while (Fibonacci(index) \u0026lt;= data.Length) index++; index--; // 樹根  int rootNode = Fibonacci(index); int diff1 = Fibonacci(index - 1); //int diff2 = Fibonacci(index - 2);  int diff2 = rootNode - diff1; // 配合陣列從 0 開始儲存資料  rootNode--; while (true) { if (SearchKey == data[rootNode]) return rootNode; else { if (index == 2) return data.Length; if (SearchKey \u0026lt; data[rootNode]) // 往左子樹  { rootNode -= diff2; int tmp = diff1; diff1 = diff2; diff2 = tmp - diff2; index--; } else // 往右子數  { if (index == 3) return data.Length; rootNode += diff2; diff1 -= diff2; diff2 -= diff1; index -= 2; } } } } 在 Main 方法中調用方法進行搜尋\nstatic void Main(string[] args) { // 原始資料  int[] data = { 2, 5, 17, 26, 38, 42, 59, 60, 65, 72, 87, 93 }; int val; int i, j; WriteLine(\u0026#34;資料內容\u0026#34;); for (i = 0; i \u0026lt; data.Length; i++) Write($\u0026#34;{i + 1}-{data[i]} \u0026#34;); WriteLine(); while (true) { Write(\u0026#34;輸入欲搜尋的資料:\u0026#34;); val = int.Parse(ReadLine()); if (val == -1) break; int node = Fibonacci_Search(data, val); if (node == data.Length) WriteLine($\u0026#34;沒有找到 [{val}] \u0026#34;); else WriteLine($\u0026#34;在第 {node + 1} 個位置找到 [{data[node]}]\u0026#34;); } ReadLine(); } 輸出結果\nNote 費氏搜尋法頗麻煩，整個原理非常地繞，筆者透過多方參考，才得以了解其原理，若不能馬上了解原理，可以反覆的帶入案例，一步步地熟練查找步驟，方能融會貫通。\nReference 【圖說演算法 C#】\n擁抱「資料結構」的「演算法」(27) - 費式搜尋法\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/","summary":"【5/31 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  費氏搜尋演算法（Fibonacci Search） 費氏搜尋演算法又稱費伯納搜尋法，Fibonacci 還有其他譯名如斐波那契數列、費氏數列等等，該數列非常特別，對於大自然而言，整個自然界都存在這個的定律，它是一個神奇的黃金比例；對於數學而言，只不過是個公式—每個值是前兩項的總和，但是，每個值除以前一項的商數，都近似於 1.618…\nOK. 我們也不能偏離主題太遠，不過 1.618 這個數字會存放於筆者內心的深處，近期受疫情的肆虐，筆者拾起達文西密碼，拜本書之賜，重新認識斐波那契數列這個「上帝之數」。\n費氏級數如同先前所說，每個值都是前兩項的加總，故其公式為\n雖然每個值都是前兩項的加總，其中並不包含第零個元素和第一個元素，第零個元素定義為 0，第一個元素定義為 1，從這兩個元素開始，每個值才是前兩項的總和，故該數列會是 0,1,1,2,3,5,8,13,21,34,55,89,144...\n費氏樹列以遞迴程式碼表現方式為\nstatic int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 了解費氏級數後，就來認識費氏搜尋數，所謂費氏搜尋數就是以費氏數列的特性，所建立的二元數，其建立原則如下","title":"【Algorithm】搜尋演算法—費氏搜尋法（Fibonacci Search）"},{"content":"Start 前篇講解 OOP 的特性卻還沒介紹基本原則，馬上來惡補一下內功心法。\n物件導向設計五大原則「SOLID」由羅伯特·C·馬丁在21世紀早期提出，SOLID分別為單一功能原則、開閉原則、里氏替換原則、介面隔離原則、依賴反轉原則。\n了解物件導向基本原則及特性，透過不斷練習和思考就可寫出閱讀性、維護性、擴充性高的程式碼，然而開發易維護與擴展的系統也變得不難。\n單一職責（Single Responsibility Principle） 對一個類別來說，應該只有一個引起他變化的理由，意為一個類別應只專注做一件事，當類別需要做兩件以上的工作時，就承擔了過多的職責，一旦需變更代碼，耦合度會比一件工作還要高，而當發生錯誤時很難快速定位錯誤原因，間接導致程式碼可閱讀性降低。\n開放封閉（Open-Closed Principle） 增加新的代碼來擴充系統，而非修改原本已存在的代碼來擴充新功能。所以在設計類別時對擴充保持開放及對修改保持封閉。若面對需求變化時，有無法封閉的變化，此時就須建立抽象點來隔離那些變化。\n里氏替換（Liskov Substitution Principle） 子類別必須可以替換父類別而不影響程式架構。若使用繼承，子類別實作的行為必須與父類別或介面所定義的行為一致，且子類別可完全取代父類別。\n介面隔離（Interface Segregation Principle） 抽取相同的功能形成介面，再讓各類別去實作。即針對不同類別開放對應需求的介面，需抽換時只需實作介面類別即可，大量降低耦合度。\n依賴反轉（Dependency Inversion Principle） 高階模組不應依賴低階模組，兩者都應依賴在抽象概念上；抽象概念不依賴細節，而細節依賴在抽象概念。模組之間若太過耦合，很容易出現修改A又被迫修改B的情況，若依賴抽象則兩只只要關注自己本身即可。\nReference 【大話設計模式】\n","permalink":"https://fakestandard.github.io/post/oop/oop-3-oop-principles/","summary":"Start 前篇講解 OOP 的特性卻還沒介紹基本原則，馬上來惡補一下內功心法。\n物件導向設計五大原則「SOLID」由羅伯特·C·馬丁在21世紀早期提出，SOLID分別為單一功能原則、開閉原則、里氏替換原則、介面隔離原則、依賴反轉原則。\n了解物件導向基本原則及特性，透過不斷練習和思考就可寫出閱讀性、維護性、擴充性高的程式碼，然而開發易維護與擴展的系統也變得不難。\n單一職責（Single Responsibility Principle） 對一個類別來說，應該只有一個引起他變化的理由，意為一個類別應只專注做一件事，當類別需要做兩件以上的工作時，就承擔了過多的職責，一旦需變更代碼，耦合度會比一件工作還要高，而當發生錯誤時很難快速定位錯誤原因，間接導致程式碼可閱讀性降低。\n開放封閉（Open-Closed Principle） 增加新的代碼來擴充系統，而非修改原本已存在的代碼來擴充新功能。所以在設計類別時對擴充保持開放及對修改保持封閉。若面對需求變化時，有無法封閉的變化，此時就須建立抽象點來隔離那些變化。\n里氏替換（Liskov Substitution Principle） 子類別必須可以替換父類別而不影響程式架構。若使用繼承，子類別實作的行為必須與父類別或介面所定義的行為一致，且子類別可完全取代父類別。\n介面隔離（Interface Segregation Principle） 抽取相同的功能形成介面，再讓各類別去實作。即針對不同類別開放對應需求的介面，需抽換時只需實作介面類別即可，大量降低耦合度。\n依賴反轉（Dependency Inversion Principle） 高階模組不應依賴低階模組，兩者都應依賴在抽象概念上；抽象概念不依賴細節，而細節依賴在抽象概念。模組之間若太過耦合，很容易出現修改A又被迫修改B的情況，若依賴抽象則兩只只要關注自己本身即可。\nReference 【大話設計模式】","title":"【OOP】物件導向設計的五大原則"},{"content":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  內插搜尋演算法（Interpolation Search） 內插搜尋法又稱插補搜尋法，是二分搜尋法的改良版，主要是針對以排序的資料進行搜尋，與二分法相同。其原理為透過斜率公式預測資料的所在位置，再以二分法逐漸逼近。\n參考斜率公式說明\n實作公式\nMid = left + ((key-data[left]) * (right - left) / (data[right] - data[left])) 演算法分析  資料需事先排序 資料分佈越平均，搜尋速度越快。時間複雜度取決於資料分佈情況，平均會優於 O(logn)  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作內插搜尋法的過程\n建立靜態陣列物件及內插搜尋方法\n// 建立靜態陣列物件 static int[] data = new int[100]; static int Interpolation(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.Length - 1; // 右邊極限  int tmp; while (left \u0026lt;= right) { // 套用公式  tmp = (int)((float)(val - data[left]) * (right - left) / (data[right] - data[left])); mid = left + tmp; if (mid \u0026gt; 100 || mid \u0026lt; -1) return -1; if (val == data[mid]) return mid + 1; else if (val \u0026lt; data[mid]) right = mid - 1; else if (val \u0026gt; data[mid]) left = mid + 1; } return -1; } Main 方法\nstatic void Main(string[] args) { int i, j; int val = 0; int num = 0; // 亂數產生值並塞入陣列  Random r = new Random(); for (i = 0; i \u0026lt; data.Length; i++) data[i] = ((r.Next(150)) % 150) + 1; // 使用 C# 內建排序  Array.Sort(data); // 輸出資料內容  for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 10; j++) Write($\u0026#34;{i * 10 + j + 1}({data[i * 10 + j]}) \u0026#34;); WriteLine(); } while (val != -1) { Write(\u0026#34;請輸入欲搜尋的鍵值(1-150之間)，或是輸入 -1 離開\u0026#34;); val = int.Parse(Console.ReadLine()); if (val == -1) break; // 內插搜尋  num = Interpolation(val); WriteLine($\u0026#34;找到鍵值 {val} 在陣列中第 {num} 個資料\u0026#34;); } ReadLine(); } Note 不得不說，透過斜率預測資料位置，發明這個方法的人太厲害。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/","summary":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  內插搜尋演算法（Interpolation Search） 內插搜尋法又稱插補搜尋法，是二分搜尋法的改良版，主要是針對以排序的資料進行搜尋，與二分法相同。其原理為透過斜率公式預測資料的所在位置，再以二分法逐漸逼近。\n參考斜率公式說明\n實作公式\nMid = left + ((key-data[left]) * (right - left) / (data[right] - data[left])) 演算法分析  資料需事先排序 資料分佈越平均，搜尋速度越快。時間複雜度取決於資料分佈情況，平均會優於 O(logn)  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作內插搜尋法的過程\n建立靜態陣列物件及內插搜尋方法\n// 建立靜態陣列物件 static int[] data = new int[100]; static int Interpolation(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.","title":"【Algorithm】搜尋演算法—內插搜尋法（Interpolation Search）"},{"content":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。\n假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。\n演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程\n建立靜態陣列物件及二分搜尋方法\n// 建立靜態陣列物件 static int[] data = new int[100]; /// \u0026lt;summary\u0026gt; /// 二分搜尋方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;val\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.Length - 1; // 右邊極限  while (left \u0026lt;= right) { // 取得中間值  mid = (left + right) / 2; // 鍵值與中間值比較  if (val == data[mid]) return mid + 1; else if (val \u0026lt; data[mid]) right = mid - 1; else if (val \u0026gt; data[mid]) left = mid + 1; else return -1; } return -1; } Main 方法\nstatic void Main(string[] args) { int i, j; int val = 0; int num = 0; // 亂數產生值並塞入陣列  Random r = new Random(); for (i = 0; i \u0026lt; data.Length; i++) data[i] = ((r.Next(150)) % 150) + 1; // 使用 C# 內建排序  Array.Sort(data); // 輸出資料內容  for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 10; j++) Write($\u0026#34;{i * 10 + j + 1}({data[i * 10 + j]}) \u0026#34;); WriteLine(); } while (val != -1) { Write(\u0026#34;請輸入欲搜尋的鍵值(1-150之間)，或是輸入 -1 離開\u0026#34;); val = int.Parse(Console.ReadLine()); if (val == -1) break; // 二分搜尋  num = BinarySearch(val); WriteLine($\u0026#34;找到鍵值 {val} 在陣列中第 {num} 個資料\u0026#34;); } ReadLine(); } Note 本書在範例的地方要設計 80 個整數，結果實際代碼卻只 Random 50 個整數，另外二分搜尋法必須是排序後的資料，結果代碼沒有撰寫排序部分，也沒有在空白處多註明要讀者自己進行排序，有些地方看起來是複製貼上，卻未細心檢查，目前讀了五個章節，每個章節都會有失誤的地方，本書在校閱的時候有待加強。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/","summary":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。\n假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。\n演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程\n建立靜態陣列物件及二分搜尋方法\n// 建立靜態陣列物件 static int[] data = new int[100]; /// \u0026lt;summary\u0026gt; /// 二分搜尋方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;val\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.","title":"【Algorithm】搜尋演算法—二分搜尋法（Binary Search）"},{"content":"【ASP.NET Core 5】\nStart ASP.NET Core 會根據執行階段的環境變數，來設定應用程式的行為。如開發環境、測試環境及正式環境的組態設定會不太相同，使用的資料庫也會不同。\nEnvironment Variable 預設的三種環境\n Development 開發環境 Staging 暫存(測試)環境 Production 正式環境  環境名稱由系統變數 ASPNETCORE_ENVIRONMENT 的內容值而來，該變數可在 launchSettings.json 作變更。\n開啟 launchSettings.json，在 profiles 節點找到 IIS Express\\..\\environmentVariables 的 ASPNETCORE_ENVIRONMENT，將原本的 Development 變更為 Production。\n\u0026#34;profiles\u0026#34;: { \u0026#34;IIS Express\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;IISExpress\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Production\u0026#34; } } } 開啟 Startup.cs，Configure 方法已注入 IWebHostEnvironment，在方法內使用下列程式碼判斷環境變數內容值\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsProduction()) // 假設是生產環境  { app.Run(async (context) =\u0026gt; { await context.Response.WriteAsync( $\u0026#34;EnvironmentName: {env.EnvironmentName}\\r\\n\u0026#34; + $\u0026#34;IsProduction: {env.IsProduction()}\u0026#34;); }); } else if (env.IsDevelopment()) // 假設是開發環境  { app.Run(async (context) =\u0026gt; { await context.Response.WriteAsync( $\u0026#34;EnvironmentName: {env.EnvironmentName}\\r\\n\u0026#34; + $\u0026#34;IsDevelopment: {env.IsDevelopment()}\u0026#34;); }); } else if (env.IsStaging()) // 假設是測試環境  { app.Run(async (context) =\u0026gt; { await context.Response.WriteAsync( $\u0026#34;EnvironmentName: {env.EnvironmentName}\\r\\n\u0026#34; + $\u0026#34;IsStaging: {env.IsStaging()}\u0026#34;); }); } else // 假設是其他環境  { app.Run(async (context) =\u0026gt; { await context.Response.WriteAsync( $\u0026#34;EnvironmentName: {env.EnvironmentName}\\r\\n\u0026#34;); }); } } 網站啟動後，因 IWebHostEnvironment 會從系統變數 ASPNETCORE_ENVIRONMENT 取得內容值，填入至 EnvironmentName 屬性，上述範例經實際測試可得以下結果\nEnvironmentName: Production IsProduction: True 環境變數可由 launchSettings.json 變更，實際專案相關設定 UI 位置為\n專案 -\u0026gt; 屬性 -\u0026gt; 偵錯\n可看到原先在 launchSettings.json 設定的環境變數，對應到 UI 的環境變數。\nProfile \u0026amp; Launch launchSettings.json 下的 profiles/IIS Express 對應到設定檔下拉選項，設定檔下拉選項除了 IIS Express 之外，還有其餘設定檔，甚至我們可以建立多個設定檔，而所有設定檔也都會對應到 launchSettings.json 的 profiles。\n我們可以看到在預設專案的 launchSettings.json 內的 profiles 實際上會有兩個設定檔 IIS Express 和 Project Name。Project Name 所啟動的是 Kestrel web server，可由 launchSettings.json 下的 CommandName 指定要啟動的伺服器，或者在 UI 的啟動下拉選單指定，可指為以下三種\n IISEXpress 啟動 IIS Express IIS 未啟動任何 Web Server Project 啟動 Kestrel  嘗試將 IIS Express 設置為生產環境，Project Name 設置為開發環境\n\u0026#34;profiles\u0026#34;: { \u0026#34;IIS Express\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;IISExpress\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Production\u0026#34; } }, \u0026#34;NetCore5\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5001;http://localhost:5000\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } 實際對兩者啟用不同伺服器以運行應用程式，分別執行 IIS Express 以及 NetCore5 (Project Name)\n兩者運行結果分別為\n[IIS Express] EnvironmentName: Production IsProduction: True [Project Name] EnvironmentName: Development IsDevelopment: True 環境設定 設置裝置的系統環境變數，以利應用程式判斷系統環境。\n開啟控制台 -\u0026gt; 系統及安全性 -\u0026gt; 系統 -\u0026gt; 進階系統設定 -\u0026gt; 環境變數\n添加系統變數 ASPNETCORE_ENVIRONMENT\n此動作需要使用系統管理員權限執行，若設定完沒有生效，嘗試重新登入或重開機。\n如此一來該裝置就被定義為正式環境，未來在裝置上運行應用程式時，就可以使用 env.IsProduction() 來判斷該環境，再讀取合適的設定檔。\nNote 了解環境變數使用方式及使用時機後，奠定未來開發時對環境概念，在專案一開始進行時，先定義不同環境的設定檔，供不同環境使用，就不需要每次變更環境時，還要重新定義一次設定檔。\nReference Use multiple environments in ASP.NET Core\n","permalink":"https://fakestandard.github.io/netcore/netcore5-7-environments/","summary":"【ASP.NET Core 5】\nStart ASP.NET Core 會根據執行階段的環境變數，來設定應用程式的行為。如開發環境、測試環境及正式環境的組態設定會不太相同，使用的資料庫也會不同。\nEnvironment Variable 預設的三種環境\n Development 開發環境 Staging 暫存(測試)環境 Production 正式環境  環境名稱由系統變數 ASPNETCORE_ENVIRONMENT 的內容值而來，該變數可在 launchSettings.json 作變更。\n開啟 launchSettings.json，在 profiles 節點找到 IIS Express\\..\\environmentVariables 的 ASPNETCORE_ENVIRONMENT，將原本的 Development 變更為 Production。\n\u0026#34;profiles\u0026#34;: { \u0026#34;IIS Express\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;IISExpress\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Production\u0026#34; } } } 開啟 Startup.cs，Configure 方法已注入 IWebHostEnvironment，在方法內使用下列程式碼判斷環境變數內容值\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsProduction()) // 假設是生產環境  { app.Run(async (context) =\u0026gt; { await context.","title":"【.NET Core】環境變數 Environments"},{"content":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。\n它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。\n假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。\n利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。\n演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n+1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程\nstatic void Main(string[] args) { int i, j; int val = 0; int find = 0; // 建立陣列物件  int[] data = new int[100]; // 亂數產生值並塞入陣列  Random r = new Random(); for (i = 0; i \u0026lt; data.Length; i++) data[i] = ((r.Next(150)) % 150) + 1; // 輸出資料內容  for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 10; j++) Write($\u0026#34;{i * 10 + j + 1}({data[i * 10 + j]}) \u0026#34;); WriteLine(); } while (val != -1) { find = 0; Write(\u0026#34;請輸入欲搜尋的鍵值(1-150之間)，或是輸入 -1 離開\u0026#34;); val = int.Parse(Console.ReadLine()); // 循序搜尋, 走訪陣列內所有的值  for (i = 0; i \u0026lt; data.Length; i++) { if (data[i] == val) { WriteLine($\u0026#34;在第 {i + 1} 個位置找到鍵值 {val}\u0026#34;); find++; } } if (find == 0) WriteLine($\u0026#34;沒有找到 {val} \u0026#34;); } ReadLine(); } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/","summary":"【5/21 閱讀紀錄】\n搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。\n依據資料量大小而言，搜尋可分為兩種\n 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種\n 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub\nStart 常見的搜尋演算法\n 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。\n它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。\n假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。\n利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。\n演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n+1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程","title":"【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）"},{"content":"Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。\n 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明\n 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。\n封裝的好處\n 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。\nstatic void Main(string[] args) { Swordman swordman = new Swordman(); } /// \u0026lt;summary\u0026gt; /// 封裝類別 /// \u0026lt;/summary\u0026gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。\n原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。\n/// \u0026lt;summary\u0026gt; /// 盜賊類別 /// \u0026lt;/summary\u0026gt; class Thief { private string name = string.Empty; private int count = 2; public int Count { get { return count; } set { count = value; } } public Thief(string name) { this.name = name; } public Thief() { this.name = \u0026#34;GM大大\u0026#34;; } public string Attack() { string result = string.Empty; for (int i = 0; i \u0026lt; count; i++) { result += name + \u0026#34;使出\u0026#34; + \u0026#34;「基本攻擊」\\n\u0026#34;; } return result; } } 剛建立的 Thief 與先前建立的 Swordman 皆為職業，我們可以創建一個 CareerBasic 作為父類別，把職業會有的屬性或方法放到 CareerBasic 類別，讓 Thief 與 Swordman 繼承 CareerBasic，這樣一來子類別就擁有父類別的屬性和方法，而不用寫相似的代碼在各個職業裡。\n接著我們讓類別們各司其職。建立 CareerBasic 類別且先不寫任何代碼。將 Thief 與 Swordman 相同的程式碼移至 CareerBasic 下。前面提到子類別擁有父類別 private 以外的屬性和方法，所以子類別想繼承原本 private 的屬性或方法時，但父類別又不想公開屬性或方法給外部使用，此時就需要設為 protected 層級，僅供給子類別使用。\n/// \u0026lt;summary\u0026gt; /// 職業基礎類別 /// \u0026lt;/summary\u0026gt; class CareerBasic { /// \u0026lt;summary\u0026gt;  /// 改為保護層級供子類別存取  /// \u0026lt;/summary\u0026gt;  protected string name = string.Empty; protected int num = 2; /// \u0026lt;summary\u0026gt;  /// 攻擊次數公開屬性  /// \u0026lt;/summary\u0026gt;  public int Num { get { return num; } set { // 給予限制  if (value \u0026gt;= 10) num = 10; else num = value; } } public CareerBasic(string name) { this.name = name; } public CareerBasic() { this.name = \u0026#34;GM大大\u0026#34;; } /// \u0026lt;summary\u0026gt;  /// 公開攻擊方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Attack() { string result = string.Empty; for (int i = 0; i \u0026lt; num; i++) { result += name + \u0026#34;使出\u0026#34; + \u0026#34;「基本攻擊」\\n\u0026#34;; } return result; } } 以 Thief 為例，讓 Thief 繼承 CareerBasic 使其擁有父類別的屬性、方法、欄位、事件和索引指示器…等，在對自己做調整，來實現父類別的功能。要注意的地方是建構式不能被繼承，只能被調用，使用 「base」 關鍵字調用父類別。來看看繼承 CareerBasic 後的 Thief 內部還剩下什麼…\n/// \u0026lt;summary\u0026gt; /// 繼承格式寫法為 =\u0026gt; 子類別 : 父類別 /// \u0026lt;/summary\u0026gt; class Thief : CareerBasic { /// \u0026lt;summary\u0026gt;  /// 調用父類別相同參數類型的建構式，用 base 關鍵字代表父類別  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public Thief(string name) : base(name) { } /// \u0026lt;summary\u0026gt;  /// 調用父類別空的建構式，一樣使用 base 關鍵字來代表父類別  /// \u0026lt;/summary\u0026gt;  public Thief() : base() { } } 可以看到子類別的代碼少了許多，嚴重懷疑是否有繼承父類，實際來看實體化 Thief 後擁有哪些方法和屬性。\n看到 thief 有 Attack() 方法和 Count 屬性，真的有繼承父類的屬性和方法，這樣筆者就放心了，有多少財產就要繼承多少（笑）\n原本在 Thief 空建構式是繼承父類別的，現在希望 Thief 實體化時不使用父類別建構式，Thief 初始化時的 name 設置為兩把刀，既然不一樣的名字那就不能寫在父類別，這時就可使用方法重載，讓子類別重寫父類別的功能。\n/// \u0026lt;summary\u0026gt; /// 盜賊 /// \u0026lt;/summary\u0026gt; class Thief : CareerBasic { public Thief(string name) : base(name) { } /// \u0026lt;summary\u0026gt;  /// 原本調用父類別空的建構式，讓子類別重寫  /// \u0026lt;/summary\u0026gt;  public Thief() { name = \u0026#34;兩把刀\u0026#34;; } } 要如何得知他是否有有繼承到父類別，而且還重寫父類別的方法？馬上來看看 name 來自哪裡…\n從上圖中可以看到 name 來自 CareerBasic 父類別，也就是說，當 Thief 實體化時，原本「GM大大」會被重寫為「兩把刀」\n多型（Polymorphism） 多型的定義是具有兩個或兩個以上名稱相同的方法，且可以傳入不同個數的參數或是型態，利用參數個數和型態，來呼叫到對應的方法。多型包含「多載（Overloading）」及「複寫（Overriding）」，前面有介紹過多載（方法重載），來說說複寫吧！若子類別要實作父類別的成員，則須將父類別成員宣告成 Virtral，子類別使用時則使用關鍵字 Override 來取代父類別實作。\n假設每個職業都有一個被動技能，每個職業被動技能的名稱不一樣，每次釋放被動技能時會根據不同職業而返回不同名稱，但他們都有釋放的動作，所以釋放這個動作就可以放在父類別，而名稱放在子類別透過子類別實現自己的名稱。\n/// \u0026lt;summary\u0026gt; /// 父類別加入虛擬方法，讓子類別可以複寫 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public virtual string PassiveSkill() { return \u0026#34; 使出被動技能： \u0026#34;; } Thief 及 Swordman 分別複寫 PassiveSkill 方法。\n// Thief 複寫 父類別方法 public override string PassiveSkill() { return name + base.PassiveSkill() + \u0026#34;二刀連擊\u0026#34;; } // Swordman 複寫 父類別方法 public override string PassiveSkill() { return name + base.PassiveSkill() + \u0026#34;攻擊弱點\u0026#34;; } 不同職業有不同的被動技能，也可隨意對角色取名，但誰也不知道誰是什麼職業，只能透過喊出的技能名稱來分辨。\nReference 【大話設計模式】\n","permalink":"https://fakestandard.github.io/post/oop/oop-2-oop-feature/","summary":"Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。\n 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明\n 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。\n封裝的好處\n 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。\nstatic void Main(string[] args) { Swordman swordman = new Swordman(); } /// \u0026lt;summary\u0026gt; /// 封裝類別 /// \u0026lt;/summary\u0026gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。\n原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。\n/// \u0026lt;summary\u0026gt; /// 盜賊類別 /// \u0026lt;/summary\u0026gt; class Thief { private string name = string.","title":"【OOP】物件導向特性—封裝、繼承、多型"},{"content":"【5/18 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。\n假設有一陣列，陣列資料分別為\n                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值\n將二元樹轉換成堆積樹，若由大到小排序，則須建立最大堆積樹，反之，由小到大排序則建立最小堆積樹。先示範如何進行遞減（由大到小排序），從最上面樹根開始，以樹的階層進行比較，來建立堆積樹。\nStep 1 首先是A[0]與A[1]比較，因A[1]=81 \u0026gt; A[0]=69，故兩者交換位置。\nStep 2 繼續將A[0]與A[2]進行比較，因A[0]=81 \u0026gt; A[2]=30，故不交換\nStep 3 第一階層與第二階層節點都比較完後，繼續進行第二階層與第三節層的比較。分別將A[1]與A[3] A[4]進行比較，因A[1]都大於兩者，故也不交換。\nStep 4 A[2]與A[5] A[6]比較，A[5]小於A[2]，故不交換。但A[6]大於A[2]，故兩者交換。\nStep 5 因A[2]節點有被交換過，故新的A[2]節點需要在與上層A[0]進行比較，因A[0]依舊大於A[2]，故不交換。\nStep 6 進行第三階層與第四階層比較，因A[7]=61 \u0026gt; A[3]=28，故交換。\nStep 7 交換後新的A[3]在與上層A[1]比較，因A[1]仍舊大於A[3]，故不交換。\n到目前為止我們就建立了一個堆積樹，將樹再轉換成陣列表示如下\n                 索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7] A[8]   數值 81 69 47 61 9 2 30 38 32    從堆積樹中可以發現整個排序尚未完成，但樹根是該樹最大的值，此時將樹根A[0]移除，再重新建立一顆堆積樹。\n拔除後的陣列表示如下\n                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 47 61 9 2 30 38 32    建立一個空陣列，依序存放被拔除的陣列\n         索引 A[0]   數值 81    將陣列轉換為一顆二元樹\n重複 Step 1 到 Step 7 的步驟，反覆進行比較，直到某個樹根移除後，已經沒有任何節點，則堆積樹排序完成。下列接著示範每次建立堆積樹比較後的結果，將此案例作完。\n第一次比較後結果 拔除樹根後的陣列\n               索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6]   數值 47 61 32 2 30 38 9    拔除樹根後的樹 被拔除的陣列\n          索引 A[0] A[1]   數值 81 69    第二次比較後結果 拔除樹根後的陣列\n              索引 A[0] A[1] A[2] A[3] A[4] A[5]   數值 47 38 2 30 32 9    拔除樹根後的樹 被拔除的陣列\n           索引 A[0] A[1] A[2]   數值 81 69 61    第三次比較後結果 拔除樹根後的陣列\n             索引 A[0] A[1] A[2] A[3] A[4]   數值 38 9 30 32 2    拔除樹根後的樹 被拔除的陣列\n            索引 A[0] A[1] A[2] A[3]   數值 81 69 61 47    第四次比較後結果 拔除樹根後的陣列\n            索引 A[0] A[1] A[2] A[3]   數值 32 30 9 2    拔除樹根後的樹 被拔除的陣列\n             索引 A[0] A[1] A[2] A[3] A[4]   數值 81 69 61 47 38    第五次比較後結果\n由於最後的堆積樹每次拔除樹根後都不會再有交換，故依序將被拔除的樹根填入陣列，該陣列即為最終的排序結果。\n被拔除的陣列\n                 索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7] A[8]   數值 81 69 61 47 38 32 30 9 2    演算法分析  非穩定排序法 所有情況下，時間複雜度為 O(nlogn) 空間複雜度為 O(1)，因為只需要一個空間存放排序結果  實際撰寫程式碼 利用堆積樹排序的概念撰寫一個可以排序陣列的程式\n建立兩個靜態變數，以及隨機產生陣列和輸出的方法\nstatic int size; static int[] arr; /// \u0026lt;summary\u0026gt; /// 隨機產生陣列 /// \u0026lt;/summary\u0026gt; static void InputArr() { arr = new int[size + 1]; Random rand = new Random(); for (int i = 1; i \u0026lt; size; i++) arr[i] = Math.Abs(rand.Next(99)) + 1; } /// \u0026lt;summary\u0026gt; /// 輸出陣列 /// \u0026lt;/summary\u0026gt; static void OutputArr() { for (int i = 1; i \u0026lt; size; i++) Write($\u0026#34;{arr[i]} \u0026#34;); WriteLine(); } 建立堆積樹和堆積樹比較方法\n/// \u0026lt;summary\u0026gt; /// 堆積樹 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Heap(int[] data, int size) { // 建立堆積樹節點  for (int i = (size / 2); i \u0026gt; 0; i--) AddHeap(data, i, size - 1); Write(\u0026#34;堆積內容：\u0026#34;); OutputArr(); WriteLine(); int tmp; // 堆積排序  for (int i = (size - 2); i \u0026gt; 0; i--) { // 頭尾節點交換  tmp = data[i + 1]; data[i + 1] = data[1]; data[1] = tmp; // 處理剩餘節點  AddHeap(data, 1, i); Write(\u0026#34;處理過程：\u0026#34;); OutputArr(); } } /// \u0026lt;summary\u0026gt; /// 堆積樹比較 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;i\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void AddHeap(int[] data, int i, int size) { int j = i * 2; int post = 0; int tmp = data[i]; while (j \u0026lt;= size \u0026amp;\u0026amp; post == 0) { if (j \u0026lt; size) { // 找出最大節點  if (data[j] \u0026lt; data[j + 1]) j++; } // 若樹根較大，則結束比較  if (tmp \u0026gt;= data[j]) post = 1; else // 若樹根較小，則繼續比較  { data[j / 2] = data[j]; j = 2 * j; } } // 指定樹根為父節點  data[j / 2] = tmp; } Main 方法\nstatic void Main(string[] args) { Write(\u0026#34;請輸入陣列大小：\u0026#34;); size = int.Parse(Console.ReadLine()); InputArr(); Write(\u0026#34;原始陣列：\u0026#34;); OutputArr(); // 建立堆積樹  Heap(arr, size); WriteLine(); Write(\u0026#34;排序結果：\u0026#34;); OutputArr(); Console.ReadLine(); } Note 在堆積樹的概念中，蠻清楚明瞭，實際參考本書代碼，有點似懂非懂，有空再參考谷哥大神有沒有更好理解的代碼，或是再更加理解代碼其中的深奧。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/","summary":"【5/18 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。\n假設有一陣列，陣列資料分別為\n                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值","title":"【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）"},{"content":"【5/20 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例\nLSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較\nStep 1 將每個元素依照「個位數」放到相對應的串列中\n                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259\nStep 2 接續使用合併後的結果，對十位數進行分配到串列中\n                 0 1 2 3 4 5 6 7 8 9   7   34 45 59 60 171  95        259 168 372      將分配的結果合併 7 34 45 59 259 60 168 171 372 95\nStep 3 繼續使用合併後的結果，對百位數進行分配\n                 0 1 2 3 4 5 6 7 8 9   7 168 259 372         34 171           45            59            60            95             將結果合併 7 34 45 59 60 95 168 171 259 372，即完成排序\nMSD 若以 MSD 方式對相同數列 59 95 7 34 60 168 171 259 372 45 進行比較，與 LSD 不同的地方就是反向比較，從最大位數百位數開始比較，接著比較十位數，直到個位數比較完後，即完成排序，就不演練其過程。\n演算法分析  屬於一種穩定排序法 所有情況下，時間複雜度皆為 O(nlog_pk)，k 是原始資料的最大值 由於會使用到很大的額外空間來存放分配的過程，空間複雜度為 O(n*p)，n 為原始資料的個數，p 是資料字元數即最大的位數，上述範例 p 為 3，因百位數是第三位數。 若 n 很大、p 固定或很小，該方法會很有效率   O(nlog_pk) - _p 的部分是底數為 p\n 實際撰寫程式碼 使用者自行輸入一個陣列大小，在透過基數排序法進行排序\n先宣告靜態變數，以及隨機產生陣列和輸出方法\nstatic int size; static int[] arr; /// \u0026lt;summary\u0026gt; /// 隨機產生陣列 /// \u0026lt;/summary\u0026gt; static void InputArr() { arr = new int[size]; Random rand = new Random(); for (int i = 0; i \u0026lt; size; i++) arr[i] = Math.Abs(rand.Next(999)) + 1; } /// \u0026lt;summary\u0026gt; /// 輸出陣列 /// \u0026lt;/summary\u0026gt; static void OutputArr() { for (int i = 0; i \u0026lt; size; i++) Write($\u0026#34;{arr[i]} \u0026#34;); WriteLine(); } 建立基數排序方法\n/// \u0026lt;summary\u0026gt; /// 基數排序 /// \u0026lt;/summary\u0026gt; static void Radix() { int i, j, k, n, m; // n 為基數, 由個位數開始  for (n = 1; n \u0026lt;= 100; n = n * 10) { // 設定暫存陣列 [0-9 位數, 資料個數]  int[,] tmp = new int[10, size]; // 比對所有資料  for (i = 0; i \u0026lt; size; i++) { // 取 n 位數的值  m = (arr[i] / n) % 10; // 將值暫存於 tmp  tmp[m, i] = arr[i]; } k = 0; // 將結果合併放到數列中  for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; size; j++) { if (tmp[i, j] != 0) { arr[k] = tmp[i, j]; k++; } } } Write($\u0026#34;經過 {n} 位數的排序後: \u0026#34;); OutputArr(); } } Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-16-radixsort/","summary":"【5/20 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例\nLSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較\nStep 1 將每個元素依照「個位數」放到相對應的串列中\n                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259","title":"【Algorithm】排序演算法—基數排序法（Radix Sort）"},{"content":"【ASP.NET Core 5】\nStart .NET Framework 的組態通常在 app.config 或 web.config 中設定，在 .NET Core 不再使用過往讀取單一檔案方法，它使用一個或多個 Configuration Provider 來提供多種設定組態的方式。\n預設組態 應用程式在 Program.cs 預設產生 Host.CreateDefaultBuilder(args) 程式碼，CreateDefaultBuilder 會依照下列 Provider 的順序提供應用程式預設組態\n ChainedConfigurationProvider appsettings.json appsettings.Environment.json Environment Variables configuration provider Command-line configuration provider  使用下列程式碼，依新增順序來顯示 Configuration Provider\nprivate IConfigurationRoot ConfigRoot; public HomeController(IConfiguration configRoot) { ConfigRoot = (IConfigurationRoot)configRoot; } public ContentResult OnGet() { string str = \u0026#34;\u0026#34;; foreach (var provider in ConfigRoot.Providers.ToList()) { str += provider.ToString() + \u0026#34;\\n\u0026#34;; } return Content(str); } 結果與前述說明的順序相同\nMicrosoft.Extensions.Configuration.ChainedConfigurationProvider JsonConfigurationProvider for \u0026#39;appsettings.json\u0026#39; (Optional) JsonConfigurationProvider for \u0026#39;appsettings.Development.json\u0026#39; (Optional) EnvironmentVariablesConfigurationProvider CommandLineConfigurationProvider appsettings.json 如果說過去使用 *.config 設定組態檔，那麼現在則是使用 appsettings.json 來設定，兩者在格式上也有所區別，.NET Framework 使用 XML 格式來存儲資料，.NET Core 則採用 JSON 格式來儲存資料。\n除了在格式上的差別之外，過去在讀取組態設定檔是使用 ConfigurationManager 物件讀取，.NET Core 則是遵循 DI 概念，取得 IConfiguration 實例介面以存取組態設定檔。\n在 appsetting.json 配置 Position 階層以及 MyKey\n{ \u0026#34;Position\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;Editor\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;Visual Studio\u0026#34; }, \u0026#34;MyKey\u0026#34;: \u0026#34;My appsettings.json Value\u0026#34;, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;NetCore5\u0026#34;: \u0026#34;Trace\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Error\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } 取得 IConfiguration 實例介面以讀取組態設定檔的值\nprivate readonly IConfiguration _configuration; public HomeController(IConfiguration configuration) { _configuration = configuration; } public ContentResult OnGet() { var myKeyValue = _configuration[\u0026#34;MyKey\u0026#34;]; var title = _configuration[\u0026#34;Position:Title\u0026#34;]; var name = _configuration[\u0026#34;Position:Name\u0026#34;]; var defaultLogLevel = _configuration[\u0026#34;Logging:LogLevel:Default\u0026#34;]; return Content($\u0026#34;MyKey value: {myKeyValue} \\n\u0026#34; + $\u0026#34;Title: {title} \\n\u0026#34; + $\u0026#34;Name: {name} \\n\u0026#34; + $\u0026#34;Default Log Level: {defaultLogLevel}\u0026#34;); } 可得以下結果，與 ConfigurationManager 物件得到的結果相同\nMyKey value: My appsettings.json Value Title: Editor Name: Visual Studio Default Log Level: Information 使用 options pattern 繫結階層式組態資料 從 appsettings.json 取得資料存於變數中，還可以使用 options pattern 來綁定階層式的組態資料到指定類別，例如建立一個接收 Options 層級的類別 PositionOptions\npublic class PositionOptions { public const string Position = \u0026#34;Position\u0026#34;; public string Title { get; set; } public string Name { get; set; } } Options 類別必須遵循以下規則\n 必須是公共的非抽象無參數之空建構子 該類型的所有公共 read-write 屬性都會被綁定 欄位不會綁 定，可以參照上述代碼中的 Position，該欄位沒有被綁定。  使用下列代碼，動作解析為\n 呼叫 ConfigurationBinder.Bind 將 PositionOptions 類別綁定到 Position 部分 顯示 Position 組態資料  private readonly IConfiguration _configuration; public HomeController(IConfiguration configuration) { _configuration = configuration; } public ContentResultOnGetPosition() { var positionOptions = new PositionOptions(); _configuration.GetSection(PositionOptions.Position).Bind(positionOptions); return Content($\u0026#34;Title: {positionOptions.Title} \\n\u0026#34; + $\u0026#34;Name: {positionOptions.Name}\u0026#34;); } ConfigurationBinder.Get\u0026lt;T\u0026gt; 使用 ConfigurationBinder.Get\u0026lt;T\u0026gt; 綁定並傳回指定型別，取代 ConfigurationBinder.Bind，前者在使用上方便於後者。\nprivate readonly IConfiguration _configuration; public PositionOptions positionOptions { get; private set; } public HomeController(IConfiguration configuration) { _configuration = configuration; } public ContentResult onGetSection() { positionOptions = _configuration.GetSection(PositionOptions.Position).Get\u0026lt;PositionOptions\u0026gt;(); return Content($\u0026#34;Title: {positionOptions.Title} \\n\u0026#34; + $\u0026#34;Name: {positionOptions.Name}\u0026#34;); } 將類別添加到 DI 服務容器並綁定 除上述兩種方法可讀取組態設定檔，還可以綁定 Position 區段，並將它添加到 DI 服務容器中，直接參考代碼\npublic void ConfigureServices(IServiceCollection services) { ... // 將 PositionOptions 添加到 Configure，並添加此服務  services.Configure\u0026lt;PositionOptions\u0026gt;(Configuration.GetSection(PositionOptions.Position)); ... } 讀取組態設定檔資料，使用 IOptions 時要引用 Microsoft.Extensions.Options\nprivate readonly PositionOptions _options; public HomeController(IOptions\u0026lt;PositionOptions\u0026gt; options) { _options = options.Value; } public ContentResult OnGetOptions() { return Content($\u0026#34;Title: {_options.Title} \\n\u0026#34; + $\u0026#34;Name: {_options.Name}\u0026#34;); } 以上三種方法皆可以讀取組態設定檔，可依照個人喜好習慣來選擇使用方式。\n合併 service collection 按照上述第三種方法使用 IOption 讀取組態設定檔，必須先添加配置服務，若同時配置兩種服務，形成以下情況\npublic void ConfigureServices(IServiceCollection services) { // 添加一  services.Configure\u0026lt;PositionOptions\u0026gt;(Configuration.GetSection(PositionOptions.Position)); // 添加二  services.Configure\u0026lt;ColorOptions\u0026gt;(Configuration.GetSection(ColorOptions.Color)); } 可以將相似的服務進行群組化，將其移至到擴充方法，再註冊服務。\n在 Microsoft.Extensions.DependencyInjection 命名空間下，新增以下擴充方法，將要添加的 Options 註冊到 services 中，以封裝要註冊的服務群組。\nnamespace Microsoft.Extensions.DependencyInjection { public static class MyConfigServiceCollectionExtensions { public static IServiceCollection AddConfig( this IServiceCollection services, IConfiguration config) { services.Configure\u0026lt;PositionOptions\u0026gt;(config.GetSection(PositionOptions.Position)); services.Configure\u0026lt;ColorOptions\u0026gt;(config.GetSection(ColorOptions.Color)); return services; } } } 使用新的擴充方法註冊服務。合併服務集合可以改善在 ConfigureServices 方法中註冊類似的服務。\npublic void ConfigureServices(IServiceCollection services) { services.AddConfig(Configuration); } 環境變數 .NET Core 還可以取得或新增系統的環境變數。\n開啟控制台 -\u0026gt; 系統及安全性 -\u0026gt; 系統 -\u0026gt; 進階系統設定 -\u0026gt; 環境變數\n添加系統變數\n值得注意的地方，需要使用系統管理員權限執行，若設定完沒有生效，嘗試重新登入或重開機。\n同樣添加 IConfiguration 實例介面，取得組態設定檔的資料\nprivate readonly IConfiguration _configuration; public HomeController(IConfiguration configuration) { _configuration = configuration; } public ContentResult OnGetSample() { var sample = _configuration[\u0026#34;Sample\u0026#34;]; return Content($\u0026#34;Sample({sample.GetType()}): {sample}\u0026#34;); } 得到結果\nSample(System.String): This is environment variable sample. Note 在組態設定的部分尚有許多 Configuration Provider，目前只記錄簡單應用，未來有機會使用時，再加以補充。\nReference Configuration in ASP.NET Core\nASP.NET Core 2 系列 - 組態設定 (Configuration)\n","permalink":"https://fakestandard.github.io/netcore/netcore5-6-configuration/","summary":"【ASP.NET Core 5】\nStart .NET Framework 的組態通常在 app.config 或 web.config 中設定，在 .NET Core 不再使用過往讀取單一檔案方法，它使用一個或多個 Configuration Provider 來提供多種設定組態的方式。\n預設組態 應用程式在 Program.cs 預設產生 Host.CreateDefaultBuilder(args) 程式碼，CreateDefaultBuilder 會依照下列 Provider 的順序提供應用程式預設組態\n ChainedConfigurationProvider appsettings.json appsettings.Environment.json Environment Variables configuration provider Command-line configuration provider  使用下列程式碼，依新增順序來顯示 Configuration Provider\nprivate IConfigurationRoot ConfigRoot; public HomeController(IConfiguration configRoot) { ConfigRoot = (IConfigurationRoot)configRoot; } public ContentResult OnGet() { string str = \u0026#34;\u0026#34;; foreach (var provider in ConfigRoot.Providers.ToList()) { str += provider.ToString() + \u0026#34;\\n\u0026#34;; } return Content(str); } 結果與前述說明的順序相同","title":"【.NET Core】組態設定 Configuration"},{"content":"【5/18 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。\n步驟非常好理解，如下\n 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25\nStep 1 將陣列合併成 N/2 個長度，鍵值為 2，如下 [38 16] [41 72] [52 98] [63 25]\n接著對每組進行排序並交換位置，排序結果如下 [16 38] [41 72] [52 98] [25 63]\nStep 2 繼續將陣列合併成 N/4 個長度，鍵值為 4，如下 [16 38 41 72] [52 98 25 63]\n對每組進行排序並交換位置，排序結果如下 [16 38 41 72] [25 52 63 98]\nStep 3 將陣列合併成 N/8 個長度，鍵值為 8，如下 [16 38 41 72 25 52 63 98] 進行排序並交換位置，排序結果如下 [16 25 38 41 52 63 72 98]，完成排序。\n反覆地將鍵值合併值到長度為 N 個鍵值，在上述的例子中，在第三步驟的鍵值為 8 剛好等於 N，所以排序即完成。\n演算法分析  是穩定排序法 排序的過程中需要一個數列大小相同的記憶體空間，故空間複雜度為 O(n) 在最佳、最差和平均情況下，時間複雜度皆為 O(nlogn)  實際撰寫程式碼 建立靜態變數，以及產生隨機陣列和輸出資料的方法\nstatic int size; static int[] arr; /// \u0026lt;summary\u0026gt; /// 隨機產生陣列 /// \u0026lt;/summary\u0026gt; static void InputArr() { arr = new int[size + 1]; Random rand = new Random(); for (int i = 0; i \u0026lt; size; i++) arr[i] = Math.Abs(rand.Next(99)) + 1; } /// \u0026lt;summary\u0026gt; /// 輸出陣列 /// \u0026lt;/summary\u0026gt; static void OutputArr() { for (int i = 0; i \u0026lt; size; i++) Write($\u0026#34;{arr[i]} \u0026#34;); WriteLine(); } /// \u0026lt;summary\u0026gt; /// 輸出陣列 /// \u0026lt;/summary\u0026gt; static void OutputArr(int[] arr2) { for (int i = 0; i \u0026lt; arr2.Length; i++) Write($\u0026#34;{arr2[i]} \u0026#34;); WriteLine(); } 建立 MergeSort 遞迴方法和 Merge 合併排序方法\nstatic void MergeSort(int[] data, int size) { // 若長度 1，則不用排序  if (size \u0026lt;= 1) return; // 計算左邊長度  int Llen = size / 2; int[] left = new int[Llen]; // 將原數列一一放入左邊陣列  for (int i = 0; i \u0026lt; Llen; i++) left[i] = data[i]; // 計算右邊長度  int Rlen = size - Llen; int[] right = new int[Rlen]; // 將原數列一一放入右邊陣列  for (int j = 0; j \u0026lt; Rlen; j++) right[j] = data[Llen + j]; // 遞迴到每組鍵值為1  MergeSort(left, Llen); MergeSort(right, Rlen); // 離開遞迴後，就可進行合併排序  Merge(data, left, right); } static void Merge(int[] data, int[] left, int[] right) { int leftIndex = 0; int rightIndex = 0; int index = 0; // 反覆比對  while ((leftIndex \u0026lt; left.Length) \u0026amp;\u0026amp; (rightIndex \u0026lt; right.Length)) { if (left[leftIndex] \u0026lt; right[rightIndex]) { data[index] = left[leftIndex]; leftIndex++; } else { data[index] = right[rightIndex]; rightIndex++; } index++; } if (leftIndex \u0026lt; left.Length) while (leftIndex \u0026lt; right.Length) data[index++] = left[leftIndex++]; else while (rightIndex \u0026lt; left.Length) data[index++] = right[rightIndex++]; Write(\u0026#34;處理過程：\u0026#34;); OutputArr(data); } Main 方法\nstatic void Main(string[] args) { Write(\u0026#34;請輸入陣列大小：\u0026#34;); size = int.Parse(Console.ReadLine()); InputArr(); Write(\u0026#34;原始陣列：\u0026#34;); OutputArr(); WriteLine(); // 合併排序  MergeSort(arr, size); WriteLine(); Write(\u0026#34;排序結果：\u0026#34;); OutputArr(); Console.ReadLine(); } Note 因本書範例代碼是用兩個檔案進行合併排序，邏輯與前述的概念略有不同，故筆者改為前面所講述的概念，對一個陣列進行合併排序，且參考坊間較正統的作法，省去讀檔的過程。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-15-mergesort/","summary":"【5/18 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。\n步驟非常好理解，如下\n 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25","title":"【Algorithm】排序演算法—合併排序法（Merge Sort）"},{"content":"【5/17 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。\n其步驟如下\n 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I \u0026gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K\n               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J\n               6 8 1 4 5 3 7 2   K I      J    因為 I \u0026gt; J 所以將 I 與 J 互換\n               6 2 1 4 5 3 7 8   K I      J    I 與 J 繼續往下找，不須再從頭開始找，結果 J 找到 3，I 找到 7，此時 I 與 J 已相遇並交會\n               6 2 1 4 5 3 7 8   K     I J     將 K 與 J 互換，對調後 K 基準點（6），將數列分為左右兩個子循環，並分別對兩數列執行步驟一到步驟五，反覆執行到排序完成\n【左半邊】\n            3 2 1 4 5   K    J   I        【右半邊】\n         7 8   K J   I     \u0026hellip; 持續作業，直到排序完成。\n演算法分析  非穩定排序法 平均執行時間最快的的排序法 空間複雜度  最差情況下為 O(n) 最佳情況為 O(log2n)   時間複雜度  最快和平均情況下為 O(nlog2n) 最差情況為 O(n2)，即每次挑中的中間值不是最大就是最小     因為頁面沒辦法顯示數學公式，將就一下\nO(log2n) - 2 是底數\nO(nlog2n) - 2 是底數\nO(n2) - 2 是平方\n 實際撰寫程式碼 首先會以亂數產生隨機陣列，筆者參考坊間的代碼，並使用本身理解的程度實作代碼，因本書代碼在變數命名的地方難理解，也沒有解釋變數是做何用途，筆者就先不參考，不過實作完後再回頭看本書範例，大概就可以理解變數命名的定義了。\n先在 Program 類別定義靜態變數\nstatic int size; static int[] data; static int count = 0; 根據使用者輸入的陣列大小，進行陣列的宣告和建立，並且使用隨機亂數填充陣列值\n/// \u0026lt;summary\u0026gt; /// 輸入資料 /// \u0026lt;/summary\u0026gt; static void Input() { // 亂數輸入  Random rand = new Random(); data = new int[size]; for (int i = 0; i \u0026lt; size; i++) data[i] = (Math.Abs(rand.Next(99))) + 1; WriteLine(); } 建立可反覆輸出陣列的方法\n/// \u0026lt;summary\u0026gt;  /// 輸出資料  /// \u0026lt;/summary\u0026gt;  static void ShowData() { for (int i = 0; i \u0026lt; size; i++) Write($\u0026#34;{data[i]} \u0026#34;); WriteLine(); } 宣告並建立快速排序的方法，過程中使用遞迴的方式，反覆的排序，直到跳出遞迴結束排序為止。\n/// \u0026lt;summary\u0026gt; /// 快速排序 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;d\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lf\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;rg\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; static void Quick(int[] data, int left, int right) { // 如果左邊大於或等於右邊，則跳出  if (left \u0026gt;= right) return; // 基準數取第一個資料  int pivot = data[left]; // 左右代理人  int i = left; int j = right; int tmp; while (i != j) { // 從右邊開始找  while (data[j] \u0026gt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) j--; // 再從左邊開始找  while (data[i] \u0026lt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) i++; // 互換值  if (i \u0026lt; j) { tmp = data[i]; data[i] = data[j]; data[j] = tmp; count++; Write($\u0026#34;第 {count} 次交換：\u0026#34;); ShowData(); } } // 將基準點與 j 代理人交換位置  data[left] = data[i]; data[i] = pivot; count++; Write($\u0026#34;第 {count} 次交換：\u0026#34;); ShowData(); // 透過遞迴處理左半邊  Quick(data, left, i - 1); // 透過遞迴處理右半邊  Quick(data, i + 1, right); } Note 筆者覺得本書在步驟的地方無法馬上理解，特地谷哥其中的原理，最後發現作者在步驟的地方確實該補充一段話，才不會使得讀者上文不接下文，在未符合條件下卻交換了位置，真是誤會一場。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-14-quicksort/","summary":"【5/17 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。\n其步驟如下\n 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I \u0026gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K\n               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J","title":"【Algorithm】排序演算法—快速排序法（Quick Sort）"},{"content":"昨天在刷 LeetCode 時，發現解題方式可以使用位移運算元，雖然筆者早就看過這個運算元，卻沒實際了解過，也趁這個機會快速了解位移運算元是個什麼樣的概念。\n首先，筆者遇到的題型非常簡單，將二進位制轉換為十進位制，如將二進位 1110 轉換成十進位，得解為 14，在 C# 中可直接使用 Convert 來實現進位之間的轉換\nstring binary = \u0026#34;1110\u0026#34;; // 二進位轉十進位, 第二個參數為 base Convert.ToInt32(binary, 2); 如此是透過現成方法來實現轉換，為了更了解二進制的應用，特意觀察不少的解法，其中不少解法是透過位移運算元，撰寫起來也非常簡潔且優雅，那什麼是位移運算元？\n位移運算元有兩種\n 左位移 \u0026lt;\u0026lt; 右位移 \u0026gt;\u0026gt;  區分方式也非常易懂，純粹是位移方向的不同，以 1110 為例，對此二進位制的所有位元進行左位移一個位元，即將所有位元往左邊移動一位，而最右邊的第一個數則補上 0，得到結果為 11100，若左位移兩個位元則為 111000；反之右位移則是向右移動，對 1110 右位移一個位元得到 0111，若右位移兩個位元則得 0011。\n 左位移一個位元的表示方式為 num \u0026lt;\u0026lt; 1 左位移一個位元的表示方式為 num \u0026lt;\u0026lt; 2 右位移一個位元的表示方式為 num \u0026gt;\u0026gt; 1 右位移一個位元的表示方式為 num \u0026gt;\u0026gt; 1  實際使用程式碼測試，先宣告一個整數變數 num，因為該變數是以十進位表示之，故筆者特意註解 num 二進位的表示方式，接著透過位移運算元，向左搬移一位，最後得十進位的結果。\n// 十進位 14, 二進位 1110 int num = 14; // 向左位移 1 位 num = num \u0026lt;\u0026lt; 1; // 得到十進位 28, 二進位 11100 Console.Write(num); 試試看右位移一個位元\n// 十進位 14, 二進位 1110 int num = 14; // 向左位移 1 位 num = num \u0026gt;\u0026gt; 1; // 得到十進位 7, 二進位 0111 Console.Write(num);  讀者有發現一件神奇的事嗎？\n 如果我們向左位移一個位元，其結果會是原本的兩倍，若向右位移一位，其結果會是原本的一半。\n有這麼神奇的事？試試看一次位移兩個位元會發生什麼事\nint num = 20; // 80 Console.WriteLine(num \u0026lt;\u0026lt; 2); // 5 Console.WriteLine(num \u0026gt;\u0026gt; 2); 每增加一個位移的位元，就會作一次乘二或除二的動作，將 num=20 向左位移兩個位元，其結果就是 20 * 2 * 2 = 80，同理向右移兩個位元可得 20 / 2 / 2 = 5\n最後，位移運算元當然也有指派的運算元，若要將 num 位移後的結果指派給 num，可以這麼寫 num = num \u0026gt;\u0026gt; 1，也可以使用位移指派運算元寫成 num \u0026gt;\u0026gt;= 1，左位移則是 num \u0026lt;\u0026lt;= 1。這麼簡單的運算元，筆者真是太晚才想好好的認識它，收工！\nReference Left Shift and Right Shift Operators (\u0026raquo; and \u0026laquo;)\n","permalink":"https://fakestandard.github.io/post/csharp/csharp-2-bitwiseshiftoperators/","summary":"昨天在刷 LeetCode 時，發現解題方式可以使用位移運算元，雖然筆者早就看過這個運算元，卻沒實際了解過，也趁這個機會快速了解位移運算元是個什麼樣的概念。\n首先，筆者遇到的題型非常簡單，將二進位制轉換為十進位制，如將二進位 1110 轉換成十進位，得解為 14，在 C# 中可直接使用 Convert 來實現進位之間的轉換\nstring binary = \u0026#34;1110\u0026#34;; // 二進位轉十進位, 第二個參數為 base Convert.ToInt32(binary, 2); 如此是透過現成方法來實現轉換，為了更了解二進制的應用，特意觀察不少的解法，其中不少解法是透過位移運算元，撰寫起來也非常簡潔且優雅，那什麼是位移運算元？\n位移運算元有兩種\n 左位移 \u0026lt;\u0026lt; 右位移 \u0026gt;\u0026gt;  區分方式也非常易懂，純粹是位移方向的不同，以 1110 為例，對此二進位制的所有位元進行左位移一個位元，即將所有位元往左邊移動一位，而最右邊的第一個數則補上 0，得到結果為 11100，若左位移兩個位元則為 111000；反之右位移則是向右移動，對 1110 右位移一個位元得到 0111，若右位移兩個位元則得 0011。\n 左位移一個位元的表示方式為 num \u0026lt;\u0026lt; 1 左位移一個位元的表示方式為 num \u0026lt;\u0026lt; 2 右位移一個位元的表示方式為 num \u0026gt;\u0026gt; 1 右位移一個位元的表示方式為 num \u0026gt;\u0026gt; 1  實際使用程式碼測試，先宣告一個整數變數 num，因為該變數是以十進位表示之，故筆者特意註解 num 二進位的表示方式，接著透過位移運算元，向左搬移一位，最後得十進位的結果。\n// 十進位 14, 二進位 1110 int num = 14; // 向左位移 1 位 num = num \u0026lt;\u0026lt; 1; // 得到十進位 28, 二進位 11100 Console.","title":"【C#】位移運算元 \u003c\u003c 和 \u003e\u003e"},{"content":"【ASP.NET Core 5】\n過去在記錄 Log 時，會使用第三方套件來記錄，在 .NET Core 預設就已經將 Logger 注入到 DI 容器，直接使用 ILogger 介面來執行。\nStart 此篇會紀錄的部分有以下\n Logging Provider Create Logs Log Level Log EventID Log Message Log Exceptions Configure Logging  Logging Provider Logging Provider 會儲存記錄檔，但 Console 顯示記錄的提供者除外。\n在 Program.cs 調用 CreateDefaultBuilder 會新增下列記錄提供者\n Console Debug EventSource EventLog: Windows only  欲 override 由 Host.CreateDefaultBuilder 設置的 logging provider 集合，可呼叫 ClearProviders 移除所有 ILoggerProvider 實例，再加入需要的記錄提供者。\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureLogging(logging =\u0026gt; { logging.ClearProviders(); // 加入 Console logging provider  logging.AddConsole(); }) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); Create Logs 使用相依性注入（DI）的 ILogger\u0026lt;TCategoryName\u0026gt; 物件來建立記錄，在 HomeController 取得 ILogger\u0026lt;HomeController\u0026gt; 實例，在動作方法 Index 中調用方法來記錄 Log\nprivate readonly ILogger\u0026lt;HomeController\u0026gt; _logger; public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger) { _logger = logger; } public IActionResult Index() { // 記錄  _logger.Log(LogLevel.Information, \u0026#34;About logger information.\u0026#34;); return View(); } 使用 _logger.Log() 方法，其中第一個參數為 LogLevel 代表記錄檔的嚴重層級，通常開發人員會直接調用 Log{LogLevel} 擴展方法，如 LogError；擴展方法會呼叫 Log 並指定記錄層級，兩者皆可達相同記錄效果。\nLog Level 下列為 Log 層級之擴展方法及建議用法\n   LogLevel Value Method      Trace 0 LogTrace 追蹤   Debug 1 LogDebug 偵錯   Information 2 LogInformation 資訊   Warning 3 LogWarning 警告   Error 4 LogError 錯誤   Critical 5 LogCritical 嚴重   None 6  指定記錄類別不應寫入任何訊息    在 HomeController/Index 內呼叫 TestLog 方法，該方法內使用不同層級的擴展方法來記錄\npublic void TestLog() { _logger.LogTrace(\u0026#34;Trace log.\u0026#34;); _logger.LogDebug(\u0026#34;Debug log.\u0026#34;); _logger.LogInformation(\u0026#34;Information log.\u0026#34;); _logger.LogWarning(\u0026#34;Warning log.\u0026#34;); _logger.LogError(\u0026#34;Error log.\u0026#34;); _logger.LogCritical(\u0026#34;Critical log.\u0026#34;); } 執行 dotnet run 運行程式，可得到以下輸出\nLog something... info: NetCore5.Controllers.HomeController[0] Information log. warn: NetCore5.Controllers.HomeController[0] Warning log. fail: NetCore5.Controllers.HomeController[0] Error log. crit: NetCore5.Controllers.HomeController[0] Critical log. 實際觀察，輸出時會記錄一堆 Log，然而預期 TestLog 只會輸出六筆，實際上也只有輸出四筆，因為在 Log Level 中每種層級的定義如下\nTrace 此類 Log 包含詳細的訊息，其中可能含有敏感性的應用程式資料，不應在生產環境中啟用，通常會用於開發環境，而該類 Log 預設為停用。\nDebug 此類 Log 通常用於生產環境偵錯，避免 Log 數量過大，在生產環境中須謹慎使用，該類預設為停用\nInformation 常見的 Log 類型，用以追蹤應用程式運行的流程作業，可能具有長期價值\nWarning 針對異常或非預期的事件，通常該類訊息是不會導致應用程式失敗的錯誤或狀況，屬於警示但非錯誤，不影響應用程式運行。\nError 該類 Log 用於表示當前執行作業失敗，或者要求失敗，引發無法處理的錯誤或例外狀況，但僅此於作業，而非整個應用程式失敗。\nCritical 此類 Log 表示發生需要立即注意的失敗，通常是嚴重的錯誤事件，如資料遺失、磁碟空間不足或是系統崩潰事件等，導致應用程式無法運行的情況。\nLog Event ID 每個 Log 可以指定一個事件識別碼，下列使用 LogEvents 類別定義事件 ID\npublic class MyLogEvents { public const int GenerateItems = 1000; public const int ListItems = 1001; public const int GetItem = 1002; public const int InsertItem = 1003; public const int UpdateItem = 1004; public const int DeleteItem = 1005; public const int TestItem = 3000; public const int GetItemNotFound = 4000; public const int UpdateItemNotFound = 4001; } 建立一個 Todo 相關的動作方法，取得指定 id 的資料，當找不到該筆資料時，除了返回 Not Found 之外，透過 Logger 來記錄成警示訊息。\n[HttpGet(\u0026#34;{id}\u0026#34;)] public async IActionResult GetTodoItem(int id) { // 記錄一般資訊  _logger.LogInformation(MyLogEvents.GetItem, \u0026#34;Getting item {Id}\u0026#34;, id); var items = await _context.TodoItems.FindAsync(id); if (items == null) { // 記錄警示事件碼  _logger.LogWarning(MyLogEvents.GetItemNotFound, \u0026#34;Get {id} Not Fount\u0026#34;, id); return NotFound(); } return View(items); } 從 Event ID 可以得知，我們可以將頁面上較為相關的方法或動作，歸類成同一個 Event ID，例如在取得特定資料時返回 Not Found ，都將歸類成 4000。\n我們已經將 Event ID 帶入 Log 方法中，實際運行應用程式觀察記錄結果\ninfo: NetCore5.Controllers.HomeController[1002] Getting item 1 warn: NetCore5.Controllers.HomeController[4000] Get(1) NOT FOUND 從結果可看到，Log provider 將事件識別碼存放到識別碼欄位 [1002]，方便用於識別不同事件的一種方法。\nLog Message 在上述的範例中，除了添加第一個參數 Event ID，還添加了第二和第三個參數，第二個參數為要記錄的訊息，第三個參數則是「提供給第二個參數使用之參數」，執行下方代碼\npublic void TestLog() { string p1 = \u0026#34;param1\u0026#34;; string p2 = \u0026#34;param2\u0026#34;; _logger.LogInformation(\u0026#34;Parameter values: {p2}, {p1}\u0026#34;, p1, p2); } 查看實際記錄訊息\ninfo: NetCore5.Controllers.HomeController[0] Parameter values: param1, param2 我們可得知在提供參數部分，是依照順序來提供值，而非名稱。\nLog Exceptions Logger 還可以具有接受例外狀況的多載方法\npublic void TestLogException() { _logger.LogError(new Exception(\u0026#34;Test exception\u0026#34;), \u0026#34;Test Exception\u0026#34;); } Configure Logging 在運行應用程式時，會紀錄許多系統資訊，在先前的範例中，Trace 和 Debug 預設不會輸出，像這些預設要記錄的資訊和層級，都是在 appsettings.json 內設定。\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, } 找到 Logging，在 LogLevel 節點下已設定好預設層級及範圍，由 Default 來說，它預設是紀錄 Information 以上的層級，Microsoft 預設會記錄 Warning 以上的層級訊息，以此類推。\n透過設定檔來過濾掉一些不需要關注的 Log，將專案加入到 LogLevel 下，並設定層級為 Trace，其餘皆設置為 Error。\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;NetCore5\u0026#34;: \u0026#34;Trace\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Error\u0026#34; } }, } 實際運行應用程式，可看到原先 Trace 和 Debug 預設停用已經被修改為要記錄，而 Microsoft 的一些資訊，我們也已經將層級提到到 Error，進而關注我們想關注的部分。\nNote 過去在開發網站中，需要做紀錄時會用第三方套件，而 .NET Core 帶來內建的紀錄檔，在開發上是否能帶來新一代突破，或者，其實 Logger 與筆者所想的並非相同，待筆者實務操作後，再來分享。\nReference Logging in .NET Core and ASP.NET Core\n","permalink":"https://fakestandard.github.io/netcore/netcore5-5-logging/","summary":"【ASP.NET Core 5】\n過去在記錄 Log 時，會使用第三方套件來記錄，在 .NET Core 預設就已經將 Logger 注入到 DI 容器，直接使用 ILogger 介面來執行。\nStart 此篇會紀錄的部分有以下\n Logging Provider Create Logs Log Level Log EventID Log Message Log Exceptions Configure Logging  Logging Provider Logging Provider 會儲存記錄檔，但 Console 顯示記錄的提供者除外。\n在 Program.cs 調用 CreateDefaultBuilder 會新增下列記錄提供者\n Console Debug EventSource EventLog: Windows only  欲 override 由 Host.CreateDefaultBuilder 設置的 logging provider 集合，可呼叫 ClearProviders 移除所有 ILoggerProvider 實例，再加入需要的記錄提供者。\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.","title":"【.NET Core】記錄 Logging"},{"content":"Start 物件導向（Object-Oriented Programming），意為針對物件進行程式設計。而學習設計模式前必須先了解物件導向設計，不然難以體會設計模式的魅力。\n接下來我們會知道\n 類別（Class） 物件（Object） 實體（Instance） 建構式（Constructor） 多載（Overloading） 欄位（Field） 屬性（Property） 修飾詞（Modifiers）  類別（Class） 類別是具有相同「屬性（Attribute）」和 「功能（Method）」的物件之抽象集合。在 C# 中定義類別的關鍵字為 class，類別命名規則為第一個字母為大寫，多個單字命名時各個首字母為大寫。\n// 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法使外部可以呼叫，修飾詞用 public  public string Attack() { return \u0026#34;基本攻擊！\u0026#34;; } } 物件（Object） 物件是一個獨立的實體，實體裡包含許多資料，資料彼此之間不會互相影響，每個皆為獨立的資料。物件與類別的關係，最簡單易懂又不抽象的解釋為—物件是類別的實體。\n// 宣告一個Swordman 物件，物件名為 swordman Swordman swordman; // 先前建立的 Swordman 類別 class Swordman { ... }  在程式碼的世界裡，萬物皆為物件。\n 實體（Instance） 實體就是一個真實的物件。實體化是建立物件的過程，使用 new 關鍵字建立。\n// 實體化 swordman 物件 swordman = new Swordman(); 綜合上述介紹的類別、物件和實體，實際演練一次程式碼並觀察結果。 在 Swordman 有一個公開的 Attack 方法，當物件被實體化後，未來就能一直呼叫該方法\nstatic void Main(string[] args) { // 簡化建立與實體化物件的程式碼  // 將 Swordman 類別實體化  Swordman swordman = new Swordman(); // 調用 Attack 公開方法  string attack = swordman.Attack(); Console.WriteLine(attack); Console.ReadLine(); } // 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法  public string Attack() { return \u0026#34;基本攻擊！\u0026#34;; } } 觀看結果，輸出 Attack 方法返回的值\n建構式（Constructor） 建構式又稱建構函式或建構子，建構式是對類別初始化的函數，建構式與類別同名，無返回值也不需要 void，在使用關鍵字 new 時調用。在未定義建構式時編譯器會自動產生空的建構式。\n根據上述例子，在實體化 swordman 物件時，new 後面的 Swordman() 就是建構式，而建立 Swordman 類別時未定義建構子，所以編譯器自動產生空的 Constructor 讓 swordman 成功實體化。\n以上述的 Swordman 類別來說，編譯器產生的空建構子如下\n// 建立 Swordman 類別 class Swordman { // 空的建構子  public Swordman() { } ... } 所以，如果不需要改變空的建構子時，就可以不必撰寫空建構子的程式碼，讓編譯器在編譯時自動產生即可。\n實際演練：利用建構式來給 swordman 增加 Name，在 Swordman 類別裡加入 name 私有變數及帶有一個參數的建構子\n// 定義私有變數 name private string name; // 建立帶有參數 name 的建構子 public Swordman(string name) { // 將參數 name 指給私有變數 name  this.name = name; } 當新的建構子被建立時，編譯器變不再自動產生空的建構子，若繼續使用先前程式碼讓 swordman 實體化，會得到紅色毛毛蟲。\n此時必須給予相對應的參數，讓物件能成功實體化。給 swordman 一個瀟灑的 ID，將 Attack() 方法返回值添加上私有變數。\n// 使用自行定義的建構子實體化物件 Swordman swordman = new Swordman(\u0026#34;離人劍\u0026#34;); class Swordman { ... // 建立攻擊方法  public string Attack() { return $\u0026#34;{name} 使出「基本攻擊」！\u0026#34;; } }p 當要實體化 swordman 物件時，必須帶入參數—離人劍，此時離人劍會存到類別的私有變數 name 裡，最後，在 Attack 方法內調用私有變數作為返回值。\n實際宣告且實體化 Swordman 類別，調用其 Attack 方法，觀察輸出結果\n多載（Overloading） 多載意即方法重載，多載為可同時建立同名的函數（Function），函數須使用不同的參數類型或不同個數。筆者不習慣用函數，因為會有點偏向於數學，筆者通常會稱函數為方法。\n假設不想取名就直接實體化物件，就必須再建立一個不帶參數的建構式，與原本的建構式共存，就是方法重載，如下\n// 建立 Swordman 類別 class Swordman { // 定義私有變數 name  private string name; // 定義空的建構式  public Swordman() { // 賦值給私有變數  this.name = \u0026#34;無名氏\u0026#34;; } // 建立帶有參數 name 的建構子  public Swordman(string name) { // 將參數 name 指給私有變數 name  this.name = name; } ... } 以上述的例子來說，該類別同時擁有兩個同名稱的建構子 Swordman，一個是沒有帶參數，一個帶有 string 參數，他們是可以同時存在的，因為符合參數個數不同的特性。方法重載通常可以用於，在不改變原有方法的基礎上，以達擴展功能目的。當然不只建構子可以方法重載，一般建立的方法也可以使用多載。\n實際演練\n// 宣告物件並實體化物件 Swordman swordman1 = new Swordman(); Swordman swordman2 = new Swordman(\u0026#34;離人劍\u0026#34;); // 調用 Attack 公開方法 Console.WriteLine(swordman1.Attack()); Console.WriteLine(swordman2.Attack()); 觀察輸出結果\n欄位（Field） 欄位用來儲存類別要滿足設計所需的資料，簡化為儲存資料的意思，通常為私有的類別變數，只能供類別內部使用的變數，一般命名規則通常開頭字母為小寫。比方 Swordman 類別裡定義的私有變數 name 即為欄位，僅供內部使用，而外部無法調用，必須給予 private修飾詞。例如先前定義的私有變數 name。\n// 建立 Swordman 類別 class Swordman { // 定義私有變數 name  private string name; ... } 屬性（Property） 屬性為類別的一個欄位（看起來有點詭異），通常是給外部調用，所以外部可以存取屬性，屬性的命名規則通常開頭字母為大寫，下面範例看起來與欄位區別不大，不過隨著後面的介紹與使用，欄位與屬性的定義會越來越清晰。\n// 建立 Swordman 類別 class Swordman { // 定義公開屬性供外部存取  public int Count; ... } 修飾詞（Modifiers） 屬性有兩個方法 get和set，get 存取器（或存取子）返回與宣告屬性相同的資料類型，即調用時可取得內部欄位的值或參考；set 存取器調用屬性時，可以給內部的欄位或參考賦值，其中有個隱式參數為 value，即從外部進來的值。\n先看公開屬性加上 get 與 set 存取子的「自動實作屬性」作法\n// 建立 Swordman 類別 class Swordman { // 定義公開屬性供外部存取，使用自動實作屬性  public int Count { get; set; } ... } 使用 get 與 set 來存取欄位，隱藏實際要做的事情，達到「資料封裝」的效果\n// 定義私有欄位 private int count; // 定義公開屬性供外部存取 public int Count { get { // 回傳私有欄位 count 的值  return count; } set { // 將 value 的值賦予給私有欄位 count  count = value; } } 上述兩種方法 Compiler 後是完全一樣，Property { get; set; } 是 C# 3.0 更新版中添加的自動實作屬性語法，自動實作屬性經過 Compiler 會自動產生 Private Field，而官方也清楚說明，屬性存取中若沒有額外的邏輯，自動實作屬性會讓宣告更精簡。\n In C# 3.0 and later, auto-implemented properties make property-declaration more concise when no additional logic is required in the property accessors.\n 另外補充 C# 6.0 更新版中增加了初始化自動實作屬性功能\n// 初始化自動實作屬性 public int Count { get; set; } = 10; 屬性只想做唯讀或是唯寫，不加修飾詞即可，比如\n// 只能讀取 public int Count { // 只有 get 存取子  get { return count; } } // 只能寫入 public int Count { // 只有 set 存取子  set { count = value; } } 或者將公開存取宣告為私有\n// 定義公開屬性供外部存取 public int Count { get { return count; } // 宣告為私有僅供內部調用，對外部而言也是唯讀  private set { count = value; } } 所以當 set 修飾詞宣告為私有時，外界要使用時會引發無法存取 set 存取子之錯誤\n認識了這麼多名詞，最後把上面提到的欄位、屬性和修飾詞實際演練。\n先建立 Swordman 類別\n/// \u0026lt;summary\u0026gt; /// Swordman 類別 /// \u0026lt;/summary\u0026gt; class Swordman { // 名稱私有屬性  private string name; // 攻擊次數私有欄位  private int num = 1; /// \u0026lt;summary\u0026gt;  /// 攻擊次數公開屬性  /// \u0026lt;/summary\u0026gt;  public int Num { get { return num; } set { // 給予限制  if (value \u0026gt;= 10) num = 10; else num = value; } } /// \u0026lt;summary\u0026gt;  /// 公告次數公開屬性，初始化為 3  /// \u0026lt;/summary\u0026gt;  public int Count { get; set; } = 3; /// \u0026lt;summary\u0026gt;  /// 空建構式  /// \u0026lt;/summary\u0026gt;  public Swordman() { this.name = \u0026#34;GM大大\u0026#34;; } /// \u0026lt;summary\u0026gt;  /// 帶有 string 參數的建構式  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public Swordman(string name) { this.name = name; } /// \u0026lt;summary\u0026gt;  /// 公開攻擊方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Attack() { string result = string.Empty; for (int i = 0; i \u0026lt; num; i++) { result += name + \u0026#34;使出\u0026#34; + \u0026#34;「基本攻擊」\\n\u0026#34;; } return result; } /// \u0026lt;summary\u0026gt;  /// 公開公告方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public string Announcement() { string result = string.Empty; for (int i = 0; i \u0026lt; Count; i++) { result += \u0026#34;「明天早上10點進行更新」\\n\u0026#34;; } return name + \u0026#34;說：\\n\u0026#34; + result + \u0026#34;很重要所以說三遍！\u0026#34;; } } 在 Main 方法中，宣告且實體化類別物件，接著調用公開方法，以及設置公開屬性\nstatic void Main(string[] args) { // 宣告名為離人劍的 swordman 物件並實體化  Swordman swordman = new Swordman(\u0026#34;離人劍\u0026#34;); // 調用攻擊方法  string attack = swordman.Attack(); Console.WriteLine(attack); // 宣告不帶參數的 gm 物件並實體化  Swordman gm = new Swordman(); // 調用公告方法  string announcement = gm.Announcement(); Console.WriteLine(announcement); // 變更攻擊次數，指派屬性 Num 的值，新的值會調用 set 訪問器  swordman.Num = 5; Console.WriteLine(\u0026#34;\\n變更攻擊次數為 5 次，開始攻擊！\\n\u0026#34;); Console.WriteLine(swordman.Attack()); swordman.Num = 11; Console.WriteLine(\u0026#34;\\n變更攻擊次數為 11 次，開始攻擊！\\n\u0026#34;); Console.WriteLine(swordman.Attack()); Console.WriteLine(\u0026#34;\\n因受到限制，實際上只攻擊了 10 次！\\n\u0026#34;); Console.ReadLine(); } 觀察輸出結果\nNote 類別是用來定義物件的模板（或是藍圖），由「方法成員」和「資料成員」組成，具體化後成為物件（實體）；屬性和欄位歸類為資料成員，方法（函數）視為方法成員，物件具有封裝特性，達到隱藏或保護資料的目的，除非方法或屬性提供外界可存取資料成員或方法成員的權限。\nReference 【大話設計模式】\nAuto-Implemented Properties\n","permalink":"https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/","summary":"Start 物件導向（Object-Oriented Programming），意為針對物件進行程式設計。而學習設計模式前必須先了解物件導向設計，不然難以體會設計模式的魅力。\n接下來我們會知道\n 類別（Class） 物件（Object） 實體（Instance） 建構式（Constructor） 多載（Overloading） 欄位（Field） 屬性（Property） 修飾詞（Modifiers）  類別（Class） 類別是具有相同「屬性（Attribute）」和 「功能（Method）」的物件之抽象集合。在 C# 中定義類別的關鍵字為 class，類別命名規則為第一個字母為大寫，多個單字命名時各個首字母為大寫。\n// 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法使外部可以呼叫，修飾詞用 public  public string Attack() { return \u0026#34;基本攻擊！\u0026#34;; } } 物件（Object） 物件是一個獨立的實體，實體裡包含許多資料，資料彼此之間不會互相影響，每個皆為獨立的資料。物件與類別的關係，最簡單易懂又不抽象的解釋為—物件是類別的實體。\n// 宣告一個Swordman 物件，物件名為 swordman Swordman swordman; // 先前建立的 Swordman 類別 class Swordman { ... }  在程式碼的世界裡，萬物皆為物件。\n 實體（Instance） 實體就是一個真實的物件。實體化是建立物件的過程，使用 new 關鍵字建立。\n// 實體化 swordman 物件 swordman = new Swordman(); 綜合上述介紹的類別、物件和實體，實際演練一次程式碼並觀察結果。 在 Swordman 有一個公開的 Attack 方法，當物件被實體化後，未來就能一直呼叫該方法","title":"【OOP】物件導向基礎概念（Object Oriented Programming）"},{"content":"【5/2 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  謝耳排序法（Shell Sort） 在插入排序法中，若大部分資料已經排序完成，該排序法會相當有效率，而謝耳排序法可以看作是一種使插入排序法減少資料搬移次數的衍伸排序法。\n其原理為將資料區分成特定間隔的區塊，以插入排序法對區塊內資料進行排序，再漸漸減少間隔的距離。\n舉例，有一陣列為 [50] [60] [10] [30] [20] [80] [40] [70]，以劃分數為 2，將資料分成四等份 (8/2)，得到下列區塊組合 (50,20)(60,80)(10,40)(30,70)，規則為第一個數與第五個數為一組，第二個數與第六個數為一組，以此類推。\n接著透過插入排序法，對區塊內的資料做排序，使其成為 (20,50)(60,80)(10,40)(30,70)，排序完後，解散區塊組合，還原成原數列 [20] [60] [10] [30] [50] [80] [40] [70]\n繼續縮小間隔為 (8/2)/2，得到下列區塊組合 (20,10,50,40)(60,30,80,70)，其規則為第一、三、五、七個數字為一組，二、四、六、八為一組，一樣以插入排序法對區塊內資料做排序，得結果為 (10,20,40,50)(30,60,70,80)，解散組合區塊，還原成原數列 [10] [30] [20] [60] [40] [70] [50] [80]\n進行第三次排序，縮小間隔為 ((8/2)/2)/2，如此一來變成對每一個元素進行排序，直接使用插入排序法得結果為 [10] [20] [30] [40] [50] [60] [70] [80]\n演算法分析  與插入演算法相同，是一種穩定排序法 只需要一個額外空間，空間複雜度為最佳，與氣泡、選擇、插入排序法相同 適用於大部份資料已經排序的情況 任何情況下，時間複雜度皆為 O(n3/2)   O(n3/2) - n3/2 代表 n 的3/2次方，因為頁面沒辦法顯示上標，將就一下\n 實際撰寫程式碼 根據初始序列 [50] [60] [10] [30] [20] [80] [40] [70]，並使用 console 主控台來進行代碼撰寫，目標為由小到大排序\n// 初始資料 int[] data = { 50, 60, 10, 30, 20, 80, 40, 70 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); int tmp; // 暫存資料  // 第一次排序 // 將資料分成四組 for (int i = 4; i \u0026lt; 8; i++) { // 遍歷所有元素  for (int j = i - 4; j \u0026gt;= 0; j -= 4) { if (data[j] \u0026gt; data[j + 4]) { tmp = data[j]; data[j] = data[j + 4]; data[j + 4] = tmp; } } } Console.Write(\u0026#34;第一次排序：　\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); // 第二次排序 // 將資料分成兩組 for (int i = 2; i \u0026lt; 8; i++) { for (int j = i - 2; j \u0026gt;= 0; j -= 2) { if (data[j] \u0026gt; data[j + 2]) { tmp = data[j]; data[j] = data[j + 2]; data[j + 2] = tmp; } } } Console.Write(\u0026#34;第二次排序：　\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); // 第三次排序 // 將資料分成八組，等同於直接使用插入排序法 for (int i = 1; i \u0026lt; data.Length; i++) { for (int j = i - 1; j \u0026gt;= 0; j -= 1) { if (data[j] \u0026gt; data[j + 1]) { tmp = data[j]; data[j] = data[j + 1]; data[j + 1] = tmp; } } } Console.Write(\u0026#34;第三次排序：　\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.ReadLine(); 上述演示每次排序邏輯，下列透過封裝並整理出其中規則，重新解析\n/// \u0026lt;summary\u0026gt; /// 封裝謝耳排序法 /// \u0026lt;/summary\u0026gt; private static void ShellSort() { // 初始資料  int[] data = { 50, 60, 10, 30, 20, 80, 40, 70 }; int tmp; int count = 0; for (int gap = data.Length / 2; gap \u0026gt; 0; gap /= 2) { for (int i = gap; i \u0026lt; data.Length; i++) { for (int j = i - gap; j \u0026gt;= 0; j -= gap) { // 插入排序法  if (data[j] \u0026gt; data[j + gap]) { tmp = data[j]; data[j] = data[j + gap]; data[j + gap] = tmp; } } } } Console.WriteLine(); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } } 本書的程式碼演練\n// 初始資料 int[] data = { 50, 60, 10, 30, 20, 80, 40, 70 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); int i; // 掃描次數 int j; // 以 j 來定位比較的元素 int k = 1; // 列印計數 int tmp; // 暫存資料 int jmp; // 設定間距位移量 jmp = data.Length / 2; while (jmp \u0026gt; 0) { for (i = jmp; i \u0026lt; data.Length; i++) { tmp = data[i]; j = i - jmp; while (j \u0026gt;= 0 \u0026amp;\u0026amp; tmp \u0026lt; data[j]) { // 插入排序法  data[j + jmp] = data[j]; j = j - jmp; } data[jmp + j] = tmp; } Console.WriteLine($\u0026#34;第{(k++)}次排序：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); jmp = jmp / 2; } Note 在思考如何撰寫程式碼過程中，還需要增強抽象能力，雖然對插入排序法已經很熟練，但在計算分組區塊這部分，對於筆者來說還有加強空間。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-13-shellsort/","summary":"【5/2 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  謝耳排序法（Shell Sort） 在插入排序法中，若大部分資料已經排序完成，該排序法會相當有效率，而謝耳排序法可以看作是一種使插入排序法減少資料搬移次數的衍伸排序法。\n其原理為將資料區分成特定間隔的區塊，以插入排序法對區塊內資料進行排序，再漸漸減少間隔的距離。\n舉例，有一陣列為 [50] [60] [10] [30] [20] [80] [40] [70]，以劃分數為 2，將資料分成四等份 (8/2)，得到下列區塊組合 (50,20)(60,80)(10,40)(30,70)，規則為第一個數與第五個數為一組，第二個數與第六個數為一組，以此類推。\n接著透過插入排序法，對區塊內的資料做排序，使其成為 (20,50)(60,80)(10,40)(30,70)，排序完後，解散區塊組合，還原成原數列 [20] [60] [10] [30] [50] [80] [40] [70]\n繼續縮小間隔為 (8/2)/2，得到下列區塊組合 (20,10,50,40)(60,30,80,70)，其規則為第一、三、五、七個數字為一組，二、四、六、八為一組，一樣以插入排序法對區塊內資料做排序，得結果為 (10,20,40,50)(30,60,70,80)，解散組合區塊，還原成原數列 [10] [30] [20] [60] [40] [70] [50] [80]\n進行第三次排序，縮小間隔為 ((8/2)/2)/2，如此一來變成對每一個元素進行排序，直接使用插入排序法得結果為 [10] [20] [30] [40] [50] [60] [70] [80]","title":"【Algorithm】排序演算法—謝耳排序法（Shell Sort）"},{"content":"最近在 LeetCode 刷題時，發現一個我不知道的東西—不規則陣列（Jagged Array）\n從古自今，筆者對於陣列的認知不外乎就是一維與多維陣列，然而在工作上也從未遇過不規則陣列的使用，導致近日在刷題時，曾一度懷疑自己的眼睛，這是不是打錯了？井底之蛙的我馬上跪拜古哥，結果在 C# 程式設計手冊發現了它的蹤影，廢話不多說，馬上來看！\n不規則陣列（Jagged Array）是陣列的一種，其陣列內的元素也是陣列，不規則陣列的元素可以具有不同維度及大小，也是與多維陣列明顯的差異之處。\n不規則陣列的宣告及初始化\n// 不規則陣列的宣告方式 int[][] array = new int[5][]; // 初始化元素 array[0] = new int[6]; array[1] = new int[5]; array[2] = new int[4]; array[3] = new int[3]; // 使用 Initializer 直接填入陣列元素的值，無須設置大小 array[0] = new int[]{ 1, 2, 3 }; array[1] = new int[]{ 4, 6 }; array[2] = new int[]{ 7 }; 從上述可知，多維陣列在同一維度下的元素大小必須相同，而不規則陣列的元素大小可以不同，不規則陣列內的元素是陣列，又稱為陣列中的陣列。\n我們也可以在宣告時直接初始化元素\n// 宣告時直接初始化 int[][] array = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; // 或是不使用 new 運算子的縮寫格式 int[][] array = { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; 其指派值的方式與多維陣列相同\n// 指派值 100 到第 [0] 個陣列的第 [1] 個元素 array[0][1] = 100; // 指派值 100 到第 [1] 個陣列的第 [2] 個元素 array[1][2] = 200; 以上介紹的是一維不規則陣列，其中皆包含一維陣列的元素。不規則陣列還可以使用混合的不規則陣列，比如說，宣告及初始化一維不規則陣列，其中包含三個大小不同的二維陣列元素。\n// 宣告及初始化 int[][,] array = new int[3][,] { new int[,]{ {1,2}, {3,4}}, new int[,]{ {5,6}, {7,8}, {9,10}}, new int[,]{ {11,12}, {13,14}, {15,18}, {100,220}} }; // 存取值的方式 Console.WriteLine(array[0][1,0]); array[0][1,0] = 4; Console.WriteLine(array[0][1,0]); 以筆者目前的工作性質來說，較不容易使用到不規則陣列，若以遊戲方面來說，我想物品欄應可透過這種方式來存取。\n了解多維陣列與不規則陣列的差別後，還有一點很重要，多維陣列在分配空間上，所有元素的長度是固定大小，而不規則陣列的元素長度可以依需求分配，故不規則陣列對於空間利用優於多維陣列。\n實際以儲存 1-5 的數字來看，二維陣列對子元素的空間分配必須是相同長度，故在存放 5 後的空間位置須補上 0，此處就是一個未被利用的空間；不規則陣列對子元素的空間分配較彈性，可以完全依照需求長度進行配置，才不會造成空間浪費\n// 二維陣列 int[,] arr1 = new int[,] { { 1, 2, 3 }, { 4, 5, 0 } }; // 不規則陣列 int[][] arr2 = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 5 } }; 使用迭代讀出所有元素方法\n// 不規則陣列 int[][] arr = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 5 } }; foreach(int[] item in arr) { foreach(int i in item) { Console.WriteLine(i); } } 也可以使用 SelectMany() 讀取\nvar item = arr.SelectMany(s =\u0026gt; s); foreach (var i in item) { Console.WriteLine(i); } ","permalink":"https://fakestandard.github.io/post/csharp/csharp-1-jaggedarray/","summary":"最近在 LeetCode 刷題時，發現一個我不知道的東西—不規則陣列（Jagged Array）\n從古自今，筆者對於陣列的認知不外乎就是一維與多維陣列，然而在工作上也從未遇過不規則陣列的使用，導致近日在刷題時，曾一度懷疑自己的眼睛，這是不是打錯了？井底之蛙的我馬上跪拜古哥，結果在 C# 程式設計手冊發現了它的蹤影，廢話不多說，馬上來看！\n不規則陣列（Jagged Array）是陣列的一種，其陣列內的元素也是陣列，不規則陣列的元素可以具有不同維度及大小，也是與多維陣列明顯的差異之處。\n不規則陣列的宣告及初始化\n// 不規則陣列的宣告方式 int[][] array = new int[5][]; // 初始化元素 array[0] = new int[6]; array[1] = new int[5]; array[2] = new int[4]; array[3] = new int[3]; // 使用 Initializer 直接填入陣列元素的值，無須設置大小 array[0] = new int[]{ 1, 2, 3 }; array[1] = new int[]{ 4, 6 }; array[2] = new int[]{ 7 }; 從上述可知，多維陣列在同一維度下的元素大小必須相同，而不規則陣列的元素大小可以不同，不規則陣列內的元素是陣列，又稱為陣列中的陣列。\n我們也可以在宣告時直接初始化元素\n// 宣告時直接初始化 int[][] array = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; // 或是不使用 new 運算子的縮寫格式 int[][] array = { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; 其指派值的方式與多維陣列相同","title":"【C#】不規則陣列（Jagged Array）"},{"content":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  插入排序法（Insert Sort） 插入排序法原理是將陣列中的元素，逐一與已經排序好的資料作比較，例如前兩個元素已經排序好，再將第三個元素與這兩個元素作比較，插入到適當的位置，接著將第四個元素，與前三個已排序好的元素進行比較，再插入到適當位置，重複此步驟，直到排序完成為止。\n透過插入排序法，一樣對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列\nStep 1 首先第一個元素 [30] 定義為已排序，取得第二個元素 [20]，與第一個元素進行比較，插入到適當位置\n初始已排序序列 [30]\n插入後結果序列 [20] [30]\nStep 2 取得第三個元素 [40]，與上次結果進行比對，並插入適當位置\n初始已排序序列 [20] [30]\n插入後結果序列 [20] [30] [40]\nStep 3 取得第四個元素 [50]，與上次結果進行比對，並插入適當位置\n初始已排序序列 [20] [30] [40]\n插入後結果序列 [20] [30] [40] [50]\nStep 4 取得最後一個元素 [10]，與上次結果進行比對，並插入適當位置，如此一來即完成排序。\n初始已排序序列 [20] [30] [40] [50]\n插入後結果序列 [10] [20] [30] [40] [50]\n演算法分析  插入排序法是一種穩定排序法 只需要一個額外空間，空間複雜度為最佳，與前氣泡排序法和選擇排序法相同 適合大部分資料已排序，或是在已排序的資料庫中，新增一筆資料後進行排序 此排序法會造成資料大量搬移，建議在鏈結串列上使用 最好的情況下，時間複雜度為 O(n) 最壞和最佳情況，需比較次數為 (n-1)+(n-2)+(n-3)+\u0026hellip;+3+2+1=n(n-1)/2，故時間複雜度為 O(n2)   O(n2) - n2 代表 n 的平方，因為頁面沒辦法顯示上標，將就一下\n 實際撰寫程式碼 根據初始序列 [30] [20] [40] [50] [10] ，並使用 console 主控台來進行代碼撰寫，目標為由小到大排序\n// 初始序列 int[] data = { 30, 20, 40, 50, 10 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); int i; // 掃描次數 int j; // 定位比較的元素 int tmp; // 用以暫存資料  for (i = 1; i \u0026lt; data.Length; i++) { // 將要插入的元素放置暫存變數  tmp = data[i]; // 已排序資料的最末端  j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; tmp \u0026lt; data[j]) { // 把所有元素往後推一格  data[j + 1] = data[j]; j--; } data[j + 1] = tmp; // 打印每次掃描結果  Console.Write($\u0026#34;第{i}次掃描排序結果：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); } // 排序後的結果 Console.WriteLine(); Console.Write(\u0026#34;排序後的序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.ReadLine(); Note 在了解插入排序法的代碼時，必須找到適當的位置插入元素，而如何記錄位置，筆者思考許久，前兩種排序簡單又非常好理解，走到這裡卻有點卡關，看來筆者某部分的大腦表現不是很活躍，需要多多從這些地方下手，讓腦細胞活起來。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-12-insertsort/","summary":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  插入排序法（Insert Sort） 插入排序法原理是將陣列中的元素，逐一與已經排序好的資料作比較，例如前兩個元素已經排序好，再將第三個元素與這兩個元素作比較，插入到適當的位置，接著將第四個元素，與前三個已排序好的元素進行比較，再插入到適當位置，重複此步驟，直到排序完成為止。\n透過插入排序法，一樣對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列\nStep 1 首先第一個元素 [30] 定義為已排序，取得第二個元素 [20]，與第一個元素進行比較，插入到適當位置\n初始已排序序列 [30]\n插入後結果序列 [20] [30]\nStep 2 取得第三個元素 [40]，與上次結果進行比對，並插入適當位置\n初始已排序序列 [20] [30]\n插入後結果序列 [20] [30] [40]\nStep 3 取得第四個元素 [50]，與上次結果進行比對，並插入適當位置\n初始已排序序列 [20] [30] [40]\n插入後結果序列 [20] [30] [40] [50]","title":"【Algorithm】排序演算法—插入排序法（Insert Sort）"},{"content":"【ASP.NET Core 5】\n靜態檔案是 HTML、css、image、js 等資源檔案，過去 .NET Framework 可直接被存取，在 ASP.NET Core 中，已不能直接被瀏覽，對於存取有特定的限制。\nStart 首先，先了解 Content root 以及 Web root，硬翻成中文為內容根目錄 \u0026amp; Web 根目錄。\nContent root（內容根目錄） Content root 預設為專案的根目錄，包含\n 裝載應用程式的可執行檔 .exe 組成應用程式的已編譯元件 .dll 應用程式所使用的內容檔案  Razor(.cshtml、.razor) 設定檔(.json、.xml) 資料檔案(.db)   Web 根目錄(Web root)  Web root（Web 根目錄） Web root 為公共靜態資源的基本路徑，預設路徑為 {content root}/wwwroot\n 樣式 .css JavaScript .js 影像檔 .png、.jpg  建立一個專案，在方案總管中找到 wwwroot，可看到預設已建立 css、js、lib 資料夾，使用路徑 https://localhost:5000/css/site.css 嘗試讀取 ~/css/site.css 該檔案， 可直接瀏覽檔案內容。\n測試自行建立的資料夾是否能存取，在 wwwroot 目錄下建立 images 資料夾以自定義靜態檔案路徑，並放置一張影像檔在該目錄下，嘗試使用 URL https://localhost:5000/images/MyImages.jpg 來讀取該檔案，應能正常瀏覽。\n指定 Web root 靜態檔案預設儲存於專案的 Web root 下，預設路徑為 {content root}/wwwroot，我們可以使用 UseWebRoot 方法，來變更預設的存放路徑。\n開啟 Program.cs，CreateDefaultBuilder 方法可將 content root 設為目前的目錄。使用 UseWebRoot 方法將 Web root 變更為 public，隨後在 public 放置一張影像檔，實際測試 URL https://localhost:5000/public/MyImages.jpg，結果在未設定前無法讀取 wwwroot 以外的目錄，設定後就能讀取指定目錄。要注意的是，該動作的目標是變更，經變更後，wwwroot 該目錄會停用存取，取而代之的是 public。\n 若測試結果不相同，請嘗試清理瀏覽器快取。\n public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); // 設置  webBuilder.UseWebRoot(\u0026#34;public\u0026#34;); }); } 註冊 UseStaticFiles Middleware 專案在預設情況下，已經在 Startup.cs 註冊靜態檔案中介軟體，在 Configure 方法中可以找到 app.UseStaticFiles()，該段即為用來啟用靜態檔案中介軟體的服務，嘗試將此段註解，實際測試 URL https://localhost:5000/public/MyImages.jpg，得到的結果是無法存取預設的靜態檔案 wwwroot。\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { ... // 啟用靜態檔案  app.UseStaticFiles(); ... } 啟用 Web root 以外的目錄檔案 前面使用 UseWebRoot 來改變 Web root 靜態檔案的預設路徑，如果想要同時存取兩個以上的目錄位址，例如可以同時存取 wwwroot 及其它同階層目錄 files，階層如下\n wwwroot  css images js   files  MyImage.jpg    我們可以藉由設定靜態檔案中介軟體來存取檔案，先啟用存取 wwwroot 目錄之服務，再啟用存取其他目錄之服務。\n// 需要引用的命名空間 using System.IO; using Microsoft.Extensions.FileProviders; ... public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { ... // wwwroot  app.UseStaticFiles(); // Other  app.UseStaticFiles(new StaticFileOptions { // 檔案提供位址  FileProvider = new PhysicalFileProvider( Path.Combine(env.ContentRootPath, \u0026#34;files\u0026#34;)), // 靜態資源對應的 request path  RequestPath = \u0026#34;/staticFiles\u0026#34; }); ... } 通過上述設定，/staticFiles 區段公開了 files 目錄階層，實際測試 URL https://localhost:5000/staticFiles/MyImage.jpg，可正常瀏覽該目錄下的靜態檔案，達到 wwwroot 和 files 皆能瀏覽之效果。\n 若想停用 wwwroot 存取服務，將 app.UseStaticFiles() 註解調即可\n 預設檔案 預設頁面是提供訪客在進入網站時的第一個頁面，通常預設頁面會是 index.html，可以透過 UseDefaultFiles 方法來設定靜態檔案目錄的預設頁面，使用該方法時，會要求依序搜尋 wwwroot 資料夾內的檔案，順序如下\n default.htm default.html index.htm index.html  值得注意，必須在 UseStaticFiles 之前使用 UseDefaultFiles，若後啟用 UseDefaultFiles 服務的話，當 URL 為 / 時，UseStaticFiles 找不到檔案，就會直接回傳找不到，就不會有機會進入 UseStaticFiles。\n兩者的職責\n UseDefaultFiles 是嘗試請求預設檔案 UseStaticFiles 是回傳請求檔案  // 先啟用 app.UseDefaultFiles(); // 後啟用 app.UseStaticFiles(); 除了上述預設頁面，還可以自訂預設頁面，使用 DefaultFilesOptions 物件來自定義預設頁面，代碼如下\nvar options = new DefaultFilesOptions(); // 清空原本預設頁面 options.DefaultFileNames.Clear(); // 添加自定義預設頁面 options.DefaultFileNames.Add(\u0026#34;myDefault.html\u0026#34;); // 啟用自定義預設頁面 app.UseDefaultFiles(options); app.UseStaticFiles(); 使用自訂預設頁面時，如同預設頁面，會依序搜尋 wwwroot 資料夾內的檔案。實際測試在 wwwroot 新增 myDefault.html，將專案 run 起來，發現 https://localhost:5000/ 瀏覽頁面已經被更換為 myDefault.html，不再是預設的 ~/Home/Index。\n如果是想添加自訂的預設頁面，但不想將原先定義的四個預設頁面清除，在上述代碼中將 options.DefaultFileNames.Clear() 拿掉即可。\n瀏覽目錄 瀏覽目錄允許在指定的路徑中列出目錄，基於安全性的考量，預設會停用瀏覽目錄，但可以透過 AddDirectoryBrowser 及 UseDirectoryBrowser 來註冊及啟用該服務。\npublic void ConfigureServices(IServiceCollection services) { // 註冊瀏覽目錄服務  services.AddDirectoryBrowser(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { ... // 啟用瀏覽目錄服務  app.UseDirectoryBrowser(); ... } 在空建構子的情況下，預設啟用的目錄為 wwwroot，例如跳轉到 https://localhost:5000/lib/，會列出 /wwwroot/lib 目錄下的所有檔案。\n若欲啟用瀏覽指定路徑的目錄，要先使用靜態檔案中介軟體來啟用存取檔案服務，接著再啟用瀏覽目錄服務。\npublic void ConfigureServices(IServiceCollection services) { // 註冊瀏覽目錄服務  services.AddDirectoryBrowser(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // 啟用指定目錄存取  app.UseStaticFiles(new StaticFileOptions { FileProvider = new PhysicalFileProvider( Path.Combine(env.ContentRootPath, \u0026#34;files\u0026#34;)), RequestPath = \u0026#34;/staticFiles\u0026#34; }); // 啟用瀏覽指定目錄服務  app.UseDirectoryBrowser(new DirectoryBrowserOptions { FileProvider = new PhysicalFileProvider( Path.Combine(env.WebRootPath, \u0026#34;files\u0026#34;)), RequestPath = \u0026#34;/staticFiles\u0026#34; }); } UseFileServer 先前介紹停用檔案存取的限制，以及開啟瀏覽目錄，UseFileServer 方法結合了 UseStaticFiles、UseDefaultFiles，也可以選擇性的結合 UseDirectoryBrowser。\n直接使用 UseFileServer 來啟用檔案服務，等同於使用 UseDefaultFiles 和 UseStaticFiles。\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // 啟用檔案服務  app.UseFileServer(); // 等於同時使用下列兩種方法  // app.UseDefaultFiles();  // app.UseStaticFiles(); } 帶入參數 enableDirectoryBrowsin: true 來啟用瀏覽目錄、啟用存取靜態檔案以及預設檔案，預設頁面會更換為列出 wwwroot 目錄\napp.UseFileServer(enableDirectoryBrowsing: true); 上面目標是 wwwroot 目錄，欲指定其他目錄，代碼如下\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.UseFileServer(new FileServerOptions { FileProvider = new PhysicalFileProvider( Path.Combine(env.ContentRootPath, \u0026#34;files\u0026#34;)), RequestPath = \u0026#34;/staticFiles\u0026#34;, EnableDirectoryBrowsing = true }); } 官方寫說若 EnabledDirectoryBrowsing 的 value 為 true 時，需要調用 AddDirectoryBrowser()，在這裡筆者沒有註冊該服務依然可以啟用目錄，若無法瀏覽目錄的朋友，可以試著在 ConfigureServices 註冊該服務，看是否有效果。\npublic void ConfigureServices(IServiceCollection services) { // 註冊瀏覽目錄服務  services.AddDirectoryBrowser(); } Note 過去網站在存取靜態檔案並沒有什麼限制，只要知道目錄結構，就能存取檔案，如今 .NET Core 對此做出變革，雖然需要花點時間了解，網站安全性也相對的提升，了解如何操作靜態檔案後，就可好好建構出乾淨清晰的目錄架構了！\nReference Static files in ASP.NET Core\n","permalink":"https://fakestandard.github.io/netcore/netcore5-4-staticfiles/","summary":"【ASP.NET Core 5】\n靜態檔案是 HTML、css、image、js 等資源檔案，過去 .NET Framework 可直接被存取，在 ASP.NET Core 中，已不能直接被瀏覽，對於存取有特定的限制。\nStart 首先，先了解 Content root 以及 Web root，硬翻成中文為內容根目錄 \u0026amp; Web 根目錄。\nContent root（內容根目錄） Content root 預設為專案的根目錄，包含\n 裝載應用程式的可執行檔 .exe 組成應用程式的已編譯元件 .dll 應用程式所使用的內容檔案  Razor(.cshtml、.razor) 設定檔(.json、.xml) 資料檔案(.db)   Web 根目錄(Web root)  Web root（Web 根目錄） Web root 為公共靜態資源的基本路徑，預設路徑為 {content root}/wwwroot\n 樣式 .css JavaScript .js 影像檔 .png、.jpg  建立一個專案，在方案總管中找到 wwwroot，可看到預設已建立 css、js、lib 資料夾，使用路徑 https://localhost:5000/css/site.css 嘗試讀取 ~/css/site.css 該檔案， 可直接瀏覽檔案內容。\n測試自行建立的資料夾是否能存取，在 wwwroot 目錄下建立 images 資料夾以自定義靜態檔案路徑，並放置一張影像檔在該目錄下，嘗試使用 URL https://localhost:5000/images/MyImages.","title":"【.NET Core】靜態檔案 Static Files"},{"content":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  選擇排序法（Selection Sort） 選擇排序法顧名思義是以選擇的概念來進行排序，也算是枚舉法的應用，原理為反覆從未排序的數列中取出最小元素，加入到另一個數列中，達到排序的結果。\n選擇排序可以由大到小排序，將最大值放到第一位置；或是由小到大排序，將最大值放到最後一個位置。\n透過選擇排序法，對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列\nStep 1 首先進行第一次掃描，找到數列中最小值，直接與第一個元素交換\n初始序列 [30] [20] [40] [50] [10]\n結果序列 [10] [20] [40] [50] [30]\nStep 2 進行第二次掃描，排除第一個元素，從第二個位置開始找起，找到最小值，與第二個位置元素交換，因為 [20] 是此次搜尋中最小值，其結果位置不變\n上次結果 [10] [20] [40] [50] [30]\n結果序列 [10] [20] [40] [50] [30]\nStep 3 第三次掃描，排除第一與第二個元素，從第三個位置找起，找到最小值，與第三個位置元素交換\n上次結果 [10] [20] [40] [50] [30]\n結果序列 [10] [20] [30] [50] [40]\nStep 4 第四次掃描，排除前三個元素，從剩餘元素中找到最小值，與第四個位置元素進行交換，此次即完成排序\n上次結果 [10] [20] [30] [50] [40]\n結果序列 [10] [20] [30] [40] [50]\n演算法分析  該排序是以最小值或最大值與最前方未排序的值進行交換，資料排序的順序可能被改變，故唯一種不穩定排序法 適合資料量較小，或有部分資料已經排序過，與氣泡排序法相同 只需一個額外空間，空間複雜度較佳，與氣泡排序法相同 無論是最佳、最壞或是平均情況，都須找到最小值或最大值，比較次數為 (n-1)+(n-2)+(n-3)+…+3+2+1=n(n-1)/2，故時間複雜度為 O(n2)   O(n2) - n2 代表 n 的平方，因為頁面沒辦法顯示上標，將就一下\n 實際撰寫程式碼 根據初始序列 [30] [20] [40] [50] [10] ，並使用 console 主控台來進行代碼撰寫，目標為由小到大排序\n// 初始序列 int[] data = { 30, 20, 40, 50, 10 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); int minIndex, tmp; // 掃描次數 for (int i = 0; i \u0026lt; data.Length; i++) { // 最小值預設為每次要搜尋數列裡的第一個元素  minIndex = i; // 找出搜尋數列中最小值  for (int j = i; j \u0026lt; data.Length; j++) { if (data[j] \u0026lt; data[minIndex]) { minIndex = j; } } // 將最小值與搜尋數列中的頭一個元素對調  tmp = data[i]; data[i] = data[minIndex]; data[minIndex] = tmp; // 打印每次掃描結果  Console.Write($\u0026#34;第{i + 1}次掃描排序結果：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); } Console.Read(); Note 實際撰寫程式碼實驗後，可以發現選擇排序法有一個缺陷，它與氣泡排序法不同之處在於不能為下一次排序提供有用資訊，氣泡排序法可提供一個 flag 來得知是否有被交換，進一步判斷需不需要進行下一次排序；選擇排序法則無法提供有利資訊給下次排序，它必須排序到最後一刻，方能得知最終排序結果。\n該書選擇排序法的程式碼，依然使用了氣泡排序法的程式碼，無法得到有用參考，筆者依據已知原理實際撰寫一個選擇排序法，若有謬誤請多包涵。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/","summary":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  選擇排序法（Selection Sort） 選擇排序法顧名思義是以選擇的概念來進行排序，也算是枚舉法的應用，原理為反覆從未排序的數列中取出最小元素，加入到另一個數列中，達到排序的結果。\n選擇排序可以由大到小排序，將最大值放到第一位置；或是由小到大排序，將最大值放到最後一個位置。\n透過選擇排序法，對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列\nStep 1 首先進行第一次掃描，找到數列中最小值，直接與第一個元素交換\n初始序列 [30] [20] [40] [50] [10]\n結果序列 [10] [20] [40] [50] [30]\nStep 2 進行第二次掃描，排除第一個元素，從第二個位置開始找起，找到最小值，與第二個位置元素交換，因為 [20] 是此次搜尋中最小值，其結果位置不變\n上次結果 [10] [20] [40] [50] [30]\n結果序列 [10] [20] [40] [50] [30]","title":"【Algorithm】排序演算法—選擇排序法（Selection Sort）"},{"content":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  氣泡排序法（Bubble Sort） 氣泡排序法可稱為交換排序法，其構思為觀察水中氣泡變化而成，甚至可稱為冒泡排序等類似名稱。\n其原理為從第一個元素開始，比較相鄰元素的大小，如大小順序有誤，就將其對調，再與下一個元素進行比較，彷彿氣泡逐漸冒出水面上的概念，使用該方法掃描過一次後，就可以確保最後一個元素是位於正確的位置，進行第二次掃描，就能確認第二個元素的正確位置，逐步進行直到所有元素排序完成。\n使用白話一點的說法，逐一拆解每一個步驟，首先有一個序列，初始的狀態和順序為 [30] [20] [40] [50] [10]，目標將此序列由小到大排列，變成 [10] [20] [30] [40] [50]\n我們透過氣泡排序法進行排序，步驟解析如下\nStep 1 首先進行第一次掃描，會先拿到第一個元素 [30]，接著與相鄰的元素 [20] 進行比較，如果第二個元素小於地一個元素，就進行位置交換。\n初始序列 [30] [20] [40] [50] [10]\n結果序列 [20] [30] [40] [50] [10]\nStep 2 依然拿著 [30] 這個元素，繼續與相鄰的元素比較，因為該元素已經調換到第二個元素的位置，所以下一個相鄰的元素會是 [40]，接著進行比較，經比較後兩個元素順序不變，依然維持下列結果\n結果序列 [20] [30] [40] [50] [10]\nStep 3 先前都是拿著 [30] 該元素進行比較，原因是，該元素原先位於第一個位置，經比較後換到第二個位置，而第二次進行比較時，要取得比較的元素是第二個位置的元素，才會又是 [30]，但上次進行比較時，兩元素並沒有調換位置，所以這次比較時，要取得的元素是第三個位置 [40]，就不是 [30] 這個元素囉！\n取得第三個元素 [40] 與相鄰元素 [50] 進行比較，兩者順序依然不變，維持下列結果\n結果序列 [20] [30] [40] [50] [10]\nStep 4 再來取得第四個位置元素 [50] 與相鄰元素 [10] 進行比較，經比較後兩者交換位置，結果如下\n結果序列 [20] [30] [40] [10] [50]\n到目前為止，第一次掃描即完成，可以發現最大的元素已經冒泡出來，經比較後，它已被換到屬於它的位置，確定該序列最大值再序列的最後方。\nStep 5 接著進行第二次掃描，從頭來過，取得第一個元素 [20] 與相鄰元素 [30] 進行比較\u0026hellip;\n每次掃描都是一樣的步驟，直到最後一次掃描時，沒有任何元素進行互換，即完成排序，就不一一解說。\n演算法分析  氣泡排序法是由相鄰兩者進行比較對調，不會改變原有排序的順序，是一種穩定排序法 此排序法適合資料量較小，或有部分資料已經排序過 只需一個額外空間，空間複雜度最佳 最好的情況只需進行一次掃描，沒有任何交換動作，即完成排序，所以只做了 n-1 次比較，時間複雜度為 O(n) 最壞的情況和平均情況需比較次數為 (n-1)+(n-2)+(n-3)+\u0026hellip;+3+2+1=n(n-1)/2，時間複雜度為O(n2)   O(n2) - n2 代表 n 的平方，因為頁面沒辦法顯示上標，將就一下\n 實際撰寫程式碼 根據初始序列 [30] [20] [40] [50] [10] ，並使用 console 主控台來進行代碼撰寫\nint i, j, tmp; // 初始序列 int[] data = { 30, 20, 40, 50, 10 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); // 掃描次數 for (i = data.Length - 1; i \u0026gt; 0; i--) { // 比較、交換的次數  for (j = 0; j \u0026lt; i; j++) { // 進行相鄰兩數比較  if (data[j] \u0026gt; data[j + 1]) { tmp = data[j]; data[j] = data[j + 1]; data[j + 1] = tmp; } } // 打印每次掃描結果  Console.Write($\u0026#34;第{data.Length - i}次掃描排序結果：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); } // 排序後的結果 Console.WriteLine(); Console.Write(\u0026#34;排序後的序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.Read(); 根據先前描述，最好的情況下可以掃描一次就完成排序，在上述代碼中無法達到這樣的效果，接著我們對程式碼進行改良，加入是否有交換過的判斷，提前中斷程式，進而減少掃描次數。\n改良前須知，初始序列已變更為 [10] [20] [40] [50] [30]，原先序列無法提前終止，故進行變更。\nint i, j, tmp, flag; // 初始序列 int[] data = { 10, 20, 40, 50, 30 }; Console.Write(\u0026#34;初始序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); Console.WriteLine(\u0026#34;進行掃描...\u0026#34;); Console.WriteLine(); // 掃描次數 for (i = data.Length - 1; i \u0026gt; 0; i--) { // 用以判斷是否有交換過的動作  flag = 0; // 比較、交換的次數  for (j = 0; j \u0026lt; i; j++) { // 進行相鄰兩數比較  if (data[j] \u0026gt; data[j + 1]) { tmp = data[j]; data[j] = data[j + 1]; data[j + 1] = tmp; // 有執行交換就+1  flag++; } } // 每次掃描完成判斷 flag 是否為 0，若為 0 則表示已完成排序  // 可提前終止程式  if (flag == 0) { break; } // 打印每次掃描結果  Console.Write($\u0026#34;第{data.Length - i}次掃描排序結果：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.WriteLine(); } // 排序後的結果 Console.WriteLine(); Console.Write(\u0026#34;排序後的序列：\u0026#34;); foreach (var item in data) { Console.Write(item + \u0026#34; \u0026#34;); } Console.Read(); Note 學習排序法的過程中，除了解各種排序的作法以及原理之外，透過程式碼也有助於邏輯思考，文字搭配程式碼，學習也變得很有趣！\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/","summary":"【4/29 閱讀紀錄】\n排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。\n經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。\n程式碼已放上 GitHub\nStart 常見的排序演算法\n 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  氣泡排序法（Bubble Sort） 氣泡排序法可稱為交換排序法，其構思為觀察水中氣泡變化而成，甚至可稱為冒泡排序等類似名稱。\n其原理為從第一個元素開始，比較相鄰元素的大小，如大小順序有誤，就將其對調，再與下一個元素進行比較，彷彿氣泡逐漸冒出水面上的概念，使用該方法掃描過一次後，就可以確保最後一個元素是位於正確的位置，進行第二次掃描，就能確認第二個元素的正確位置，逐步進行直到所有元素排序完成。\n使用白話一點的說法，逐一拆解每一個步驟，首先有一個序列，初始的狀態和順序為 [30] [20] [40] [50] [10]，目標將此序列由小到大排列，變成 [10] [20] [30] [40] [50]\n我們透過氣泡排序法進行排序，步驟解析如下\nStep 1 首先進行第一次掃描，會先拿到第一個元素 [30]，接著與相鄰的元素 [20] 進行比較，如果第二個元素小於地一個元素，就進行位置交換。\n初始序列 [30] [20] [40] [50] [10]\n結果序列 [20] [30] [40] [50] [10]\nStep 2 依然拿著 [30] 這個元素，繼續與相鄰的元素比較，因為該元素已經調換到第二個元素的位置，所以下一個相鄰的元素會是 [40]，接著進行比較，經比較後兩個元素順序不變，依然維持下列結果\n結果序列 [20] [30] [40] [50] [10]","title":"【Algorithm】排序演算法—氣泡排序法（Bubble Sort）"},{"content":"【ASP.NET Core 5】\nASP.NET Core 引入一個新概念稱為中介軟體（Middleware），Middleware 會在 ASP.NET Core 應用程式中的每個請求上執行。\n過去 ASP.NET 中 HttpHandlers 和 HttpModules 在 ASP.NET Core 已不復存在，更準確地說，它們已成為 Request Pipeline 的一部分，Middleware 類似於 HttpHandlers、HttpModules，都需要在每個請求中進行配置及執行。\nStart Middleware 是組成應用程式 Pipeline 的軟體，每個組件可以選擇是否將請求傳遞到管線中的下一個組件，也可以在下一個組件中的前後執行工作。\n通常 ASP.NET Core Web 應用程式中有許多 Middleware，它可以是 Framework provided 的中介軟體，也可以通過 NuGet 添加，甚至可以自行定義 Middleware。我們可以在請求管道中設置中介軟體的執行順序，每個中介軟體都會新增或修改 Http 請求，且可選擇將控制權傳遞給下一個中介軟體。\n請求委派用於建構請求管道，請求委派會處理每個 Http 請求。該句的原文是這樣\n Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.\n Request delegates 使用 Run、Map 和 Use 三種擴充方法來配置。單個請求委派可以指定嵌入式（in-line）匿名方法，稱為嵌入式中介軟體，也可以在重複使用的類別中進行定義。這些可重用的類別和嵌入式匿名方法就是 middleware ，也稱之為 middleware components。在請求管道中的每個中介軟體元件負責調用 Pipeline 中的下一個元件，或對管線執行最少運算，當中介軟體短路時（short-circult），會阻止接下來的中介軟體處理請求，稱之為終端中介軟體 terminal middleware。\n最簡單的 ASP.NET Core 應用程式可以設置一個處理所有請求的請求委派，該情況不包括實際的請求管道，取而代之的是，系統會調用單一匿名函數來回應每個 HTTP 請求。\napp.Run() 在 Startup 的 Configure 註冊 Middleware，將 app.Run() 註冊在最前面即第一個。\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;First. Hello World\u0026#34;); }); // ... } 設立中斷點，啟動應用程式，可以發現 Run 是最後一個執行，在 Run 後註冊的中介軟體都未執行，也就是說一般情況下 Run 必須註冊於最後，要使用的 Middleware 必須在 Run 之前註冊完成。\n再添加一個 Run 委派，等於目前註冊了兩個中介軟體，像這樣\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;First. Hello World\u0026#34;); }); app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Second. Hello World\u0026#34;); }); } 啟動應用程式觀察結果，當第一個 Run 委派輸出 First. Hello World 回應，就會終止 Pipeline，第二個 Run 委派則不會被呼叫。\napp.Use() 使用 Use 擴充方法來註冊 Middleware，也可以使用 Use 方法將多個請求委派鏈結再一起，next 代表 Pipeline 中的下個委派。通常可以在下一個委派前或後執行動作，你也可以不呼叫 next 參數來使 Pipeline 執行最少運算（short-circult）\n重新註冊 Middleware 如下\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;First Middleware.\\n\u0026#34;); await next.Invoke(); }); app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Second Middleware.\\n\u0026#34;); await next.Invoke(); }); app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Done. Hello World\\n\u0026#34;); }); } 觀察執行輸出如下\nFirst Middleware. Second Middleware. Done. Hello World 試試在使用 next.Invoke 之後繼續處理程式碼\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;First Middleware.\\n\u0026#34;); await next.Invoke(); await context.Response.WriteAsync(\u0026#34;First Middleware After Invoke.\\n\u0026#34;); }); app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Second Middleware.\\n\u0026#34;); await next.Invoke(); await context.Response.WriteAsync(\u0026#34;Second Middleware After Invoke.\\n\u0026#34;); }); app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Done. Hello World\\n\u0026#34;); }); } 觀察輸出結果\nFirst Middleware. Second Middleware. Done. Hello World Second Middleware After Invoke. First Middleware After Invoke. 在 Pipeline 概念中資料的順序是先進後出（First In Last Out），所以 Middleware 註冊的順序非常重要。\nMiddleware 也可以作為攔截使用，將第二個 Use 變更如下\napp.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Second Middleware.\\n\u0026#34;); if (false) await next.Invoke(); await context.Response.WriteAsync(\u0026#34;Second Middleware After Invoke.\\n\u0026#34;); }); 觀察輸出結果，發現在第二個 Use 中封裝未能往後面的 Pipeline 傳送。\nFirst Middleware. Second Middleware. Second Middleware After Invoke. First Middleware After Invoke. app.Map() Map 擴展方法用於約定分支管道，上述我們直接定義固定的管道，在應用程式作中時，都必須遵循此 Pipeline，而 Map 可以根據請求路徑來分配要作用的 Pipeline，當匹配成功分支會被執行。\n簡單來說，根據不同 URL 指向不同 Pipeline。\n在 Configure 方法內使用 Map，也可以建立靜態方法 HandleMapTest，方法內使用 Map\nprivate static void HandleMapTest(IApplicationBuilder app) { app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Map Test Done.\u0026#34;); }); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;First Middleware.\\n\u0026#34;); await next.Invoke(); await context.Response.WriteAsync(\u0026#34;First Middleware After Invoke.\\n\u0026#34;); }); app.Map(\u0026#34;/map\u0026#34;, HandleMapTest); app.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Second Middleware.\\n\u0026#34;); await next.Invoke(); await context.Response.WriteAsync(\u0026#34;Second Middleware After Invoke.\\n\u0026#34;); }); app.Map(\u0026#34;/middleware\u0026#34;, map =\u0026gt; { map.Use(async (context, next) =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Third Middleware.\\n\u0026#34;); await next.Invoke(); await context.Response.WriteAsync(\u0026#34;Third Middleware After Invoke.\\n\u0026#34;); }); map.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Done Third.\u0026#34;); }); }); app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Done. Hello World\\n\u0026#34;); }); } 運行應用程式觀察輸出結果，當前路徑 https://localhost:44323/\nFirst Middleware. Second Middleware. Done. Hello World Second Middleware After Invoke. First Middleware After Invoke. 路徑指向 https://localhost:44323/map 輸出結果\nFirst Middleware. Map Test Done. First Middleware After Invoke. 路徑指向 https://localhost:44323/middleware 輸出結果\nFirst Middleware. Second Middleware. Third Middleware. Done Third. Third Middleware After Invoke. Second Middleware After Invoke. First Middleware After Invoke. Middleware Components 一般應用程式會新增的中介軟體元件有\n 例外狀況/錯誤處理（Exception/error handling）  當應用程式運行於開發環境（Development） 當應用程式運行於生產環境（Production）   HTTPS 重新導向（HTTPS Redirection Middleware）\n將 HTTP 請求重新導向到 HTTPS UseHttpsRedirection 靜態檔案（Static File Middleware）\n傳回靜態檔案並縮短進一步請求處理的時間\nUseStaticFiles Cookie 原則（Cookie Policy Middleware）\n符合歐盟 General Data Protection Regulation (GDPR) 規定\nUseCookiePolicy 路由（Routing Middleware）\n傳送路由請求\nUseRouting 驗證（Authentication Middleware）\n使用者存取資源前先進行安全性驗證\nUseAuthentication 授權（Authorization Middleware）\n授權使用者存取資源的安全性\nUseAuthorization Session（Session Middleware）\n建立並維護 Session 狀態，需在 Cookie Policy Middleware 和 MVC Middleware 之前呼叫 Session Middleware\nUseSession 端點路由（Endpoint Routing Middleware）\n將頁面端點新增至請求管線\nUseEndpoints  Note 請求管道 Request delegates 配置的擴充方法\n Run Use Map  對於安全性、效能或功能各方面而言，註冊中介軟體的順序很重要，\nReference ASP.NET Core Middleware\nASP.NET Core - Middleware\n","permalink":"https://fakestandard.github.io/netcore/netcore5-3-middleware/","summary":"【ASP.NET Core 5】\nASP.NET Core 引入一個新概念稱為中介軟體（Middleware），Middleware 會在 ASP.NET Core 應用程式中的每個請求上執行。\n過去 ASP.NET 中 HttpHandlers 和 HttpModules 在 ASP.NET Core 已不復存在，更準確地說，它們已成為 Request Pipeline 的一部分，Middleware 類似於 HttpHandlers、HttpModules，都需要在每個請求中進行配置及執行。\nStart Middleware 是組成應用程式 Pipeline 的軟體，每個組件可以選擇是否將請求傳遞到管線中的下一個組件，也可以在下一個組件中的前後執行工作。\n通常 ASP.NET Core Web 應用程式中有許多 Middleware，它可以是 Framework provided 的中介軟體，也可以通過 NuGet 添加，甚至可以自行定義 Middleware。我們可以在請求管道中設置中介軟體的執行順序，每個中介軟體都會新增或修改 Http 請求，且可選擇將控制權傳遞給下一個中介軟體。\n請求委派用於建構請求管道，請求委派會處理每個 Http 請求。該句的原文是這樣\n Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.\n Request delegates 使用 Run、Map 和 Use 三種擴充方法來配置。單個請求委派可以指定嵌入式（in-line）匿名方法，稱為嵌入式中介軟體，也可以在重複使用的類別中進行定義。這些可重用的類別和嵌入式匿名方法就是 middleware ，也稱之為 middleware components。在請求管道中的每個中介軟體元件負責調用 Pipeline 中的下一個元件，或對管線執行最少運算，當中介軟體短路時（short-circult），會阻止接下來的中介軟體處理請求，稱之為終端中介軟體 terminal middleware。","title":"【.NET Core】中介軟體 Middleware"},{"content":"【5/24 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄雜湊表定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  雜湊表（Hash Table） 雜湊是一種電腦對資料的處理方式，它通過某種特定的雜湊函數應用，將鍵值轉換成相對應的資料儲存位址，形成一種快速存取與搜尋資料的資料結構—雜湊表，而雜湊表是一種儲存紀錄的連續記憶體。\n相關專有名詞  雜湊函數（Hashing Function）\n將未經雜湊的資料，透過特定的計算公式，轉換成對應的資料儲存位址，計算後的結果必須隨著明文改變而改變。 雜湊值（Hash Code）\n原始資料經由雜湊函數計算的結果，稱為雜湊值，且雜湊值為不可逆。不可逆的意思是，轉換後的結果無法反推原來的資料，只能由 A 變成 B，無法從 B 找回 A，例如將蘋果透過果汁機打成蘋果汁，蘋果就是原始資料，果汁機是雜湊函數，蘋果汁是雜湊值，我們無法將蘋果汁再透過果汁機變回蘋果，這就是不可逆。 桶（Bucket）\n雜湊表中儲存資料的位置，每個位置對應唯一的位址（Bucket Address） 槽（Slot）\n每一筆紀錄可能包含多個欄位，Slot 指的就是 Bucket 的欄位 碰撞（Collision）\n兩筆不同的資料，經雜湊函數運算後，對應到相同位址時，稱為碰撞 溢位（Overflow）\n資料經過雜湊函數運算後，對應的 Bucket 已滿，則會使 Bucket 發生溢位 雜湊表（Hash Table）\n儲存紀錄的連續記憶體，它類似於資料表的索引表格，可將 Column 和 Row 看待成 Slot 與 Bucket 完美雜湊（Perfect Hashing）\n指沒有發生碰撞，也沒有發生溢位的雜湊函數  雜湊應用 雜湊通常應用於加密或驗證，但雜湊不等於加密，加密不等於雜湊。其應用有身份證字號是透過公式來驗證是否合法，或者是 MD5 密碼雜湊函式，將使用者的 password 經由 MD5 產生雜湊值，再將雜湊值儲存於資料庫中，等下次使用者登入時，將輸入的密碼經由 MD5 運算，將其結果與資料庫中儲存的雜湊值進行比對即可。\n關於雜湊函數，設計時應遵循幾個原則\n 降低碰撞及溢位發生 雜湊函數不宜太複雜，越容易計算越佳 盡量把文字鍵值轉換成數值，以利運算 計算所得的值，盡量均勻分布在每一個 Bucket 中，不要太過於集中某些 Bucket 中，以降低碰撞及減少溢位處理  雜湊函式常見的有以下四種\n 除法 中間平方法 折疊法 數位分析法  碰撞與溢位的處理方法\n 線性探測法 平方探測法 再雜湊法 鏈結串列  後續文章會再紀錄關於雜湊函式及碰撞溢位的處理方法，這篇先給大家聞香一下。\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-9-hashtable/","summary":"【5/24 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄雜湊表定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  雜湊表（Hash Table） 雜湊是一種電腦對資料的處理方式，它通過某種特定的雜湊函數應用，將鍵值轉換成相對應的資料儲存位址，形成一種快速存取與搜尋資料的資料結構—雜湊表，而雜湊表是一種儲存紀錄的連續記憶體。\n相關專有名詞  雜湊函數（Hashing Function）\n將未經雜湊的資料，透過特定的計算公式，轉換成對應的資料儲存位址，計算後的結果必須隨著明文改變而改變。 雜湊值（Hash Code）\n原始資料經由雜湊函數計算的結果，稱為雜湊值，且雜湊值為不可逆。不可逆的意思是，轉換後的結果無法反推原來的資料，只能由 A 變成 B，無法從 B 找回 A，例如將蘋果透過果汁機打成蘋果汁，蘋果就是原始資料，果汁機是雜湊函數，蘋果汁是雜湊值，我們無法將蘋果汁再透過果汁機變回蘋果，這就是不可逆。 桶（Bucket）\n雜湊表中儲存資料的位置，每個位置對應唯一的位址（Bucket Address） 槽（Slot）\n每一筆紀錄可能包含多個欄位，Slot 指的就是 Bucket 的欄位 碰撞（Collision）\n兩筆不同的資料，經雜湊函數運算後，對應到相同位址時，稱為碰撞 溢位（Overflow）\n資料經過雜湊函數運算後，對應的 Bucket 已滿，則會使 Bucket 發生溢位 雜湊表（Hash Table）\n儲存紀錄的連續記憶體，它類似於資料表的索引表格，可將 Column 和 Row 看待成 Slot 與 Bucket 完美雜湊（Perfect Hashing）\n指沒有發生碰撞，也沒有發生溢位的雜湊函數  雜湊應用 雜湊通常應用於加密或驗證，但雜湊不等於加密，加密不等於雜湊。其應用有身份證字號是透過公式來驗證是否合法，或者是 MD5 密碼雜湊函式，將使用者的 password 經由 MD5 產生雜湊值，再將雜湊值儲存於資料庫中，等下次使用者登入時，將輸入的密碼經由 MD5 運算，將其結果與資料庫中儲存的雜湊值進行比對即可。","title":"【Algorithm】資料結構—雜湊表（Hash Table）"},{"content":"在 .NET 框架中，命名空間System.IO已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西\n 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。\n流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。\nStart 流（Stream）為所有資料流的基礎類別，繼承該類別的資料流常見的有\n FileStream StreamReader StreamWriter MemoryStream  FileStream FileStream可以用來讀取、寫入、開啟和關閉檔案系統上的檔案，或操縱其他與檔案相關的檔案處理系統。該類別主要是要操作位元組陣列， Stream 類別則直接操作字元，是兩者較不同的地方。\n文字讀起來沒感覺，直接使用FileStream來讀寫二進位制檔案。\n先建立一個含有文字內容的文字檔，透過FileStream開啟該文字檔，除了讀取出二進位制內容，也順便將 binary 轉換為字元打印出來。\n/// \u0026lt;summary\u0026gt; /// 使用 FileStream 讀取檔案 /// \u0026lt;/summary\u0026gt; public static void FileStreamRead() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立 FileStream 並實例化  // 開啟或建立指定路徑檔案，訪問權限唯讀  FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Read); // 讀取 binary 檔案  byte[] array = new byte[fs.Length]; fs.Read(array); // 打印 binary 檔案  Console.WriteLine(\u0026#34;讀取二進位制資料: \u0026#34;); foreach (var arr in array) { Console.Write(arr); } Console.WriteLine(Environment.NewLine); // 將 binary 轉換成字元  string str = Encoding.UTF8.GetString(array); Console.WriteLine(\u0026#34;二進位轉換成字元: \u0026#34;); Console.WriteLine(str); // 關閉檔案流  fs.Close(); // 釋放資源  fs.Dispose(); } 使用上述方法成功讀取事先建立的文字檔，接著再使用FileStream來寫入內容到檔案，最後呼叫FileStreamRead方法讀取檔案內容。\n/// \u0026lt;summary\u0026gt; /// 使用 FileStream 寫入檔案 /// \u0026lt;/summary\u0026gt; public static void FileStreamWrite() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立 FileStream 並實例化  // 開啟或建立指定檔案路徑，訪問權限唯寫  FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write); // 要寫入的字串  string str = \u0026#34;寫入一行新字串\u0026#34;; // 將字串轉換成位元組  byte[] array = Encoding.UTF8.GetBytes(str); // 寫入檔案流  fs.Write(array, 0, array.Length); // 關閉檔案流  fs.Close(); // 釋放資源  fs.Dispose(); Console.WriteLine(Environment.NewLine); Console.WriteLine($\u0026#34;即將寫入資料: {str}\u0026#34;); Console.WriteLine(Environment.NewLine); // 讀取檔案  FileStreamRead(); } StreamReader 使用StreamReader無須擔心檔案編碼方式，可直接讀取檔案文字內容，不用轉換成位元組陣列或從位元組陣列轉換為字元，讀出結果直接是字元。\n/// \u0026lt;summary\u0026gt; /// 使用 StreamReader 讀取檔案 /// \u0026lt;/summary\u0026gt; public static void UseStreamReader() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立 StreamReader 並實體化  StreamReader sr = new StreamReader(path); // 迭代逐行讀取內容  string s; while ((s = sr.ReadLine()) != null) { Console.WriteLine(s); } // 或是一次讀到底  Console.WriteLine(sr.ReadToEnd()); sr.Close(); sr.Dispose(); } 根據上述代碼可以讀出檔案的文字內容，但若依照程式碼邏輯，使用ReadLine()和ReadToEnd()應該會讀取兩次，實際上卻只有輸出一次？\n原因是先使用ReadLine()進行第一次讀取，此時檔案流的指標已經讀到結尾，再進行任何讀取方法時，對檔案流來說已經是最末端，沒有讀到任何資料，所以什麼都沒有，此時需手動將指標位置移回至檔案流的起始位置，在進行讀取動作，方能成功輸出兩次。\n// 將流的指標返回到初始位置 sr.BaseStream.Position = 0; StreamWriter 使用StreamWriter類別寫入檔案非常簡單，馬上來看\n/// \u0026lt;summary\u0026gt; /// 使用 StreamWriter 寫入檔案 /// \u0026lt;/summary\u0026gt; public static void UseStreamWrite() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立 StreamWriter 並實體化  StreamWriter sw = new StreamWriter(path); // 寫入檔案內容  sw.WriteLine(\u0026#34;寫入第一行文字\u0026#34;); sw.WriteLine(\u0026#34;寫入第二行文字\u0026#34;); sw.WriteLine(\u0026#34;寫入第三行文字\u0026#34;); sw.Close(); sw.Dispose(); // 讀取檔案  UseStreamReader(); } MemoryStream MemoryStream可稱為記憶體流，顧名思義是為系統記憶體提供讀寫操作，而上述的FileStream、StreamWriter和StreamReader類別則是對永續性儲存裝置進行讀寫。\n使用預設的無參數建構函式實例化記憶體流，然後使用Write方法寫入，隨著位元組資料的寫入會自動調整大小。而MemoryStream類別還封裝一個位元組陣列，該構造函式使用一個byte[]作為傳遞參數，但是該陣列長度無法在調整，也無法透過Write方法寫入時自動調整。\n實體化記憶體流物件時，會建立一塊連續的記憶體區域，我們可稱該區域為緩衝區也就是 Buffer，也可以將緩衝區看作為一個陣列，每個陣列元素可存放一個位元組資料。\n/// \u0026lt;summary\u0026gt; /// 操作記憶體流 /// \u0026lt;/summary\u0026gt; public static void UseMemoryStream() { int count; char[] charArray; UnicodeEncoding ue = new UnicodeEncoding(); // 要寫入的資料  byte[] firstString = ue.GetBytes(\u0026#34;寫入第一行資料\u0026#34;); byte[] secondString = ue.GetBytes(\u0026#34;嘗試寫入第二行資料\u0026#34;); // 使用 using 區塊在末尾釋放資源  using (MemoryStream ms = new MemoryStream(100)) { // 使用 Write 方法  ms.Write(firstString, 0, firstString.Length); // 使用 WriteByte 方法  count = 0; while (count \u0026lt; secondString.Length) { ms.WriteByte(secondString[count++]); } Console.WriteLine($\u0026#34;Capacity: {ms.Capacity.ToString()}\u0026#34;); Console.WriteLine($\u0026#34;Length: {ms.Length.ToString()}\u0026#34;); Console.WriteLine($\u0026#34;Position: {ms.Position.ToString()}\u0026#34;); // 目前流的指標位置在最末端，將指標位置移到頂端進行讀取  ms.Seek(0, SeekOrigin.Begin); // 建立與記憶體流長度相同的位元組陣列  byte[] byteArray = new byte[ms.Length]; // 讀取記憶體流資料放到位元組陣列中  ms.Read(byteArray, 0, byteArray.Length); Console.WriteLine(ue.GetString(byteArray)); // 移動記憶體流指標位置到頂端  ms.Seek(0, SeekOrigin.Begin); // 只讀取前十個位元組資料  ms.Read(byteArray, 0, 10); Console.WriteLine(ue.GetString(byteArray)); } } Note 使用FileStream要注意關閉檔案流，如果不關閉，需要等待一段時間後才能再次開啟檔案（約一分鐘），因為它會等待 GC 來釋放FileStream後才會關閉文件。不過在操作任何資源時，本應注意關閉和釋放資源這部分。\n流的區別\n 對永續性儲存裝置操作：FileStream、StreamWriter、StreamReader 對底層記憶體操作：MemoryStream、BufferedStream  Reference Stream Class\nFileStream\nStreamReader\nStreamWriter\nMemoryStream\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-9-filesystemandfileio-two/","summary":"在 .NET 框架中，命名空間System.IO已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西\n 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。\n流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。\nStart 流（Stream）為所有資料流的基礎類別，繼承該類別的資料流常見的有\n FileStream StreamReader StreamWriter MemoryStream  FileStream FileStream可以用來讀取、寫入、開啟和關閉檔案系統上的檔案，或操縱其他與檔案相關的檔案處理系統。該類別主要是要操作位元組陣列， Stream 類別則直接操作字元，是兩者較不同的地方。\n文字讀起來沒感覺，直接使用FileStream來讀寫二進位制檔案。\n先建立一個含有文字內容的文字檔，透過FileStream開啟該文字檔，除了讀取出二進位制內容，也順便將 binary 轉換為字元打印出來。\n/// \u0026lt;summary\u0026gt; /// 使用 FileStream 讀取檔案 /// \u0026lt;/summary\u0026gt; public static void FileStreamRead() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立 FileStream 並實例化  // 開啟或建立指定路徑檔案，訪問權限唯讀  FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Read); // 讀取 binary 檔案  byte[] array = new byte[fs.","title":"【.NET】使用 C# 操作檔案 I/O 與檔案系統（二）"},{"content":"【5/25 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄圖形定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  圖形（Graph） 圖形理論是由一位瑞士數學家所想出的一種資料結構，是比樹狀結構更複雜的非線性結構，許多問題都可以轉換成圖形資料結構，因此，圖形資料結構被廣泛應用於程式的實作，在所有資料結構中的應用也最為廣泛。\n例如在網路的地圖上搜尋兩點之間的最短路徑，可以將地點轉換成圖形中的頂點，地點與地點之間的距離轉換成邊，最後使用最短路徑的演算法，即可以找出最短路徑。\n圖的定義是由**頂點（Vertice）和邊（Edge）**所組成的集合，邊是連結圖形中的兩個頂點，可以有循環，也可以不跟其他頂點相連，通常以 G=(V,E) 來定義一個圖形\n G：圖（Graph） V：所有頂點（Vertice）的集合 E：所有邊（Edge）的集合  圖形的種類有兩種，分別是無向圖形和有向圖形\n無向圖形（Undirected Graph） 無向圖形的邊只代表頂點之間是相連，不會標示方向箭頭，可以說是不具有方向性，無向圖以 (V1,V2) 來表示，例如 (V1,V2) 與 (V2,V1) 表示相同的邊。\n以上圖來說\nV = {A,B,C,D,E} E = {(A,B),(A,C),(B,D),(B,E),(C,D),(C,E)} 有向圖形（Directed Graph） 有向圖形的每個邊都具有方向性，以 \u0026lt;V1,V2\u0026gt; 來表示，若無向圖是不具方向性，那麼有向圖就是具有方向性的，V1 是指尾端，V2 是指頂端，\u0026lt;V1,V2\u0026gt; 則代表著由 V1 尾端指向 V2 頂端。例如 \u0026lt;V1,V2\u0026gt; 和 \u0026lt;V2,V1\u0026gt; 表示兩個不同方向的邊。\n以上圖來說，與無向圖形的範例圖差異在於，該圖的邊是具有方向性箭頭，表示方式如下\nV = {A,B,C,D,E} E = {\u0026lt;A,B\u0026gt;,\u0026lt;A,C\u0026gt;,\u0026lt;B,D\u0026gt;,\u0026lt;C,D\u0026gt;,\u0026lt;E,B\u0026gt;,\u0026lt;E,C\u0026gt;} 相關專有名詞   頂點（Vertice）\n圖形中的點\n  邊（Edge）\n兩個頂點之間相連的邊\n  路徑（Path） 兩個頂點之間所要經過的邊，稱之為路徑，例如從 A 到 D，需要經過 C，其路徑為 {(A,C),(C,D)}\n  路徑長度（Path length）\n一個路徑上所包含邊的個數，稱之為路徑長度。例如從 A 到 D，需要經過 C，其路徑為 {(A,C),(C,D)}，該路徑經過兩條邊，則路徑長度為 2\n  簡單路徑（Simple path）\n在一條路徑中，起點與終點可以為同一個點，或是不同的點，但路徑中所經過的頂點不能重複，或是皆不相同，稱之為簡單路徑。例如 A B C D E A 為簡單路徑，A B C D E 也是簡單路徑，A B C B D A 就不是簡單路徑，因為除了是起點也是終點的 A 之外，路徑中 B 出現兩次。\n  循環（Cycle）\n起點與終點皆為相同頂點的簡單路徑，稱之為循環。\n  相連（或鄰接）\n如果兩個頂點之間擁有一條邊連結，則該兩點稱為相連或是鄰接。\n  強相連\n在有向圖形中，任意兩個頂點之間具有邊可以相連，且雙向皆可連結。例如下圖的 B 可以到 C，C 也可以到 B。\n圖片來源   相連圖形（Connected Graph）\n圖形內任何兩個頂點都有路徑相連，稱為相連圖形。\n  不相連圖形（Disconnected Graph）\n圖形內至少有兩個頂點之間是沒有路徑相連的，稱之為不相連圖形。\n  完整圖形（Complete Graph）\n完整圖形的邊個數須符合公式 n(n-1)/2，其中 n 為點的數量。例如無向圖中有五個頂點，將五個頂點套入公式得到十，若該圖形存在十個邊，則是完整圖形。\n圖片來源   子圖（Subgraph）\n假設 G2 是 G1 的子圖，G2 出現過的頂點與邊，在 G1 皆有相同的頂點與邊。\n圖片來源   分支度（Degree）\n若為無向圖，分支度表示一個頂點包含邊的數量；若是有向圖，則分支度是入支度與出支度的總和。\n  入支度（In-degree）\n在有向圖中，箭頭指入端點的個數。以下圖為例，A 點的入支度為 1\n  出支度（Out-degree）\n在有向圖中，箭頭從頂點指出箭頭的個數。以下圖為例，A 點的出支度為 2\n  圖片來源   Note  將無向圖想像成雙向道，有向圖則是單行道會比較好記憶。\n 另外本書在圖形的專有名詞並未多作介紹，筆者參考了許多網路文章，慢慢整理出圖形相關的名詞，可是花了好長的時間，畢竟資訊爆炸的網路，真真假假偶爾也是要靠智慧來辨識。在參考文章的過程中，因筆者目前還未找到好用的畫圖工具，故暫借其他文章內的圖片表示一些範例，若有任何侵權問題，有勞告知，筆者會盡速處理。\nReference 【圖說演算法 C#】\n擁抱「資料結構」的「演算法」(14) - 圖形 Graph\n圖形結構(C++)\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-8-graph/","summary":"【5/25 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄圖形定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  圖形（Graph） 圖形理論是由一位瑞士數學家所想出的一種資料結構，是比樹狀結構更複雜的非線性結構，許多問題都可以轉換成圖形資料結構，因此，圖形資料結構被廣泛應用於程式的實作，在所有資料結構中的應用也最為廣泛。\n例如在網路的地圖上搜尋兩點之間的最短路徑，可以將地點轉換成圖形中的頂點，地點與地點之間的距離轉換成邊，最後使用最短路徑的演算法，即可以找出最短路徑。\n圖的定義是由**頂點（Vertice）和邊（Edge）**所組成的集合，邊是連結圖形中的兩個頂點，可以有循環，也可以不跟其他頂點相連，通常以 G=(V,E) 來定義一個圖形\n G：圖（Graph） V：所有頂點（Vertice）的集合 E：所有邊（Edge）的集合  圖形的種類有兩種，分別是無向圖形和有向圖形\n無向圖形（Undirected Graph） 無向圖形的邊只代表頂點之間是相連，不會標示方向箭頭，可以說是不具有方向性，無向圖以 (V1,V2) 來表示，例如 (V1,V2) 與 (V2,V1) 表示相同的邊。\n以上圖來說\nV = {A,B,C,D,E} E = {(A,B),(A,C),(B,D),(B,E),(C,D),(C,E)} 有向圖形（Directed Graph） 有向圖形的每個邊都具有方向性，以 \u0026lt;V1,V2\u0026gt; 來表示，若無向圖是不具方向性，那麼有向圖就是具有方向性的，V1 是指尾端，V2 是指頂端，\u0026lt;V1,V2\u0026gt; 則代表著由 V1 尾端指向 V2 頂端。例如 \u0026lt;V1,V2\u0026gt; 和 \u0026lt;V2,V1\u0026gt; 表示兩個不同方向的邊。\n以上圖來說，與無向圖形的範例圖差異在於，該圖的邊是具有方向性箭頭，表示方式如下\nV = {A,B,C,D,E} E = {\u0026lt;A,B\u0026gt;,\u0026lt;A,C\u0026gt;,\u0026lt;B,D\u0026gt;,\u0026lt;C,D\u0026gt;,\u0026lt;E,B\u0026gt;,\u0026lt;E,C\u0026gt;} 相關專有名詞   頂點（Vertice）","title":"【Algorithm】資料結構—圖形（Graph）"},{"content":"【5/17 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。\n上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。\n對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。\n樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）\n樹的基本術語有許多種，利用上圖的樹狀圖一一解說\n  根節點（Root）\n先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點\n  葉節點（Leaf）或終點節點（Terminal Nodes）\n節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點\n  非終端節點（Nonterminal Nodes）\n除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H\n  子節點（Children）\n每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D\n  父節點（Parent）\n每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C\n  祖先節點（Ancestor）\n指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。\n  子孫節點（Descendant）\n指某個節點往下追溯所有的子節點都是子孫節點。例如 D 的子孫節點有 H、I、J、M\n  兄弟節點（Siblings） 指節點間有共同的父節點，則節點彼此間稱為兄弟節點。例如 B、C、D 是兄弟節點，H、I、J 也是兄弟節點\n  分支度（Degree）\n指每個節點下擁有的子樹個數。例如 B 的分支度為 2，D 的分支度為 3\n  階層（Level）\n指樹的層級，如果 A 是第一階層，則 B、C、D 是第二階層…以此類推\n  樹深（Depth）\n指樹的最大階層數，也可以稱為樹高（Height）或高度。例如該樹的樹深為 4\n  同代（Generation）\n指具有相同階層的節點，以上面介紹過的階層來看，第二階層有 B、C、D，則 B、C、D 就是同代\n  樹林（Forest）\n樹林是由 n 個互斥樹的集合（n ≧ 0），去除樹根後，剩下的樹即為樹林，例如去除樹根 A 後，就會剩下三個樹林\n  二元樹（Binary Tree） 一般樹狀結構在記憶體中的儲存方式是鏈結串列，而在資料結構中最廣泛使用的樹狀結構是二元樹，因為它的鏈結浪費率最低，通常使用二元樹來代替樹狀結構可以改善記憶體空間浪費的缺點。\n二元樹的定義為 Binary Tree 的節點個數是一個有限集合，或是沒有節點的空集合，或是由一個樹根及兩個沒有交集的子樹組成，分別為左子樹（Left Sub-tree）和（Right Sub-tree）。簡單來說，Binary Tree 中的每個節點最多只能擁有兩個子節點，即分支度小於或等於二。\nBinary Tree 可用的陣列表示法有兩種：\n  我們可以知道一顆樹的樹高，假設樹高為 h，那麼該樹可擁有的最大節點個數為 (2^h)-1，換句話說，配置 (2^h)-1 個元素，就能儲存樹高為 h 的二元樹。以下圖為例，該樹高 h 為 3，則可配置 (2^3)-1 共七個節點。\n (2^h)-1 是 (2 的 h 次方)-1\n   二元樹的節點編號擁有循序性，參考下圖，將每個節點都編制編號，可得編號的規則為：左子樹是父節點編號乘二、右子樹是父節點編號乘二再減一。                BTree A B C D E F G   編號 1 2 3 4 5 6 7      完滿二元樹（Fully Binary Tree） 如果二元樹的樹高為 h，樹的節點數量為 2^h-1，且 h \u0026gt;= 0，則該樹稱之為完滿二元樹\n完整二元樹（Complete Binary Tree） 如果二元樹的樹高 h，所含的節點數量小於 2^h-1，而且其節點編號方式如同完滿二元樹，由左到右，由上到下一一對應結合，稱之為完整二元樹。左圖是一顆完美二元樹，右圖則不是完滿二元樹，因為缺少 6 的節點，並沒有按照左到右的順序結合。\n歪斜樹（Skewed Binary Tree） 當一顆樹沒有左邊節點，或右邊節點時，稱為左歪斜樹或右歪斜樹\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-7-tree/","summary":"【5/17 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。\n上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。\n對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。\n樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）\n樹的基本術語有許多種，利用上圖的樹狀圖一一解說\n  根節點（Root）\n先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點\n  葉節點（Leaf）或終點節點（Terminal Nodes）\n節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點\n  非終端節點（Nonterminal Nodes）\n除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H\n  子節點（Children）\n每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D\n  父節點（Parent）\n每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C\n  祖先節點（Ancestor）\n指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。","title":"【Algorithm】資料結構—樹（Tree）"},{"content":"【5/16 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。\n佇列基本運算具備以下五種工作定義\n   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。\nNote  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-6-queue/","summary":"【5/16 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。\n佇列基本運算具備以下五種工作定義\n   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。\nNote  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】","title":"【Algorithm】資料結構—佇列（Queue）"},{"content":"【ASP.NET Core 5】\n如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。\nStart 相依性是另一個物件所依賴的物件。\n建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法\npublic class MyDependency { public void WriteMessage(string message) { Console.WriteLine($\u0026#34;Message:{message}\u0026#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。\npublic class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(\u0026#34;MyClass get a message\u0026#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。\n接著透過 DI 容器來切斷彼此間的相依性，首先使用介面或父類別讓相依性資訊抽象化，在內建 Services 容器中註冊依賴類別，服務通常在應用程式中 Startup.ConfigureServices 註冊，最後將服務植入到使用該服務的類別建構式中，DI 容器會負責產生物件實例，直到不需要時會將其釋放。\n建立介面 IMyDependency，並定義 WriteMessage 方法\npublic interface IMyDependency { void WriteMessage(string message); } MyDependency 類別繼承 IMyDependency 且明確實作該介面\npublic class MyDependency : IMyDependency { void IMyDependency.WriteMessage(string message) { Console.WriteLine($\u0026#34;Message:{message}\u0026#34;); } } 使用 AddScoped\u0026lt;\u0026gt; 擴充功能在 Startup.ConfigureServices 中註冊該實作類別，第一個泛型為注入的類型，建議用介面包裝以拆掉相依性，第二個泛型為實作類別。\npublic void ConfigureServices(IServiceCollection services) { // 註冊服務  services.AddScoped\u0026lt;IMyDependency, MyDependency\u0026gt;(); services.AddControllersWithViews(); } ASP.NET Core 使用 Constructor Injection 將實例化的物件從建構式傳入，要取用已經註冊在 DI 容器的服務物件，只要在建構式加入相對的介面即可。\n回到 MyClass 類別，使用 IMyDependency 介面來改善實作\n 不使用具體類別 MyDependency，改為使用它所執行的 IMyDependency 介面 不會產生 MyDependency 實例，該實例會由 DI 容器建立  public class MyClass { private readonly IMyDependency _myDependency; public MyClass(IMyDependency myDependency) { _myDependency = myDependency; } public void Get() { _myDependency.WriteMessage(\u0026#34;MyClass get a message\u0026#34;); } } 如此一來就完成 DI 注入的動作。\nService Lifetime 前面使用 AddScoped\u0026lt;\u0026gt; 擴充方法註冊服務，除了該擴充方法外，還有其餘可用於註冊的擴充方法，它們用以定義服務的生命週期，待使用完服務時，容器會對注入的服務進行釋放，而選擇適當的生命週期，可以節省記憶體，提升程式效率，反之可能會造成重大的異常錯誤。\n從程式碼可以看到，生命週期有三種列舉值\nnamespace Microsoft.Extensions.DependencyInjection { public enum ServiceLifetime { Singleton = 0, Scoped = 1, Transient = 2 } } Transient  每次向服務容器請求時，都會建立新實例，該生命週期適用於輕量級的無狀態服務。 使用 AddTransient 註冊服務 無論是否為同一客戶端或請求，每次都使用新的實例  Scoped  每個 Client Side 請求時，都會重新建立一個實例，所以同一個請求不管經過多少 Pipeline 都是用同一個實例 使用 AddScoped 註冊服務 不同客戶端使用不同實例，客戶端內不同請求使用同一個實例  Singleton  第一次請求時建立新實例，應用程式運行期間不會消失，也不會再建立 使用 AddSingleton 註冊服務 不同客戶端不同請求都是使用同一個實例   依照 John Wu 文章的實驗，筆者也仿照他的方式，實際測試服務生命週期的差異\n 新增三個介面並繼承 IMyDependency 介面 MyDependency 類別改為繼承上述新增的三個介面  public interface ITransient : IMyDependency { } public interface IScoped : IMyDependency { } public interface ISingleton : IMyDependency { } public class MyDependency : ITransient, IScoped, ISingleton { void IMyDependency.WriteMessage(string message) { Console.WriteLine($\u0026#34;Message:{message}\u0026#34;); } } 在 Startup.cs 中註冊三種不同生命週期的服務\npublic void ConfigureServices(IServiceCollection services) { // 註冊生命週期的服務  services.AddTransient\u0026lt;ITransient, MyDependency\u0026gt;(); services.AddScoped\u0026lt;IScoped, MyDependency\u0026gt;(); services.AddSingleton\u0026lt;ISingleton, MyDependency\u0026gt;(); services.AddControllersWithViews(); } 在 HomeController 建構子中注入實例及定義 ServiceLifeTime 動作方法\npublic class HomeController : Controller { private readonly ILogger\u0026lt;HomeController\u0026gt; _logger; private readonly ITransient _transient; private readonly IScoped _scoped; private readonly ISingleton _singleton; public HomeController( ITransient transient, IScoped scoped, ISingleton singleton) { _transient = transient; _scoped = scoped; _singleton = singleton; } public IActionResult ServiceLifeTime() { ViewBag.TransientHC = _transient.GetHashCode(); ViewBag.ScopedHC = _scoped.GetHashCode(); ViewBag.SingletonHC = _singleton.GetHashCode(); return View(); } } 繪製 View 呈現的表格\n\u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Lifetime\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Hash Code\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Transient\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@ViewBag.TransientHC\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Scoped\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@ViewBag.ScopedHC\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Singleton\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@ViewBag.SingletonHC\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 實際運行應用程式，在三個瀏覽器同時打開頁面，或者對頁面重新整理，發現 Singleton 的 Hash Code 都是一樣的，驗證了前述所說，只在應用程式啟動時 new 一個新實例，運行期間不會消失，直到應用程式停用才會釋放。\n再修改 View 代碼，使用 @inject 直接在 View 中注入 Service\n@inject ITransient transient @inject IScoped scoped @inject ISingleton singleton ... \u0026lt;hr/\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Lifetime\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Hash Code\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Transient\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@transient.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Scoped\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@scoped.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Singleton\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@singleton.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 啟動應用程式如下圖，在同一個 Client Side 使用不同請求，Scoped 的 Hash Code 並未改變；比較在不同的 Client Side，Scoped 的 Hash Code 也不同。\n最後，自行定義一個服務，並注入上述三個 Service，觀察變化\npublic class MyService { public ITransient Transient { get; private set; } public IScoped Scoped { get; private set; } public ISingleton Singleton { get; private set; } public MyService( ITransient transient, IScoped scoped, ISingleton singleton) { Transient = transient; Scoped = scoped; Singleton = singleton; } } 在 Startup.cs 註冊自定義服務\npublic void ConfigureServices(IServiceCollection services) { ... // 註冊自定義服務  services.AddScoped\u0026lt;MyService, MyService\u0026gt;(); } 使用 @inject 注入到 View\n@inject ITransient transient @inject IScoped scoped @inject ISingleton singleton @inject MyService myService ... \u0026lt;hr/\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Lifetime\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Hash Code\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Transient\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@myService.Transient.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Scoped\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@myService.Scoped.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Singleton\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@myService.Singleton.GetHashCode()\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 啟動應用程式，觀察不同服務注入，在同一個請求內，對於 Scoped 來說會使用同一個實例；Transient 則是每次請求都重新建立實例，Singleton 在應用程式啟動時建立實例，往後該實例會一直存在並被使用，直到應用程式關閉才將其處置。\nNote 實際了解相依性注入後，發現服務的 Lifetime 很有趣，對於動作的時間點有著更進一步的理解，John Wu 生命週期的實驗，對筆者來說有很大的收穫，動手做果然很有感。\nReference Dependency Injection in ASP.NET Core\nDependency injection in .NET\nASP.NET Core - Dependency Injection\nASP.NET Core 3 系列 - 依賴注入 (Dependency Injection) \n","permalink":"https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/","summary":"【ASP.NET Core 5】\n如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。\nStart 相依性是另一個物件所依賴的物件。\n建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法\npublic class MyDependency { public void WriteMessage(string message) { Console.WriteLine($\u0026#34;Message:{message}\u0026#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。\npublic class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(\u0026#34;MyClass get a message\u0026#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。","title":"【.NET Core】相依性注入 Dependency Injection"},{"content":"【5/16 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。\n堆疊基本運算具備以下五種工作定義\n   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。\nNote  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-5-stack/","summary":"【5/16 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。\n堆疊基本運算具備以下五種工作定義\n   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。\nNote  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】","title":"【Algorithm】資料結構—堆疊（Stack）"},{"content":"在 .NET 框架中，命名空間 System.IO 已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西\n 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。\n流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。\nStart FileSystemInfo 類別是檔案系統類別的基礎類別，繼承該類別的子類別有\n File - 負責檔案系統中的檔案，屬靜態類別 FileInfo - 負責檔案系統中的檔案 Directory - 負責檔案系統中的資料夾，屬靜態類別 DirectoryInfo - 負責檔案系統中的資料夾  另外還有位於 System.IO 命名空間下其餘相關的類別\n Path - 負責檔案系統中的路徑 DriveInfo - 負責磁碟機資訊的訪問  File 與 FileInfo 的區別在於 Info 類別需要實體化，而一般 File 是屬於靜態類別；Directory 與 DirectoryInfo 同理，Directory 是靜態類別，DirectoryInfo 需實體化類別。\nFileInfo 使用 FileInfo 類別建立檔案，並且寫入資料\n/// \u0026lt;summary\u0026gt; /// 建立檔案並寫入資料 /// \u0026lt;/summary\u0026gt; public static void CreateFileByFileInfo() { // 實體化 FileInfo 並指予路徑  FileInfo file = new FileInfo(@\u0026#34;D:\\Test.txt\u0026#34;); // 寫入流實體化  StreamWriter sw = file.AppendText(); // 寫入  sw.WriteLine(\u0026#34;第一行寫入測試\u0026#34;); sw.WriteLine(\u0026#34;第二行寫入測試\u0026#34;); // 關閉流  sw.Close(); // 釋放資源  sw.Dispose(); Console.WriteLine($\u0026#34;建立時間:{file.CreationTime}\u0026#34;); Console.WriteLine($\u0026#34;檔案路徑:{file.DirectoryName}\u0026#34;); Console.WriteLine($\u0026#34;完成檔案建立與寫入\u0026#34;); } 在檔案開啟前，使用 FileInfo 判斷檔案是否存在\n/// \u0026lt;summary\u0026gt; /// 判斷檔案是否存在 /// \u0026lt;/summary\u0026gt; public static void IsFileByFileInfo() { FileInfo file = new FileInfo(@\u0026#34;D:\\Test.txt\u0026#34;); if (!file.Exists) { Console.WriteLine(\u0026#34;檔案不存在\u0026#34;); // 建立檔案或其他作業...  } else { Console.WriteLine(\u0026#34;檔案已存在\u0026#34;); // 開啟檔案進行讀取作業...  } } 對檔案執行移動、複製或刪除\n/// \u0026lt;summary\u0026gt; /// 對檔案執行移動、複製或刪除 /// \u0026lt;/summary\u0026gt; public static void FileInfoAction() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; FileInfo file = new FileInfo(path); // 複製到新路徑  file.CopyTo(@\u0026#34;D:\\Test\\TestABC.txt\u0026#34;); // 複製到新路徑多載方法  // overwrite 參數 true 表示可以覆寫已存在的檔案  file.CopyTo(@\u0026#34;D:\\Test\\TestABC.txt\u0026#34;, true); // 移動到指定路徑  file.MoveTo(@\u0026#34;D:\\Test\\Test.txt\u0026#34;); // 移動到指定路徑多載方法  // overwrite 參數 true 表示可以覆寫已存在的檔案  file.MoveTo(@\u0026#34;D:\\Test\\Test.txt\u0026#34;, true); // 因有執行移動，此時 file 實例的路徑已更新成移動後的新路徑  Console.WriteLine(file.FullName); // 刪除檔案  file.Delete(); } 讀取檔案內容\n/// \u0026lt;summary\u0026gt; /// 讀取檔案內容 /// \u0026lt;/summary\u0026gt; public static void ReadFileInfo() { string path = @\u0026#34;D:\\Test\\TestABC.txt\u0026#34;; FileInfo info = new FileInfo(path); StreamReader sr = info.OpenText(); string str = \u0026#34;\u0026#34;; while ((str = sr.ReadLine()) != null) { Console.WriteLine(str); } sr.Close(); sr.Dispose(); } File 使用 File 類別建立檔案，並且寫入資料\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別建立檔案並寫入資料 /// \u0026lt;/summary\u0026gt; public static void CreateFileByFile() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 建立檔案  FileStream fs = File.Create(path); Console.WriteLine($\u0026#34;建立時間:{File.GetCreationTime(path)}\u0026#34;); Console.WriteLine($\u0026#34;檔案路徑:{Path.GetDirectoryName(path)}\u0026#34;); byte[] info1 = new UTF8Encoding(true).GetBytes(\u0026#34;第一行寫入測試\\n\u0026#34;); byte[] info2 = new UTF8Encoding(true).GetBytes(\u0026#34;第二行寫入測試\u0026#34;); // 寫入檔案流  fs.Write(info1, 0, info1.Length); fs.Write(info2, 0, info2.Length); // 關閉檔案流流  fs.Close(); // 釋放資源  fs.Dispose(); Console.WriteLine($\u0026#34;完成檔案建立與寫入\u0026#34;); } 在檔案開啟前，使用 File 判斷檔案是否存在\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別檢查檔案是否存在 /// \u0026lt;/summary\u0026gt; public static void IsFileExists() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; if (!File.Exists(path)) { Console.WriteLine(\u0026#34;檔案不存在\u0026#34;); // 建立檔案或其他作業...  } else { Console.WriteLine(\u0026#34;檔案已存在\u0026#34;); // 開啟檔案進行讀取作業...  } } 使用靜態類別對檔案執行移動、複製或刪除\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別對檔案執行移動、複製或刪除 /// \u0026lt;/summary\u0026gt; public static void FileAction() { string path = @\u0026#34;D:\\Test.txt\u0026#34;; // 複製到新路徑  File.Copy(path, @\u0026#34;D:\\Test\\TestABC.txt\u0026#34;); // 複製到新路徑多載方法  // overwrite 參數 true 表示可以覆寫已存在的檔案  File.Copy(path, @\u0026#34;D:\\Test\\TestABC.txt\u0026#34;, true); // 移動到指定路徑  File.Move(path, @\u0026#34;D:\\Test\\Test.txt\u0026#34;); // 移動到指定路徑多載方法  // overwrite 參數 true 表示可以覆寫已存在的檔案  File.Move(path, @\u0026#34;D:\\Test\\Test.txt\u0026#34;, true); // 刪除檔案  File.Delete(path); } 使用靜態類別讀取檔案內容\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別讀取檔案內容 /// \u0026lt;/summary\u0026gt; public static void ReadFile() { string path = @\u0026#34;D:\\Test\\TestABC.txt\u0026#34;; // 讀取所有文字  string text = File.ReadAllText(path, Encoding.UTF8); Console.WriteLine(\u0026#34;ReadAllText:\\n\u0026#34;); Console.WriteLine(text); // 讀取所有行  string[] lines = File.ReadAllLines(path, Encoding.UTF8); Console.WriteLine(\u0026#34;ReadAllLines:\\n\u0026#34;); foreach(string line in lines) { Console.WriteLine(line); } Console.WriteLine(Environment.NewLine); Console.WriteLine(\u0026#34;ReadAllBytes: \\n\u0026#34;); // 讀取二進位  byte[] bytes = File.ReadAllBytes(path); foreach(byte b in bytes){ Console.Write(b); } } 使用靜態類別寫入檔案內容\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別寫入檔案內容 /// \u0026lt;/summary\u0026gt; public static void WriteFile() { string path = @\u0026#34;D:\\Test\\TestABC.txt\u0026#34;; // 寫入所有字串  File.WriteAllText(path, \u0026#34;Hello World\u0026#34;); // 寫入所有行  string[] arr = { \u0026#34;ABC\u0026#34;, \u0026#34;DEF\u0026#34;, \u0026#34;GHI\u0026#34; }; File.WriteAllLines(path, arr); // 寫入二進制  byte[] b = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; File.WriteAllBytes(path, b); } DirectoryInfo 使用 DirectoryInfo 類別建立資料夾\n/// \u0026lt;summary\u0026gt; /// 建立資料夾 /// \u0026lt;/summary\u0026gt; public static void CreateFolderByDirectoryInfo() { // 建立目錄實例  DirectoryInfo info = new DirectoryInfo(@\u0026#34;D:\\Test\\Directory\u0026#34;); // 建立目錄  info.Create(); Console.WriteLine($\u0026#34;父目錄: {info.Parent.FullName}\u0026#34;); } 讀取目錄下所有資料夾與檔案\n/// \u0026lt;summary\u0026gt; /// 讀取目錄下所有資料夾與檔案 /// \u0026lt;/summary\u0026gt; public static void ReadFolderByDirectoryInfo() { // 取得目錄實例  DirectoryInfo info = new DirectoryInfo(@\u0026#34;D:\\\u0026#34;); // 讀取目錄下所有資料夾與檔案  FileSystemInfo[] files = info.GetFileSystemInfos(); // 讀取父目錄下所有資料夾與檔案  //FileSystemInfo[] files = info.Parent.GetFileSystemInfos();  foreach (var file in files) { Console.WriteLine(file.Name); } } 檢查目錄是否存在\n/// \u0026lt;summary\u0026gt; /// 檢查目錄是否存在 /// \u0026lt;/summary\u0026gt; public static void IsFolderByDirectoryInfo() { string path = @\u0026#34;D:\\Test\u0026#34;; DirectoryInfo info = new DirectoryInfo(path); if (!info.Exists) { Console.WriteLine(\u0026#34;目錄不存在\u0026#34;); } else { Console.WriteLine(\u0026#34;目錄已存在\u0026#34;); } } 刪除目錄資料夾\n/// \u0026lt;summary\u0026gt; /// 刪除目錄資料夾 /// \u0026lt;/summary\u0026gt; public static void DeleteFolderByDirectoryInfo() { string path = @\u0026#34;D:\\Test\u0026#34;; DirectoryInfo info = new DirectoryInfo(path); // 刪除資料夾，資料夾內必須為空，不得有任何檔案或資料夾，否則會扔回異常  info.Delete(); // 刪除資料夾  // recursive 參數 true 表示刪除該目錄下所有資料夾與檔案  //info.Delete(true); } Directory 使用 Directory 類別建立資料夾\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別建立資料夾 /// \u0026lt;/summary\u0026gt; public static void CreateFolderByDirectory() { string path = @\u0026#34;D:\\Test\\Directory\u0026#34;; Directory.CreateDirectory(path); } 使用靜態類別讀取目錄下所有資料夾與檔案，或只讀取資料夾或檔案其一\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別讀取目錄下所有資料夾與檔案 /// \u0026lt;/summary\u0026gt; public static void ReadFolderByDirectory() { string path = @\u0026#34;D:\\\u0026#34;; // 讀取所有資料夾與檔案  string[] entries = Directory.GetFileSystemEntries(path); // 只讀取所有資料夾  //string[] directories = Directory.GetDirectories(path);  // 只讀取所有檔案  //string[] files = Directory.GetFiles(path);  foreach (string dir in entries) { Console.WriteLine(dir); } } 使用靜態類別檢查目錄是否存在\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別檢查目錄是否存在 /// \u0026lt;/summary\u0026gt; public static void IsFolderByDirectory() { string path = @\u0026#34;D:\\Test\u0026#34;; if (!Directory.Exists(path)) { Console.WriteLine(\u0026#34;目錄不存在\u0026#34;); } else { Console.WriteLine(\u0026#34;目錄已存在\u0026#34;); } } 使用靜態類別刪除目錄資料夾\n/// \u0026lt;summary\u0026gt; /// 使用靜態類別刪除目錄資料夾 /// \u0026lt;/summary\u0026gt; public static void DeleteFolderByDirectory() { string path = @\u0026#34;D:\\Test\u0026#34;; // 刪除資料夾，資料夾內必須為空，不得有任何檔案或資料夾，否則會扔回異常  Directory.Delete(path); // 刪除資料夾多載方法  // recursive 參數 true 表示刪除該目錄下所有資料夾與檔案  //Directory.Delete(path, true); } Path 使用 Path 取得虛擬路徑的完整路徑以及合併路徑\n/// \u0026lt;summary\u0026gt; /// Path 類別簡單應用 /// \u0026lt;/summary\u0026gt; public static void PathInfo() { string pathA = @\u0026#34;D:\\\u0026#34;; string pathB = @\u0026#34;Test.txt\u0026#34;; // 合併路徑  string combineResult = Path.Combine(pathA, pathB); Console.WriteLine(combineResult); // 取得虛擬路徑的完整路徑  string fullPath = Path.GetFullPath(@\u0026#34;.\\Test.txt\u0026#34;); Console.WriteLine(fullPath); } DriveInfo 使用 DriveInfo 類別取得所有磁碟機的相關資訊\n/// \u0026lt;summary\u0026gt; /// DriveInfo 簡單應用 /// \u0026lt;/summary\u0026gt; public static void DriveInfoUse() { // 取得所有磁碟機  DriveInfo[] drives = DriveInfo.GetDrives(); // 迭代所有磁碟機  foreach (var drive in drives) { if (drive.IsReady) { Console.WriteLine($\u0026#34;磁碟機名稱: {drive.Name}\u0026#34;); Console.WriteLine($\u0026#34;類型: {drive.DriveFormat}\u0026#34;); Console.WriteLine($\u0026#34;總容量: {drive.TotalSize}\u0026#34;); Console.WriteLine($\u0026#34;可用容量: {drive.AvailableFreeSpace}\u0026#34;); } Console.WriteLine(); } } Note 在網路上看到常用 IO 流的文章，覺得自己也應該要記錄起來，操作上非常簡單，觀念也易懂，也順便複習操作 I/O 流的部分。\nReference Basics of .NET Framework File I/O and the File System (Visual Basic)\nStream Class\nC# 常用 IO 流與讀寫文件\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/","summary":"在 .NET 框架中，命名空間 System.IO 已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西\n 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。\n流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。\nStart FileSystemInfo 類別是檔案系統類別的基礎類別，繼承該類別的子類別有\n File - 負責檔案系統中的檔案，屬靜態類別 FileInfo - 負責檔案系統中的檔案 Directory - 負責檔案系統中的資料夾，屬靜態類別 DirectoryInfo - 負責檔案系統中的資料夾  另外還有位於 System.IO 命名空間下其餘相關的類別\n Path - 負責檔案系統中的路徑 DriveInfo - 負責磁碟機資訊的訪問  File 與 FileInfo 的區別在於 Info 類別需要實體化，而一般 File 是屬於靜態類別；Directory 與 DirectoryInfo 同理，Directory 是靜態類別，DirectoryInfo 需實體化類別。\nFileInfo 使用 FileInfo 類別建立檔案，並且寫入資料\n/// \u0026lt;summary\u0026gt; /// 建立檔案並寫入資料 /// \u0026lt;/summary\u0026gt; public static void CreateFileByFileInfo() { // 實體化 FileInfo 並指予路徑  FileInfo file = new FileInfo(@\u0026#34;D:\\Test.","title":"【.NET】使用 C# 操作檔案 I/O 與檔案系統（一）"},{"content":"紀錄一項非常基本的常識。\nMS SQL 在預設的情況下執行查詢指令，會將結果訊息顯示在下方，如下圖\n其實在預設情況下也是可以在右下角看到執行時間，不過這個執行時間只能讀到秒。某天無意間看到別人在執行查詢指令時，在結果訊息視窗竟能印出詳細資訊，特別紀錄一下這非常簡單我卻不會的技能。\nStep 1 新增一個查詢視窗，在功能列表選擇查詢→查詢選項\nStep 2 左側選擇執行→進階，勾選【SET STATISTICS TIME】\nStep 3 左側選擇結果→文字，勾選【在結果集裡包含查詢】\nStep 4 執行查詢指令查看結果訊息\n非常簡單的操作，如果還想知道關於結果訊息的相關設定，也都在查詢選項裡面設置！\n","permalink":"https://fakestandard.github.io/post/mssql/mssql-2-setstatisticstime/","summary":"紀錄一項非常基本的常識。\nMS SQL 在預設的情況下執行查詢指令，會將結果訊息顯示在下方，如下圖\n其實在預設情況下也是可以在右下角看到執行時間，不過這個執行時間只能讀到秒。某天無意間看到別人在執行查詢指令時，在結果訊息視窗竟能印出詳細資訊，特別紀錄一下這非常簡單我卻不會的技能。\nStep 1 新增一個查詢視窗，在功能列表選擇查詢→查詢選項\nStep 2 左側選擇執行→進階，勾選【SET STATISTICS TIME】\nStep 3 左側選擇結果→文字，勾選【在結果集裡包含查詢】\nStep 4 執行查詢指令查看結果訊息\n非常簡單的操作，如果還想知道關於結果訊息的相關設定，也都在查詢選項裡面設置！","title":"【MSSQL】顯示 SQL 執行指令的時間"},{"content":"【ASP.NET Core 5】\n在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。\nStart 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup\u0026lt;T\u0026gt; 方法，其中泛型 \u0026lt;T\u0026gt; 預設為 Startup\npublic class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { // 配置啟動類別位置  webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup\u0026lt;T\u0026gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { // 新類名 MyStartup  webBuilder.UseStartup\u0026lt;MyStartup\u0026gt;(); }); 開啟 Startup.cs 該類別包含兩個公共方法\n ConfigureServices Configure  ConfigureServices ASP.NET Core 有個重要的觀念為依賴注入，或稱相依性注入也行，依賴注入全名為 Dependency Injection，簡稱為 DI，該依賴注入模式大量地在 ASP.NET Core 架構中使用，它包含內建的控制反轉 IoC 容器，該容器使用建構函數提供依賴對象。\n在 ConfigureServices 方法中註冊依賴類別，之後就可在應用程式中的任何位置隨心所欲地使用，ASP.NET Core 稱依賴類別為服務（Service），後續有提到服務時指的就是依賴類別。\n// This method gets called by the runtime. // Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { // Register dependent type(services) with IoC container here. } Configure 在 Configure 方法中，使用 IoC 容器提供的 IApplicationBuilder 實例來為應用程式加以配置 App 請求管道（request pipeline），Configure 用來指定應用程式對 HTTP 請求的回應方式，藉由 ASP.NET Core 引入的中介軟體（Middleware）來定義請求管道，各 Use 擴充方法會將中介軟體添加到管線中，如 app.UseStaticFiles() 是設定中介軟體可以提供靜態檔案，在請求管線內，每個中介軟體會負責調用管線中的下一個組件，所以應用程式只包含所需要的 Middleware 組件，從而提高應用程式的效能。\nConfigure 方法含有三個參數，分別為\n IApplicationBuilder IWebHostEnvironment ILoggerFactory  這些服務是由內建 IoC 容器注入的框架服務，運行時，在 Configure 方法之前調用 ConfigureServices 方法，如此一來便可在 IoC 容器中註冊自定義服務，並在 Configure 中使用。\n// This method gets called by the runtime. // Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.  app.UseHsts(); } // Configure HTTP request pipeline (middleware) here.  app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllerRoute( name: \u0026#34;default\u0026#34;, pattern: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); }); } Note 一開始說 Startup.cs 是用來配置應用程式的服務和請求管道，經由上述可更準確地了解\n Configure 方法用來定義請求管線中的中介軟體 ConfigureServices 方法用於定義應用程式所使用的服務，意即將服務註冊到 DI 容器中是在該方法處理  Reference App startup in ASP.NET Core\nASP.NET Core - Startup Class\n","permalink":"https://fakestandard.github.io/netcore/netcore5-1-startupclass/","summary":"【ASP.NET Core 5】\n在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。\nStart 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup\u0026lt;T\u0026gt; 方法，其中泛型 \u0026lt;T\u0026gt; 預設為 Startup\npublic class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { // 配置啟動類別位置  webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup\u0026lt;T\u0026gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.","title":"【.NET Core】Application Startup Class"},{"content":"在網站開發時，總會遇到匯出 EXCEL 的需求，除了匯出之外，偶爾也會遇到匯入 EXCEL 這種懶人需求。\n為何是懶人需求呢？通常使用者可以透過 UI 介面來維護資料，包括 CRUD 等功能，所以 Excel 資料會先透過前端介面在將資料傳遞到資料庫儲存。而匯入的方式，可以一次傳遞多筆資料，並且直達資料庫，過程中不需要使用 UI 介面逐筆輸入，非常省時又省力。\n註：此篇使用 ASP.NET Core 5 實作\nStart 首先到 NuGet 下載 NPOI 套件並安裝到專案中\n建立 ImportController.cs\npublic class ImportController : Controller { public IActionResult Index() { return View(); } } 建立 Index.cshtml\n\u0026lt;h2\u0026gt;Import\u0026lt;/h2\u0026gt; @using (Html.BeginForm(\u0026#34;Upload\u0026#34;, \u0026#34;Import\u0026#34;, FormMethod.Post, new { enctype = \u0026#34;multipart/form-data\u0026#34; })) { \u0026lt;input type=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; } 在 Controller 中新增一個接收 HttpPost 的 ActionResult Upload，除了返回頁面之外，沒有任何代碼。\n/// \u0026lt;summary\u0026gt; /// 上傳 Excel 方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult Upload(IFormFile file) { return View(\u0026#34;Index\u0026#34;); } 建立以副檔名來判斷要使用的 Workbook 實例私有方法\n/// \u0026lt;summary\u0026gt; /// 判斷副檔名以取得 Workbook 實例，直接讀取檔案內容 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;extension\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private IWorkbook GetWorkbook(string extension, IFormFile file) { MemoryStream ms = new MemoryStream(); file.CopyTo(ms); Stream stream = new MemoryStream(ms.ToArray()); switch (extension) { case \u0026#34;.xls\u0026#34;: return new HSSFWorkbook(stream); case \u0026#34;.xlsx\u0026#34;: return new XSSFWorkbook(stream); default: return null; } } 回到 Upload 方法撰寫讀取資料程式碼，最後，將讀到的資料作處理或解析，在把整理好的資料存入資料庫，這邊就不撰寫程式碼。\n/// \u0026lt;summary\u0026gt; /// 上傳 Excel 方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult Upload(IFormFile file) { try { if (file != null) { // 檢查 \u0026lt;input type=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; 是否選擇檔案  if (file.Length \u0026gt; 0) { // 取得副檔名  string extension = Path.GetExtension(file.FileName); // 取得 Workbook 實例  IWorkbook wb = GetWorkbook(extension, file); if (wb == null) { ViewBag.Message = \u0026#34;請上傳 .xls 或 .xlsx 的檔案！\u0026#34;; return View(\u0026#34;Index\u0026#34;); } // 取得第一個工作表  ISheet sheet = wb.GetSheetAt(0); // 取得標題列  IRow header = sheet.GetRow(0); // 走訪所有資料列(排除標題列)  for (int row = 1; row \u0026lt;= sheet.LastRowNum; row++) { // 驗證不是空白列  if (sheet.GetRow(row) != null) { // 走訪所有資料欄  for (int column = 0; column \u0026lt; header.LastCellNum; column++) { // 取得資料  var data = sheet.GetRow(row).GetCell(column).ToString(); // do something...  } } } ViewBag.Message = \u0026#34;上傳成功\u0026#34;; } else { ViewBag.Message = $\u0026#34;上傳失敗，檔案內無任何資料\u0026#34;; } } else { ViewBag.Message = \u0026#34;請選擇檔案！\u0026#34;; } } catch (Exception ex) { ViewBag.Message = $\u0026#34;上傳失敗，詳細原因:{ex.Message}\u0026#34;; } return View(\u0026#34;Index\u0026#34;); } 值得注意的幾個地方\n 檢查 \u0026lt;input type=\u0026quot;file\u0026quot; class=\u0026quot;form-control\u0026quot; name=\u0026quot;file\u0026quot; /\u0026gt; 是否有選擇檔案 取得索引為零的工作表，建議不直接用名稱取得工作表，除非有特別要求只讀取特定名稱的工作表，否則，優先建議用取得索引的方法來取得 ISheet 實例。 通常範例會包含標題，在讀取時記得要跳過第一行標題 使用 GetRow() 方法取得 Row 之後，要驗證取到的值是否為 Null  Note 使用第三方套件達成報表匯出匯入功能其實不難，了解整體脈絡後，不管是匯入或匯出，在使用上沒有太大的差別，只是處理取得資料或是返回資料的部分，就會要根據需求來撰寫。\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/","summary":"在網站開發時，總會遇到匯出 EXCEL 的需求，除了匯出之外，偶爾也會遇到匯入 EXCEL 這種懶人需求。\n為何是懶人需求呢？通常使用者可以透過 UI 介面來維護資料，包括 CRUD 等功能，所以 Excel 資料會先透過前端介面在將資料傳遞到資料庫儲存。而匯入的方式，可以一次傳遞多筆資料，並且直達資料庫，過程中不需要使用 UI 介面逐筆輸入，非常省時又省力。\n註：此篇使用 ASP.NET Core 5 實作\nStart 首先到 NuGet 下載 NPOI 套件並安裝到專案中\n建立 ImportController.cs\npublic class ImportController : Controller { public IActionResult Index() { return View(); } } 建立 Index.cshtml\n\u0026lt;h2\u0026gt;Import\u0026lt;/h2\u0026gt; @using (Html.BeginForm(\u0026#34;Upload\u0026#34;, \u0026#34;Import\u0026#34;, FormMethod.Post, new { enctype = \u0026#34;multipart/form-data\u0026#34; })) { \u0026lt;input type=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; } 在 Controller 中新增一個接收 HttpPost 的 ActionResult Upload，除了返回頁面之外，沒有任何代碼。","title":"【.NET】使用 NPOI 匯入 Excel"},{"content":"前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。\nStart 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下\nModel public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable\u0026lt;Export_ClosedXML.Models.Employee\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-success\u0026#34; asp-action=\u0026#34;csvExport\u0026#34;\u0026gt;csv Export\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026#34;table table-hover\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.ID) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.FirstName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.LastName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.City) \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var item in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.ID) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.FirstName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.LastName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.City) \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; OK. 前置作業準備完成。\n接著在 EmployeeController 添加一個 csvExport 的 Action，在動作方法內撰寫匯出的代碼，特別注意 ContentType 的部分是 text/csv，收工！\n/// \u0026lt;summary\u0026gt; /// 匯出 csv /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult csvExport() { try { StringBuilder sb = new StringBuilder(); // 取得類別的欄位名稱  var headerList = typeof(Employee).GetProperties().Select(m =\u0026gt; m.Name).ToList(); // 添加所有欄位  sb.AppendLine(String.Join(\u0026#39;,\u0026#39;, headerList)); // 添加內容  foreach (Employee employee in employees) { sb.AppendLine($\u0026#34;{employee.ID}, {employee.FirstName}, {employee.LastName}, {employee.Title}, {employee.City}\u0026#34;); } byte[] buffer = Encoding.UTF8.GetBytes(sb.ToString()); return File(buffer, \u0026#34;text/csv\u0026#34;, \u0026#34;EmployeeExport.csv\u0026#34;); } catch (Exception ex) { return File(Encoding.Unicode.GetBytes(ex.Message), \u0026#34;application/x-unknown\u0026#34;, \u0026#34;error.txt\u0026#34;); } } Reference Common MIME types\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/","summary":"前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。\nStart 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下\nModel public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable\u0026lt;Export_ClosedXML.","title":"【.NET】將資料匯出成 CSV"},{"content":"開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。\n這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub\n【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用\nStart 首先到 NuGet 安裝套件\nModel 建立資料模型\npublic class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料\npublic class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕\n@model IEnumerable\u0026lt;Export_ClosedXML.Models.Employee\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-success\u0026#34; asp-action=\u0026#34;Export\u0026#34;\u0026gt;Simple Export\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026#34;table table-hover\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.ID) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.FirstName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.LastName) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.City) \u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var item in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.ID) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.FirstName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.LastName) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.City) \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 截至目前為止資料的前置作業已完成，為了不做資料庫設定，這邊直接快速產生資料並呈現。\n下一步為匯出按鈕建立一個具有 HttpPost 的 Export 動作方法，記得引用命名空間 using ClosedXML.Excel;\n/// \u0026lt;summary\u0026gt; /// 匯出 Excel /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult Export() { try { // 取得類別的欄位名稱  var headerList = typeof(Employee).GetProperties().Select(m =\u0026gt; m.Name).ToList(); string contentType = \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;; //string contentType = \u0026#34;application/vnd.ms-excel\u0026#34;;  string fileName = \u0026#34;EmployeeExport.xlsx\u0026#34;; // 建立工作簿  IXLWorkbook wb = new XLWorkbook(); // 建立工作表  IXLWorksheet sheet = wb.Worksheets.Add(\u0026#34;Employee\u0026#34;); // 合併儲存格  sheet.Range(1, 1, 1, headerList.Count()).Merge(); sheet.Cell(1, 1).Value = \u0026#34;Employee Report\u0026#34;; // 樣式-背景色  sheet.Cell(1, 1).Style.Fill.SetBackgroundColor(XLColor.AppleGreen); // 字體大小  sheet.Cell(1, 1).Style.Font.SetFontSize(12); // 粗體  sheet.Cell(1, 1).Style.Font.SetBold(); // 水平垂直對齊方式  sheet.Cell(1, 1).Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Center; sheet.Cell(1, 1).Style.Alignment.Vertical = XLAlignmentVerticalValues.Center; // 標題列寫入 / ClosedXML 的 row 或 cell 都是從 1 開始  for (int i = 1; i \u0026lt;= headerList.Count(); i++) { sheet.Cell(2, i).Value = headerList[i - 1]; // 上框線  sheet.Cell(2, i).Style.Border.SetTopBorder(XLBorderStyleValues.Double); } // 內容寫入  for (int i = 1; i \u0026lt;= employees.Count(); i++) { sheet.Cell(i + 2, 1).Value = employees[i - 1].ID; sheet.Cell(i + 2, 2).Value = employees[i - 1].FirstName; sheet.Cell(i + 2, 3).Value = employees[i - 1].LastName; sheet.Cell(i + 2, 4).Value = employees[i - 1].Title; sheet.Cell(i + 2, 5).Value = employees[i - 1].City; } // 自適應欄寬  sheet.Columns().AdjustToContents(); using (MemoryStream ms = new MemoryStream()) { // 將檔案存入記憶流  wb.SaveAs(ms); // 記憶流轉換成 byte[]  var content = ms.ToArray(); return File(content, contentType, fileName); } } catch (Exception ex) { return File(System.Text.Encoding.Unicode.GetBytes(ex.Message), \u0026#34;application/x-unknown\u0026#34;, \u0026#34;error.txt\u0026#34;); } } 這樣就完成簡易的匯出，順便補充 ContentType 的對應\n   Extension ContentType     .xls application/vnd.ms-excel   .xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet    Reference ClosedXML\nCommon MIME types\nGitHub ClosedXML\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/","summary":"開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。\n這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub\n【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用\nStart 首先到 NuGet 安裝套件\nModel 建立資料模型\npublic class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料\npublic class EmployeeController : Controller { private List\u0026lt;Employee\u0026gt; employees; public EmployeeController() { if (employees == null) { employees = new List\u0026lt;Employee\u0026gt;() { new Employee{ ID = 1, LastName = \u0026#34;Davolio\u0026#34;, FirstName = \u0026#34;Nancy\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 2, LastName = \u0026#34;Fuller\u0026#34;, FirstName = \u0026#34;Andrew\u0026#34;, Title = \u0026#34;Vice President, Sales\u0026#34;, City = \u0026#34;Tacoma\u0026#34; }, new Employee{ ID = 3, LastName = \u0026#34;Leverling\u0026#34;, FirstName = \u0026#34;Janet\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Kirkland\u0026#34; }, new Employee{ ID = 4, LastName = \u0026#34;Peacock\u0026#34;, FirstName = \u0026#34;Margaret\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;Redmond\u0026#34; }, new Employee{ ID = 5, LastName = \u0026#34;Buchanan\u0026#34;, FirstName = \u0026#34;Steven\u0026#34;, Title = \u0026#34;Sales Manager\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 6, LastName = \u0026#34;Suyama\u0026#34;, FirstName = \u0026#34;Michael\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 7, LastName = \u0026#34;King\u0026#34;, FirstName = \u0026#34;Robert\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; }, new Employee{ ID = 8, LastName = \u0026#34;Callahan\u0026#34;, FirstName = \u0026#34;Laura\u0026#34;, Title = \u0026#34;Inside Sales Coordinator\u0026#34;, City = \u0026#34;Seattle\u0026#34; }, new Employee{ ID = 9, LastName = \u0026#34;Dodsworth\u0026#34;, FirstName = \u0026#34;Anne\u0026#34;, Title = \u0026#34;Sales Representative\u0026#34;, City = \u0026#34;London\u0026#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕","title":"【.NET】使用 ClosedXML 實現匯出 Excel 功能"},{"content":"【4/14 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。\n在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成\n 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。\n日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。\n對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。\nNote 特性\n 記憶體空間配置的儲存方式為不連續且隨機  優點\n 刪除或插入資料無須移動大量資料  缺點\n 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/","summary":"【4/14 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。\n在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成\n 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。\n日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。\n對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。\nNote 特性\n 記憶體空間配置的儲存方式為不連續且隨機  優點\n 刪除或插入資料無須移動大量資料  缺點\n 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】","title":"【Algorithm】資料結構—鏈結串列（Linked List）"},{"content":"【紀錄 2021/4/2-4/4】\n2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）\n這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～\n話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！\n因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。\n出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka \u0026amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。\n出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！\n第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。\n第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！\n沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」\n這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。\n敲敲打打的一行人\n因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。\n努力掛內帳的孩子\n第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！\n度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！\n麻辣鴛鴦鍋\n晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。\n山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！\n因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。\n無用配件\n冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD\n隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。\n第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。\n早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。\n專業備料\n專業煎牛排組\n羅宋湯 \u0026amp; 牛排\n結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！\n大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。\n打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。\n這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。\nW 老闆的下午茶\n時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。\n有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。\n到了晚餐時光，這一天吃飯彷彿接力賽，嘴巴也沒停過，不停的吃喝。晚餐直接選用前一晚的食材，直接涮起壽喜燒，壽喜燒的醬調配的挺好，值得回鍋購入。不過，好像沒有人有拍照，照片只好從缺。\n在收碗盤的過程中，朋友 B 買了營火，對男士而言，營火散發一種獨特魅力，會想待在營火旁，不停地看著，必要時燒個木柴，此趟也不免俗地來玩一下，營火還有個好處，晚上圍繞著它取暖超舒服。\n男士熱愛的營火\n收拾完，一行人念念不忘昨晚的獵巫，戀戰的他們，今晚，廝殺到三點…\n連續兩晚的獵巫鎮，過程中不斷地出現狼人術語，各種表水、對跳、高玩等等，一直出現要獵狼，你就是狼等等有關狼的話語，可獵巫的核心是女巫阿，這票人狼人殺中毒太深了！\n時光飛逝，來到第三日早晨，這天大夥隨意吃個早餐，吃完就要慢慢收拾，準備收心回家。\n最後，此趟所有餐點都與大夥共食，食材準備和烹飪部分以分工為主，不得不說，這次主廚團太強了，除了準備食材外，還附上各種美學的鍋碗瓢盆，五星級的擺盤技術，配上一流的專業攝影，口味的部分也讓人豎起大拇指讚賞一番！\n美學小物\n公共桌\n在詞彙有限的狀態下，想仔細紀錄每個細節，不小心寫得如此冗長，宛如露營，出發前準備的齊全，到頭來不一定都能派上用場，難道這就是所謂的甘願做歡喜受？\n","permalink":"https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/","summary":"【紀錄 2021/4/2-4/4】\n2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）\n這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～\n話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！\n因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。\n出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka \u0026amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。\n出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！\n第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。\n第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！\n沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」\n這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。\n敲敲打打的一行人\n因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。\n努力掛內帳的孩子\n第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！\n度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！\n麻辣鴛鴦鍋\n晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。\n山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！\n因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。\n無用配件\n冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD\n隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。\n第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。\n早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。\n專業備料\n專業煎牛排組\n羅宋湯 \u0026amp; 牛排\n結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！\n大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。\n打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。\n這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。\nW 老闆的下午茶\n時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。\n有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。","title":"【Life Trip】五峰星空下露營區"},{"content":"開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。\n代碼存放於 GitHub\nStart 首先到 NuGet 套件添加 NPOI Package\n建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable\n/// \u0026lt;summary\u0026gt; /// 資料庫連線方法 /// \u0026lt;/summary\u0026gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = \u0026#34;.\u0026#34;; cnsb.InitialCatalog = \u0026#34;Northwind\u0026#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = \u0026#34;SELECT * FROM [Northwind].[dbo].[Orders]\u0026#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.Fill(ds); // 將 DataSet 的資料倒入 DataTable  DataTable dt = ds.Tables[0]; return dt; } 引用命名空間\nusing NPOI; using NPOI.SS.UserModel; using NPOI.XSSF.UserModel; using NPOI.HSSF.UserModel; 匯出資料 建立 SimpleExport 方法，該方法具有兩個參數，\n DataTable ：要匯出的資料 path ：要匯出的目的地路徑  /// \u0026lt;summary\u0026gt; /// 匯出 Excel 簡易方法 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;dt\u0026#34;\u0026gt;要匯出的資料\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;path\u0026#34;\u0026gt;要匯出的目的地路徑\u0026lt;/param\u0026gt; static void SimpleExport(DataTable dt, string path) { // 建立工作簿  IWorkbook wb = new XSSFWorkbook(); // .xls  // IWorkbook wb = new HSSFWorkbook();  using (FileStream fs = File.Create(path)) { // 建立名為 Simple 的工作表  ISheet sheet = wb.CreateSheet(\u0026#34;Simple\u0026#34;); int i = 0; int j = 0; #region Title  // 建立新的 row 給標題用  sheet.CreateRow(0); for (i = 0; i \u0026lt; dt.Columns.Count; i++) { // 取得已建立的 row ，再建立 cell，最後再配置值給 cell  sheet.GetRow(0).CreateCell(i).SetCellValue(dt.Columns[i].ColumnName); } #endregion  #region Content  // 走訪 dt  for (i = 1; i \u0026lt;= dt.Rows.Count; i++) { sheet.CreateRow(i); for (j = 0; j \u0026lt; dt.Columns.Count; j++) { // 因為建立過的 row 或 cell 再次建立會覆蓋原有的值，所以建立過的物件使用 Get 取得再設置 Value  sheet.GetRow(i).CreateCell(j).SetCellValue(dt.Rows[i-1][j].ToString()); } } #endregion  // 將 wb 寫出到檔案流  wb.Write(fs); // 釋放資源  wb.Close(); wb = null; sheet = null; } } 該方法先建立工作簿（Workbook），工作簿下建立工作表（Sheet），接著建立資料行（row），資料行內建立單元格（cell），依此階層順序將資料填入到單元格內。\n值得注意一開始建立工作簿使用的 XSSFWorkbook 物件，該物件為操作 Excel 2007 開始且包含之後的版本，產出的副檔名為 .xlsx，相對的 HSSFWorkbook 物件為操作 Excel 97-2003 之間的版本，產出的副檔名為 .xls，建立工作簿時可依需求決定要產出版本。\n   Namespace Class Extension     NPOI.XSSF.UserModel XSSFWorkbook .xlsx   NPOI.HSSF.UserModel HSSFWorkbook .xls    版面設置 紀錄常用設置\n列印 紙張大小 sheet.PrintSetup.PaperSize = (short)PaperSize.A4;\n版面方向 sheet.PrintSetup.Landscape = true;\n 橫向：true 縱向：false  設置列印標題（上側）\nsheet.RepeatingRows = new NPOI.SS.Util.CellRangeAddress(fRow, lRow, fCol, lCol);\n fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  設置列印標題（左側）\nsheet.RepeatingColumns = new NPOI.SS.Util.CellRangeAddress(fRow, lRow, fCol, lCol);\n fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  頁尾頁碼 sheet.Footer.Center = \u0026quot;\u0026amp;P\u0026quot;;\n Left：靠左 Center：置中 Right：靠右  格線 顯示狀態 sheet.DisplayGridlines = true;\n 顯示：true 不顯示：false  欄寬和行高 設置欄寬大小 sheet.SetColumnWidth(0, 20 * 256);\n自動調整欄寬\nfor (i = 0; i \u0026lt; dt.Columns.Count; i++) { sheet.AutoSizeColumn(i); } 設置行高 sheet.GetRow(0).Height = 30 * 20;\n合併儲存格 CellRangeAddress region = new CellRangeAddress(fRow, lRow, fCol, lCol); sheet.AddMergedRegion(region);  fRow：開始的資料行 lRow：結束的資料行 fCol：開始的資料列 lCol：結束的資料列  儲存格樣式 先建立 XSSFCellStyle 物件\nXSSFCellStyle style = (XSSFCellStyle)wb.CreateCellStyle(); 多行文字(自動換行) style.WrapText = true;\n文字水平置中 style.Alignment = HorizontalAlignment.Center;\n文字垂直置中 style.VerticalAlignment = VerticalAlignment.Center;\n背景色 style.FillForegroundColor = new XSSFColor(Color.Red).Index;\n背景色樣式 style.FillPattern = FillPattern.SparseDots;\n框線樣式\n 上 style.BorderTop = BorderStyle.DashDot; 下 style.BorderBottom = BorderStyle.Double; 左 style.BorderLeft = BorderStyle.Hair; 右 style.BorderRight = BorderStyle.Thick;  框線顏色\n 上 style.TopBorderColor = new XSSFColor(Color.Chocolate).Index; 下 style.BottomBorderColor = new XSSFColor(Color.DarkOrange).Index; 左 style.LeftBorderColor = new XSSFColor(Color.Pink).Index; 右 style.RightBorderColor = new XSSFColor(Color.Purple).Index;  最後將自定義 Style 賦給單元格\nfor (i = 1; i \u0026lt; dt.Columns.Count; i++) { sheet.GetRow(0).GetCell(i).CellStyle = style; } 字體樣式 先建立 XSSFFont 物件\nXSSFFont font = (XSSFFont)wb.CreateFont(); 字體樣式 font.FontName = \u0026quot;Arial\u0026quot;;\n字體顏色 font.SetColor(new XSSFColor(Color.Blue));\n粗體 font.IsBold = true;\n斜體 font.IsItalic = true;\n刪除線 font.IsStrikeout = true;\n字體大小 font.FontHeightInPoints = 20;\n最後將自定義 Font 賦給自定義 Style\nstyle.SetFont(font); 凍結窗格 凍結頂端列 sheet.CreateFreezePane(0, 1, 0, 1);\n凍結左欄 sheet.CreateFreezePane(1, 0, 1, 0);\nReference https://github.com/nissl-lab/npoi\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/","summary":"開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。\n代碼存放於 GitHub\nStart 首先到 NuGet 套件添加 NPOI Package\n建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable\n/// \u0026lt;summary\u0026gt; /// 資料庫連線方法 /// \u0026lt;/summary\u0026gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = \u0026#34;.\u0026#34;; cnsb.InitialCatalog = \u0026#34;Northwind\u0026#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = \u0026#34;SELECT * FROM [Northwind].[dbo].[Orders]\u0026#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.","title":"【.NET】使用 NPOI 匯出 Excel 的基本應用"},{"content":"【4/11 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。\n靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。\n操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。\n陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。\n使用一維陣列尋找和儲存 1~num 之間的所有質數\nconst int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m \u0026lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i \u0026lt; num; i++) { if (prime[i]) { if (c == 10) { Console.WriteLine(); c = 0; } Console.Write(i + \u0026#34; \u0026#34;); c++; count++; } } Console.WriteLine(); Console.WriteLine($\u0026#34;總共 {count} 個質數\u0026#34;); 使用先前判斷質數的方法\nstatic bool IsPrime(int n) { int i = 2; while (i \u0026lt; n) { // 如果整除, i 為 n 的因數  if (n % i == 0) return false; i++; } return true; } 書籍撰寫代碼參考\nconst int MAX = 300; bool[] prime = new bool[MAX]; prime[0] = true; prime[1] = true; int num = 2, i; while (num \u0026lt; MAX) { if (!prime[num]) { for (i = num + num; i \u0026lt; MAX; i += num) { if (prime[i]) continue; prime[i] = true; } } num++; } for (i = 2, num = 0; i \u0026lt; MAX; i++) { if (!prime[i]) { Console.Write(i + \u0026#34;\\t\u0026#34;); num++; } } Console.WriteLine($\u0026#34;總共 {num} 個質數\u0026#34;); Note 特性\n 空間所配置的儲存方式為連續記憶體 提供索引功能 為靜態資料結構，編譯時必須先配置記憶體空間  優點\n 讀取和修改速度快  缺點\n 刪除和新增必須移動大量資料  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-3-array/","summary":"【4/11 閱讀紀錄】\n選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。\nStart 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下\n 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。\n靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。\n操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。\n陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。\n使用一維陣列尋找和儲存 1~num 之間的所有質數\nconst int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m \u0026lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i \u0026lt; num; i++) { if (prime[i]) { if (c == 10) { Console.","title":"【Algorithm】資料結構—陣列（Array）"},{"content":"【4/11 閱讀紀錄】\n此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。\nStart 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。\n一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。\n資料型態\n 基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）  記憶體儲存方式\n 靜態資料結構（Static data structure） 動態資料結構（Dynamic data structure）   資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。\n  基本資料型態（Primitive Data Type）\n基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。\n  結構化資料型態（Structured Data Type）\n結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。\n  抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。\n  記憶體儲存方式 若以記憶體儲存的方式來看資料結構，可以區分為兩種\n  靜態資料結構（Static data structure）\n靜態資料結構是將有序數列的資料，儲存於連續的記憶體空間，故在編譯時就得先配置記憶體空間，所以在初期須先宣告固定的記憶體空間，優點是連續記憶體設計時叫簡易，且讀取與修改任一元素的時間都是固定，缺點則是刪除或加入需要移動大量的資料，而最典型的靜態資料結構就是陣列。\n  動態資料結構（Dynamic data structure）\n動態資料結構是將有序數列的資料，儲存於不連續的記憶體空間，不須在編譯時先配置記憶體，因記憶體配置是發生在執行時，故能節省記憶體空間，在插入和刪除也相當方便，它不需要移動大量資料，缺點則是設計時較麻煩，讀取、修改或搜尋時，無法像靜態資料結構一樣直接取出資料，必須透過走訪找到目標資料為止。動態資料結構的代表是鏈結串列。\n  Reference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-2-datastructure/","summary":"【4/11 閱讀紀錄】\n此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。\nStart 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。\n一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。\n資料型態\n 基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）  記憶體儲存方式\n 靜態資料結構（Static data structure） 動態資料結構（Dynamic data structure）   資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。\n  基本資料型態（Primitive Data Type）\n基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。\n  結構化資料型態（Structured Data Type）\n結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。\n  抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。\n  記憶體儲存方式 若以記憶體儲存的方式來看資料結構，可以區分為兩種\n  靜態資料結構（Static data structure）\n靜態資料結構是將有序數列的資料，儲存於連續的記憶體空間，故在編譯時就得先配置記憶體空間，所以在初期須先宣告固定的記憶體空間，優點是連續記憶體設計時叫簡易，且讀取與修改任一元素的時間都是固定，缺點則是刪除或加入需要移動大量的資料，而最典型的靜態資料結構就是陣列。\n  動態資料結構（Dynamic data structure）\n動態資料結構是將有序數列的資料，儲存於不連續的記憶體空間，不須在編譯時先配置記憶體，因記憶體配置是發生在執行時，故能節省記憶體空間，在插入和刪除也相當方便，它不需要移動大量資料，缺點則是設計時較麻煩，讀取、修改或搜尋時，無法像靜態資料結構一樣直接取出資料，必須透過走訪找到目標資料為止。動態資料結構的代表是鏈結串列。\n  Reference 【圖說演算法 C#】","title":"【Algorithm】資料結構定義與資料型態"},{"content":"這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。\n一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。\n西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。\nSolution 有三種解決方案\n 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間\n引用命名空間\n System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $\u0026#34;{year}/{month}/{day}\u0026#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。\n/// \u0026lt;summary\u0026gt; /// 靜態擴展類別 /// \u0026lt;/summary\u0026gt; public static class DateTimeExtend { /// \u0026lt;summary\u0026gt;  /// 靜態擴展方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;dateTime\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; return $\u0026#34;{year}/{month}/{day}\u0026#34;; } } 替換當前執行緒的文化特性 不想在每次遇到時間時，才透過方法來轉換民國年與西元年，那直接設定執行緒的 Cultrue 最便利。\n引用命名空間\n System.Globalization System.Threading  // 指定 zh-TW CultureInfo culture = new CultureInfo(\u0026#34;zh-TW\u0026#34;); // 西曆 culture.DateTimeFormat.Calendar = new GregorianCalendar(); // 民國曆 //culture.DateTimeFormat.Calendar = new TaiwanCalendar();  // 將自建物件指給當前執行緒使用 Thread.CurrentThread.CurrentCulture = culture; Thread.CurrentThread.CurrentUICulture = culture; Console.WriteLine(DateTime.Now.ToShortDateString()); 由上列的代碼可以看到分別使用的物件為\n 西曆 GregorianCalendar 民國曆 TaiwanCalendar  在做轉換時，只需建立欲轉換的物件並指給 Culture，最後在將自訂的 Culture 指給執行緒使用，即可達到效果。\nNote 如何取得 DateTime 型別的日期部分？\nDateTime dateTime = new DateTime(2020, 2, 29); Console.WriteLine(dateTime.Date); 使用 Date 屬性，結案！\nReference TaiwanCalendar Class\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/","summary":"這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。\n一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。\n西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。\nSolution 有三種解決方案\n 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間\n引用命名空間\n System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $\u0026#34;{year}/{month}/{day}\u0026#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。\n/// \u0026lt;summary\u0026gt; /// 靜態擴展類別 /// \u0026lt;/summary\u0026gt; public static class DateTimeExtend { /// \u0026lt;summary\u0026gt;  /// 靜態擴展方法  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;dateTime\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.","title":"【.NET】西元年與民國年相互轉換"},{"content":"一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。\n首先要了解所得稅分為以下兩種\n 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）\n所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。\n收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。\n計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的\n綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額\n接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。\n所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。\n假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。\n那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！\n另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。\n免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人\n   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。\n標準扣除額 標準扣除額非常好理解，只分為兩種\n   身份 可扣除額度     單身者 120,000/人   已婚者 240,000/人    如果你是單身者，該項目就為 120,000，已婚者就是乘二為 240,000\n列舉扣除額 先說結論，標準扣除額和列舉扣除額兩者是擇一扣除，可以先試算兩者的金額，在選擇對自己有利的項目申報，選擇較高的金額作為扣除項目較有利。\n列舉扣除額有以下項目可申報\n 捐贈 保險 自宅 租屋 醫藥及生育費 災害損失  因為列舉扣除額包含的的項目較多，每個項目也就不一一說明，筆者大概看了一下，並在心中試算額度，比標準扣除額的 12 萬來的低，就不多花時間在此，詳細內容請參考下方的財政部連結。\n財政部稅務入口網-扣除額篇\n特別扣除額 該特別扣除額包含報稅的納稅義務人，若有配偶或受扶養親屬也適用下列條件\n   項目 扣除額 適用條件     薪資所得特別扣除額 200,000/人 有薪資收入者   身心障礙特別扣除額 200,000/人 具備身心障礙證明者   幼兒學前特別扣除額 120,000/人 育有學齡前幼兒   教育學費特別扣除額 25,000/人 受扶養子女就讀經教育部認可之國內外大專院校   儲蓄投資特別扣除額 270,000/戶 有金額機構存款利息、儲蓄性質信託資金等收益   長期照顧特別扣除額 120,000/人 符合身心失能條件    以筆者的情況來說，可以先扣除一人份的薪資所得 200,000，假設有配偶且具有薪資收入並一同申報，則可扣除兩人份的薪資所得扣除額 200,000 * 2 = 400,000，值得注意儲蓄投資特別扣除額是以每申報戶為單位，申報上限為 270,000，與先前扣除額不同之處是有多少計多少，假設去年度存款利息有 3,000，該項目應計入 3,000，以此類推。\n基本生活費差額 首先先計算基本生活費總額，每人以 175,000 計算，納稅義務人若同時有配偶和一位扶養眷屬，則基本生活費總額為 175,000 * 3 = 525,000。\n得知基本生活費總額之後，再計算基本生活費差額，公式為\n基本生活費差額 = 基本生活費總額 - 免稅額 - 一般(標準/列舉)扣除額 - 儲蓄投資特別扣除額 - 身心障礙特別扣除額 - 教育學費特別扣除額 - 幼兒學前扣除額 - 長期照顧特別扣除額\n看起來非常攏長，原因是特別扣除額的部分並非全部都能是減項，計算基本生活費差額時，「薪資所得特別扣除額」不能納入計算。\n如果基本生活費差額算出來為負數，則該項目金額則以 0 計算，反之，算出來為正數，則可從所得稅中扣除。\n綜合所得稅額級距與累進差額試算表 綜合所得稅淨額參考對應的稅率，計算應繳納稅額，計算公式為\n所得稅應納稅額 = 綜合所得淨額 * 稅率 - 累進差額\n根據上述林林總總所計算出的的綜合所得淨額，依照此公式及對應下表應有的級距，得以計算出當年度綜合所得稅額，就是今年度要繳納的稅額！\n   綜合所得淨額區間 適用稅率 累進差額     0 - 540,000 5% 0   540,001 - 1,210,000 12% 37,800   1,210,001 - 2,420,000 20% 134,600   2,420,001 - 4,530,000 30% 376,600   4,530,001 以上 40% 829,600    案例 小明是位年收 60 萬的單身貴族，沒有其他收入所得，也未有撫養的眷屬，他當年度的稅額計算方式為\n基本生活費差額 = ( 17.5 萬 - 8.8 萬 - 12 萬) = -3.3 萬，所以該項目以 0 計算\n綜合所得淨額 = 薪資所得 60 萬 - 免稅額 8.8 萬 - 標準扣除額 12 萬 - 薪資所得特別扣除額 20 萬 - 基本生活費差額 0 萬 = 19.2 萬\n所得稅應納稅額 = 19.2 萬 * 稅率 5% - 累進差額 0 = 9,600\n此案例的小明最終須繳交 9,600 元的個人綜合所得稅。\n最後，筆者也算出今年度需要繳納的稅額，因為也沒什麼好扣的，計算方式同上案例非常簡單，但看到要繳納的金額，覺得心在淌血…（哭）\n","permalink":"https://fakestandard.github.io/post/other/other-2-incometax/","summary":"一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。\n首先要了解所得稅分為以下兩種\n 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）\n所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。\n收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。\n計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的\n綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額\n接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。\n所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。\n假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。\n那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！\n另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。\n免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人\n   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。","title":"【人森】如何計算個人綜合所得稅？"},{"content":"Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。\n還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。\nSolution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！\n","permalink":"https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/","summary":"Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。\n還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。\nSolution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！","title":"【Windows】開啟運行程式的所在資料夾位置"},{"content":"此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。\nUI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。\n代碼部分已上傳到 GitHub\nStart  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。\nVisual Studio IDE 建立 【ASP.NET Core Web 應用程式】\n選擇 【ASP.NET Core Web 應用程式(Model-View-Controller)】\n下拉選單選擇 .Net Core 和 ASP.NET Core 5.0\n執行 Ctrl + F5 啟動 IIS Express 以執行應用程式，並且不執行偵錯。不啟用偵錯工作的好處是可隨時變更程式碼並且隨時儲存，當程式碼變更可重新整理瀏覽器快速查看。\n觀察瀏覽器網址列顯示 localhost:{port}，本機電腦的 hostname 為 localhost，{port} 是當 Visual Studio 建立 Web project 時，會自動分配一個隨機通訊埠號給網頁伺服器。\nCommand Shell 開啟終端機或 VS Code 終端機，切換到欲新增專案的目錄\n在當前目錄建立新的 ASP.NET Core MVC 專案\n$ dotnet new mvc -o MvcMovie 如果是使用 VS Code，下列指令可在 VS Code 直接載入 MvcMovie.csproj 專案檔\n$ code -r MvcMovie 信任 Https 開發憑證\n$ dotnet dev-certs https --trust 接著同上述執行 Ctrl + F5 啟動應用程式，詳細內容請往回參考。\n新增控制器（Controller） 在方案總管中，對 Controllers 資料夾執行右鍵→選擇加入→控制器。\n選擇【MVC 控制器 - 空白】\n將控制器名稱更改為 HelloWorldController.cs，並且新增。\n此時啟動應用程式瀏覽 https://localhost:{Port}/HelloWorld/ 會返回錯誤，因為我們還沒建立檢視器（View）。\n新增檢視器（View） 建立檢視器方法有兩種，一種是從方案總管中建立，一種是快速建立。筆者推薦使用快速建立。\n方案總管 對 Views 資料夾執行右鍵→加入→資料夾，該資料夾名稱命名為欲建立 View 的控制器名稱，這邊將它命名為 HelloWorld。\n對新增的 HelloWorld 資料夾，執行右鍵→加入→檢視，選擇 Razor 檢視 - 空白。\nView 的名稱應命名為控制器之動作方法名稱，與動作方法與之對應。開啟 HelloWorldController.cs 可以看見預設建立的 Index() 動作方法，該方法就是這次要建立檢視器的名稱 Index.cshtml。\n快速建立 開啟 HelloWorldControll.cs，在 Index() 方法上執行右鍵，選擇新增檢視。接著就與上述建立方法相同，選擇 Razor 檢視 - 空白，建立名為 Index.cshtml 檢視器。\n變更檢視及版面配置 打開剛剛建立的 View 修改代碼以變更呈現內容\n\u0026lt;!--index.cshtml--\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Index\u0026#34;; } \u0026lt;h2\u0026gt;Index\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Hello from our View Template!\u0026lt;/p\u0026gt; 在版面配置中添加 HelloWorld Controller 的導航配置，開啟 Views/Shared/_Layout.cshtml 找到配置導航的位置添加以下代碼\n\u0026lt;div class=\u0026#34;navbar-collapse collapse d-sm-inline-flex justify-content-between\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav flex-grow-1\u0026#34;\u0026gt; ... \u0026lt;!--要添加的代碼--\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;HelloWorld\u0026#34; asp-action=\u0026#34;Index\u0026#34;\u0026gt;HelloIndex\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;!--先添加 Movies，後續在新增 Movies Controller--\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34;\u0026gt;Movies\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 效果\n新增模型（Model） 模型以實際層面來說即是類別，建立模型實際動作就是建立一個類別，將建立的類別作為 Model 使用。\nEntity Framework Core（EF Core） 是一種物件關聯式架構（Object-relational mapping, ORM），在撰寫資料存取的代碼時，透過 ORM 可簡化這些代碼。所以你可以將類別與 EF Core 搭配使用以操作資料庫。\n這些自行建立的類別被稱為 POCO（Plain Old CLR Objects），因為它們只定義儲存在資料庫中的資料屬性，對 EF Core 不具有任何相依性。\n建立類別 在 Models 資料夾執行右鍵→選擇加入→類別，將類別命名為 Movie.cs，在類別內添加下列代碼\nusing System; using System.ComponentModel.DataAnnotations; namespace CoreMVCMovieList.Models { public class Movie { public int Id { get; set; } public string Title { get; set; } [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } public string Genre { get; set; } public decimal Price { get; set; } } } 新增 NuGet 套件 在 ASP.NET Core 中欲使用 Entity Framework Core 需安裝 Microsfot.EntityFrameworkCore Package，使用下列指令來安裝套件\n$ dotnet add package Microsoft.EntityFrameworkCore EF 通常都是搭配 SQL Server，開啟套件管理器主控台，執行下列指令，以添加 EF Core SQL Server Provider\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer 建立 DbContext DbContext 類別為 EF Core 與資料庫的溝通橋樑，在專案下建立 MvcMovieContext.cs 類別，並繼承 DbContext 類別以定義與資料庫的溝通行為，同時建立 DbSet\u0026lt;Movie\u0026gt;　實體集（Entity Set）。\n在 Entity Framework 下，通常實體集（Entity Set）對應於資料表，實體（Entity）對應於資料表中的資料列，EF Core 會自動幫我們轉換實體集與實體的部分。\nusing CoreMVCMovieList.Models; using Microsoft.EntityFrameworkCore; namespace CoreMVCMovieList { public class MvcMovieContext : DbContext { public MvcMovieContext(DbContextOptions\u0026lt;MvcMovieContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Movie\u0026gt; Movie { get; set; } } } 新增 ConnectionString 以往應用程式有 app.config 可以設定，Web 則有 web.config 可以設置連線字串，在 .Net Core 下 .config 配置文件已經消失，改成使用 JSON 格式的 appsettings.json 配置相關設定。\n添加 ConnectionString 節點的代碼\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;MvcMovieContext\u0026#34;: \u0026#34;Server=(localdb)\\\\mssqllocaldb;Database=MvcMovieContext;Trusted_Connection=True;MultipleActiveResultSets=true\u0026#34; } } 註冊 DbContext ASP.NET Core 建構於相依性注入（Dependency Injection, DI）概念，所有服務必須在應用程式啟動期間向 DI 進行註冊，透過建構函數提供服務給需要服務的元件（如 Razor Page），開啟 Startup.cs 向 DI 容器註冊 DbContext。\n// 添加引用 using MvcMovie.Data; using Microsoft.EntityFrameworkCore; public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews(); // DI 注入  services.AddDbContext\u0026lt;MvcMovieContext\u0026gt;(options =\u0026gt; options.UseSqlServer(Configuration.GetConnectionString(\u0026#34;MvcMovieContext\u0026#34;))); } 在 DbContextOptions 物件上調用方法將連線字串傳遞到 context，而在目前開發中，ASP.NET Core Configuration System 會從 appsetting.json 來取得連線字串。\n使用 Scaffold 在方案總管對 Controllers 資料夾執行右鍵→加入→選擇 新增 Scaffold 項目\n選擇 使用 Entity Framework 執行檢視的 MVC 控制器\n將模型類別與資料內容類別 調整為與下圖相同選項，並勾選檢視的三個複選框，控制器名稱為預設。\n此時已添加 MoviesController.cs 該控制下項已經添加所有 CRUD 等動作方法（Action），但目前未能使用該頁面，因為資料庫還不存在，下一步我們將會建立資料庫。\n 如果使用 Scaffold 建立失敗\n嘗試到 NuGet 安裝 Microsoft.VisualStudio.Web.CodeGeneration.Utils\n 進行初始移轉（Initial Migration） 使用 EF Core 的遷移功能來建立資料庫，Migration 可建立和更新與資料模型相符的資料庫。在套件管理器主控台輸入下列命令\n產生 /{timestamp}_InitialCreate.cs 遷移檔案，因為是第一次移轉，所以產生的類別會以 MvcMovieContext 類別的資料庫結構為基礎。\nAdd-Migration InitialCreate 此命令會執行 Migrations/{time-stamp}_InitialCreate.cs 檔案中的 Up 方法，以建立資料庫。\nUpdate-Database 此時可以啟動應用程式操作新增、刪除、修改等方法，可以發現在執行 CRUD 時都會使用到資料庫，因為在建立 MoviesController.cs 時，已經添加下列的建構函式，然而先前在 DI 容器中已註冊 MvcMovieContext，所以在 Controller 的建構子就可透過 DI 來取得 Context 實例。\nprivate readonly MvcMovieContext _context; public MoviesController(MvcMovieContext context) { _context = context; } 植入資料以初始資料庫 在 Models 資料夾下建立 SeedData.cs 類別，在類別內添加下列代碼\npublic static class SeedData { public static void Initialize(IServiceProvider serviceProvider) { using (var context = new MvcMovieContext( serviceProvider.GetRequiredService\u0026lt; DbContextOptions\u0026lt;MvcMovieContext\u0026gt;\u0026gt;())) { // Look for any movies.  if (context.Movie.Any()) { return; // DB has been seeded  } context.Movie.AddRange( new Movie { Title = \u0026#34;When Harry Met Sally\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1989-2-12\u0026#34;), Genre = \u0026#34;Romantic Comedy\u0026#34;, Price = 7.99M }, new Movie { Title = \u0026#34;Ghostbusters \u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1984-3-13\u0026#34;), Genre = \u0026#34;Comedy\u0026#34;, Price = 8.99M }, new Movie { Title = \u0026#34;Ghostbusters 2\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1986-2-23\u0026#34;), Genre = \u0026#34;Comedy\u0026#34;, Price = 9.99M }, new Movie { Title = \u0026#34;Rio Bravo\u0026#34;, ReleaseDate = DateTime.Parse(\u0026#34;1959-4-15\u0026#34;), Genre = \u0026#34;Western\u0026#34;, Price = 3.99M } ); context.SaveChanges(); } } } 其中這段代表植入資料前，先判斷資料庫中是否已經資料，沒有資料才初始化資料，有的話直接返回，不新增任何資料。\n// Look for any movies. if (context.Movie.Any()) { // DB has been seeded  return; } 開啟 Program.cs 新增初始設定，將 Main 方法內的原始代碼替換成下列代碼\npublic class Program { public static void Main(string[] args) { // CreateHostBuilder(args).Build().Run();  var host = CreateHostBuilder(args).Build(); using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; try { SeedData.Initialize(services); } catch (Exception ex) { var logger = services.GetRequiredService\u0026lt;ILogger\u0026lt;Program\u0026gt;\u0026gt;(); logger.LogError(ex, \u0026#34;An error occurred seeding the DB.\u0026#34;); } } host.Run(); } ... } 啟動應用程式，查看上述的設定，資料庫在有資料的情況下，不做新增資料的動作，將所有資料刪除使得資料庫資料為零，這時再啟動應用程式會發現，資料庫會新增預設的資料。\n使用資料註釋 Data Annotations 目前清單的標題列上顯示的是 Model 的名稱，使用 Data Annotations 來變更顯示名稱。開啟 Models/Movie.cs 替換成下列代碼\n// 需引用的命名空間 using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; ... public class Movie { public int Id { get; set; } [Display(Name = \u0026#34;電影名稱\u0026#34;)] public string Title { get; set; } [Display(Name = \u0026#34;放映日期\u0026#34;)] [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } [Display(Name = \u0026#34;類型\u0026#34;)] public string Genre { get; set; } [Display(Name = \u0026#34;價格\u0026#34;)] [Column(TypeName = \u0026#34;decimal(18, 2)\u0026#34;)] public decimal Price { get; set; } } 結果如下\n新增搜尋引擎 目前的清單沒有搜尋引擎，當資料量一多，一頁頁的翻找會很耗時，接下來我們要新增一個搜尋引擎，讓使用者可以搜尋「電影名稱」、「類型」以快速查找。\n搜尋電影名稱 開啟 Vies/Movies/Index.cshtml 添加下列 \u0026lt;form\u0026gt;...\u0026lt;/form\u0026gt; 代碼\n\u0026lt;p\u0026gt; \u0026lt;a asp-action=\u0026#34;Create\u0026#34;\u0026gt;Create New\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!--要添加的代碼--\u0026gt; \u0026lt;form asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 電影名稱: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;SearchString\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Filter\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!--End--\u0026gt; \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; ... 開啟 MoviesController.cs 變更 Index 動作方法\n[HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Index(string searchString) { // LINQ 查詢  var movies = from m in _context.Movie select m; if (!String.IsNullOrEmpty(searchString)) { movies = movies.Where(k =\u0026gt; k.Title.Contains(searchString)); } return View(await movies.ToListAsync()); } 效果\n搜尋類型 搜尋類型要以下拉選單的方式呈現，因此先新增 ViewModels 資料夾，再資料夾下新增 MovieGenerViewModel.cs 類別\npublic class MovieGenerViewModel { public List\u0026lt;Movie\u0026gt; Movies { get; set; } public SelectList Genres { get; set; } public string MovieGenre { get; set; } public string SearchString { get; set; } } 進一步修改剛剛的 MoviesController.cs 的 Index 方法\npublic async Task\u0026lt;IActionResult\u0026gt; Index(string movieGenre, string searchString) { var movies = from m in _context.Movie select m; if (!String.IsNullOrEmpty(searchString)) { movies = movies.Where(k =\u0026gt; k.Title.Contains(searchString)); } if (!string.IsNullOrEmpty(movieGenre)) { movies = movies.Where(k =\u0026gt; k.Genre == movieGenre); } // LINQ 取類型資料  IQueryable\u0026lt;string\u0026gt; genreQuery = from m in _context.Movie orderby m.Genre select m.Genre; var movieGenreVM = new MovieGenerViewModel { Genres = new SelectList(await genreQuery.Distinct().ToListAsync()), Movies = await movies.ToListAsync() }; return View(movieGenreVM); } 更新 Views/Movies/Index.cshtml\n\u0026lt;!--將原本傳入的 Model 替換成 MovieGenerViewModel--\u0026gt; @model CoreMVCMovieList.ViewModels.MovieGenerViewModel ... \u0026lt;form asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;!--添加下拉選單--\u0026gt; \u0026lt;select asp-for=\u0026#34;MovieGenre\u0026#34; asp-items=\u0026#34;Model.Genres\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;All\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;!--End--\u0026gt; 電影名稱: \u0026lt;input type=\u0026#34;text\u0026#34; asp-for=\u0026#34;SearchString\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Filter\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; ... \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--因傳入的 Model 結構不同，所以將原本 model.Title 替換成 model.Movies[0].Title--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Title) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].ReleaseDate) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Genre) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt; \u0026lt;!--同理--\u0026gt; @Html.DisplayNameFor(model =\u0026gt; model.Movies[0].Price) \u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; ... \u0026lt;!--同理將要走訪的數組改為 Model.Movies--\u0026gt; @foreach (var item in Model.Movies) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; @Html.DisplayFor(modelItem =\u0026gt; item.Title) \u0026lt;/td\u0026gt; ... \u0026lt;/tr\u0026gt; } 觀察效果\n新增資料驗證 使用 DataAnnotations Namespace 提供的的驗證屬性，套用到類別或屬性中，開啟 Movie 類別，將 Required、StringLength、RegularExpression、Range 添加到各個屬性上\npublic class Movie { public int Id { get; set; } [Required] [StringLength(60, MinimumLength =3)] [Display(Name = \u0026#34;電影名稱\u0026#34;)] public string Title { get; set; } [Display(Name = \u0026#34;放映日期\u0026#34;)] [DataType(DataType.Date)] public DateTime ReleaseDate { get; set; } [Required] [RegularExpression(@\u0026#34;^[A-Z]+[a-zA-Z]*$\u0026#34;)] [Display(Name = \u0026#34;類型\u0026#34;)]  public string Genre { get; set; } [Range(1, 100)] [DataType(DataType.Currency)] [Display(Name = \u0026#34;價格\u0026#34;)] [Column(TypeName = \u0026#34;decimal(18, 2)\u0026#34;)] public decimal Price { get; set; } } 啟動應用程式新增一筆資料，在未填任何資料的情況下按下「新增」按鈕，觀察結果，同樣在編輯頁面若資料不符合驗證規則，會有錯誤提示產生。\n使用 Bootstrap 增強外觀效果 最後一步，由於 .NET Core 已經不會內建樣式，要添加 Bootstrap 等套件需自行到 NuGet 添加，這邊隨手添加一下 Bootstrap 的 Button 及 Table 樣式，使得外觀好看一點。\n完成！\nNote 在 Step by step 過程中，實作的部分很快就能完成，其中有很多原理必須深入研究，待研究有心得再來記錄。\nReference Part 1 - Get started with ASP.NET Core MVC\nPart 2 - Add a controller to an ASP.NET Core MVC app\nPart 3 - Add a view to an ASP.NET Core MVC app\nPart 4 - Add a model to an ASP.NET Core MVC app\nPart 5 - Work with a database in an ASP.NET Core MVC app\nPart 6 - Controller methods and views in ASP.NET Core\nPart 7 - Add search to an ASP.NET Core MVC app\nPart 8 - Add a new field to an ASP.NET Core MVC app\nPart 9 - Add validation to an ASP.NET Core MVC app\nPart 10 - Examine the Details and Delete methods of an ASP.NET Core app\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/","summary":"此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。\nUI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。\n代碼部分已上傳到 GitHub\nStart  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。\nVisual Studio IDE 建立 【ASP.NET Core Web 應用程式】","title":"【.NET】適合初心者的 .NET Core MVC 實作"},{"content":"【3/28 閱讀紀錄】\n此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。\nStart 演算法種類很多，經典的演算法有以下幾種\n 分治演算法（Divide and conquer） 迭代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Enumeration Algorithm） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。\n像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。\n然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。\n所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。\n迭代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為迭代演算法，像是透過迴圈去循環重複的程式碼來得到答案。\n舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果\n// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { sum = sum * j; } Console.WriteLine($\u0026#34;{i} != {sum}\u0026#34;); // 重設計算結果  sum = 1; } 執行結果\n1!=1 2!=2 3!=6 4!=24 5!=120 除了上述介紹固定執行次數的迭代法之外，還可以使用 while 迴圈，來執行不確定執行次數的迭代法。使用 while 迴圈必須注意不可讓迴圈一直循環，若執行無法停止就會導致「無窮迴圈」，所以 while 迴圈結構需要具備三個條件\n 變數初始值 迴圈條件式 調整變數增減值  設置一個變數初始值使迴圈得以開始，明確設置迴圈條件式，在符合該條件下迴圈得以循環執行，最終一定要調整變數增減值做為可以離開迴圈的出口。\n// 變數出使值 int i = 1; // 迴圈條件式 while (i \u0026lt;= 10) { Console.WriteLine(i); // 調整變數增減值  i += 1; } 巴斯卡三角形 也是經典中之一，這邊不做進一步介紹。\n遞迴演算法（Recursion Algorithm） 遞迴演算法跟迭代演算法在循環上相似，卻又跟分治演算法的概念類似，遞迴法與分治法相同地將大問題拆解成小問題來解決，又跟迭代法的循環有異曲同工之妙。\n在程式設計裡，設計一種方法並將其封裝起來稱為函數或副程式，通過外部來呼叫函數或副程式執行封裝後的代碼，以定義而言，透過自己來呼叫自己的過程稱為遞迴，可以想像為函數內部又在調用一次函數。遞迴必須具備兩個條件\n 可以反覆執行的程式碼 結束執行過程的出口  遞迴的經典範例「階乘」，階乘的運算式 n! = n*(n-1)*(n-2)...*1，透過階乘運算過程可觀察出一定的規律性，就可以使用遞迴演算法來達成\nstatic int Function(int n) { if (n == 0) // 終止的條件  return 1; else return n * Function(n - 1); // 遞迴呼叫自己 } 經典的費伯那序列（Fibonacci Polynomial）\n參照上圖公式，n 為正整數，第零項為 0、第一項為 1、第二項為本身前兩項的值相加所得，第二項可得 1、第三項為 2，以此類推。找出規律後可嘗試設計出遞迴程式。\nstatic int Fibonacci(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2); } 動態規劃演算法（Dynamic Programming Algorithm） 動態規劃演算法（DPA）與分治法十分相似，先將大問題拆解成小問題，不同的是動態規劃演算法將每個子問題的答案儲存起來，以供下次求解時直接取用，減少相同子問題再次被計算的時間，所以動態規劃法解決了重複計算的缺點。\n依據上述提到的費伯那序列，從上面的路徑圖看到 Fib[2] 被計算過兩次，透過動態規劃演算法將第一次 Fib[2] 的計算結果儲存於陣列，第二次要計算時就可直接從陣列取出結果，不用再計算一次。上述明顯地得知，將每次的計算結果先儲存，供後續使用，以減少效能開銷是其演算法之精神。\n改良先前的費伯那序列代碼\n// 計算結果暫存區 static int[] output = new int[100]; static int Fibonacci(int n) { int result; result = output[n]; if (result == 0) { if (n == 0) result = 0; else if (n == 1) result = 1; else result = (Fibonacci(n - 1) + Fibonacci(n - 2)); } // 將計算結果儲存到暫存區  output[n] = result; return result; }  2021/6/5 改良空間複雜度為 O(1)\n static int Fibonacci(int n) { if (n \u0026lt;= 0) return 0; if (n \u0026lt;= 2) return n; int f1 = 1; int f2 = 2; int result = 0; for(int i = 2; i \u0026lt; n; i++) { result = f1 + f2; f1 = f2; f2 = result; } return f2; } 枚舉演算法（Enumeration Algorithm） 又稱窮舉法，一種常見的數學基礎方法，高頻率的在日常生活中使用到，主要核心概念為依據問題需求，逐一枚舉出所有解答，達到解決問題的目的，缺點為速度太慢。\n舉例：當 1000 依次減去 1,2,3\u0026hellip;直到結果為負數，代碼如下\nint num = 1000; int count = 0; while (num \u0026gt;= 0) { count++; num -= count; } Console.WriteLine(count); 上述範例中可看到，每執行一次相減就檢查結果是否為負數，在不遺漏的情況下，一一枚舉出所有項目，在從枚舉的項目中找到自己所需的項目。\n再舉個例：從 1-500 之間列舉出所有 3 的倍數的整數\nfor (int num = 0; num \u0026lt;= 500; num++) { if (num % 3 == 0) Console.WriteLine(num); } 枚舉演算法還有一個經典題型，如何得知某數是否為質數，在此推薦使用 Eratosthenes 方法，將某數逐一除以 2 至某數減一之間的所有數字，若有其中一個可以整除，就能斷定某數是否為質數。\nstatic bool IsPrime(int n) { int i = 2; while (i \u0026lt; n) { // 如果整除, i 為 n 的因數  if (n % i == 0) return false; i++; } return true; } 貪心演算法（Greedy Algorithm） 貪心演算法又稱貪婪演算法，主要核心概念如同名稱一樣，在每個解決問題的步驟遵循貪心原則，採取最有利或最優化的選項，意即只求局部解決辦法，而不考慮大局影響，不斷改進解答。\n雖然貪心演算法都是選擇當前最有利，但不能保證最終結果也是最佳的，因為貪心法在原理上容易過早做決定，此演算法很適合用來尋找最短路徑或是機器學習等方面。\n回溯演算法（Backtracking Algorithm） 最後一個回溯演算法也是枚舉法的一種，顧名思義為步驟可回溯的概念，當枚舉出不正確答案時，可以透過回溯來回到上一層，接著找尋出尚未執行過的路徑，再遞迴至下一層。\n老鼠走迷宮就是經典例子，利用二維陣列模擬出一個迷宮，而老鼠行進時遵循以下三個原則\n 一次只能走一格 遇到牆壁無法前行時，則退回到上一步尋找其他可走路徑 走過的路不再走第二遍  二維陣列的迷宮規則為\nMaze[i][j] = 1 --表示該位置為牆壁，無法通行 Maze[i][j] = 0 --表示該位置為不為牆壁，可前行 Maze[1][1] --該處為入口 Maze[m][n] --該處為出口 虛擬碼解析迷宮搜尋概念\nif (上一格可走) { 加入方格編號到堆疊; 往上走; 判斷是否為出口; } else if (下一格可走) { 加入方格編號到堆疊; 往下走; 判斷是否為出口; } else if (左一格可走) { 加入方格編號到堆疊; 往左走; 判斷是否為出口; } else if (右一格可走) { 加入方格編號到堆疊; 往右走; 判斷是否為出口; } else { 從堆疊中刪除一個方格編號; 從堆疊中取出一個方格編號; 往回走; } 實際代碼\n建立座標類別\n/// \u0026lt;summary\u0026gt; /// 座標 /// \u0026lt;/summary\u0026gt; public class Node { public int X { get; set; } public int Y { get; set; } public Node(int x, int y) { this.X = x; this.Y = y; } } 建立記錄路經追蹤的類別\n/// \u0026lt;summary\u0026gt; /// 紀錄追蹤路徑類別 /// \u0026lt;/summary\u0026gt; public class TraceRecord { public Node[] nodes = new Node[120]; public Node Pre; public int num = 1; public bool IsEmpty() { return nodes[0] == null; } // 新增路徑到堆疊  public void Insert(int x, int y) { Node newNode = new Node(x, y); if (this.IsEmpty()) // 剛從入口出發  { nodes[0] = newNode; } else { num = num + 1; nodes[num] = newNode; } } // 刪除堆疊中的路徑  public void Delete() { if (this.IsEmpty()) { Console.WriteLine(\u0026#34;佇列已經空了\u0026#34;); return; } nodes[num] = null; num = num - 1; Pre = nodes[num]; } } 建立檢查出口的方法\npublic static bool ChkExit(int x, int y, int ex, int ey) { if (x == ex \u0026amp;\u0026amp; y == ey) return true; return false; } 開始前的預定義\n// 定義出口 X 座標 public static int ExitX = 8; // 定義出口 Y 座標 public static int ExitY = 10; // 定義二維陣列迷宮 public static int[,] Maze = { { 1,1,1,1,1,1,1,1,1,1,1,1 }, { 1,0,0,0,1,1,1,1,1,1,1,1 }, { 1,1,1,0,1,1,0,0,0,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,0,0,0,0,1,1,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,0,1,1,0,1,1,0,1,1 }, { 1,1,1,1,1,1,0,1,1,0,1,1 }, { 1,1,0,0,0,0,0,0,1,0,0,1 }, { 1,1,1,1,1,1,1,1,1,1,1,1 } }; Main 方法\nstatic void Main(string[] args) { int i, j; int x = 1; int y = 1; TraceRecord path = new TraceRecord(); Console.WriteLine(\u0026#34;迷宮路徑\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 12; j++) { Console.Write(Maze[i, j]); } Console.WriteLine(); } Thread.Sleep(1000); Console.WriteLine(\u0026#34;\\n老鼠開始走迷宮...\\n\u0026#34;); while (x \u0026lt;= ExitX \u0026amp;\u0026amp; y \u0026lt;= ExitY) { // 將當前路徑設置成已經走過  Maze[x, y] = 2; if (Maze[x - 1, y] == 0) // 左邊  { x -= 1; path.Insert(x, y); } else if (Maze[x + 1, y] == 0) // 右邊  { x += 1; path.Insert(x, y); } else if (Maze[x, y - 1] == 0) // 下方  { y -= 1; path.Insert(x, y); } else if (Maze[x, y + 1] == 0) // 上方  { y += 1; path.Insert(x, y + 1); } else if (ChkExit(x, y, ExitX, ExitY)) // 判斷是否為出口  { break; } else // 遇到死路  { path.Delete(); x = path.Pre.X; y = path.Pre.Y; } } Thread.Sleep(1000); Console.WriteLine(\u0026#34;老鼠走過的路徑(以2表示)\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) { for (j = 0; j \u0026lt; 12; j++) { Console.Write(Maze[i, j]); } Console.WriteLine(); } Console.ReadKey(); } 執行結果\n迷宮路徑 111111111111 100011111111 111011000011 111011011011 111000011011 111011011011 111011011011 111111011011 110000001001 111111111111 老鼠開始走迷宮... 老鼠走過的路徑(以2表示) 111111111111 122211111111 111211222211 111211211211 111222211211 111211011211 111211011211 111111011211 110000001221 111111111111 Note 這次趁著假日時間，回憶一下經典演算法，閱讀過程中，意外發現此書作者有些筆誤的地方，文字的部分到還好，沒特別注意還是能順暢的讀過（中文字就算兩個字顛倒也能辨識，神奇～），倒是老鼠走迷宮代碼的部分，讓筆者疑惑很久，最後依照筆者自己的想法做了些改良，一樣是使用堆疊概念來實作，其實還可進階地使用遞迴，有興趣的人可以試試看。\n收工！\nReference 【圖說演算法 C#】\n","permalink":"https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/","summary":"【3/28 閱讀紀錄】\n此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。\nStart 演算法種類很多，經典的演算法有以下幾種\n 分治演算法（Divide and conquer） 迭代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Enumeration Algorithm） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。\n像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。\n然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。\n所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。\n迭代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為迭代演算法，像是透過迴圈去循環重複的程式碼來得到答案。\n舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果\n// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { sum = sum * j; } Console.","title":"【Algorithm】經典演算法"},{"content":"Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？\nSolution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。\n如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！\n視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔\n 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側\n 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。\n視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置\n 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。\n","permalink":"https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/","summary":"Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？\nSolution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。\n如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！\n視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔\n 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側\n 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。\n視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置\n 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。","title":"【Windows】如何分割視窗/畫面"},{"content":"紀錄一下每次使用命令提示字元想從 C:\\ 切換到 D:\\ 時，都會喪失記憶，一直使用 CD D:\\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。\n其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。\n","permalink":"https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/","summary":"紀錄一下每次使用命令提示字元想從 C:\\ 切換到 D:\\ 時，都會喪失記憶，一直使用 CD D:\\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。\n其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。","title":"【Windows】使用 DOS 指令切換當前硬碟"},{"content":"Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。\n查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）\n何謂全表掃描（Full Table Scan）？\n簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。\n以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。\n  避免使用 NULL\nSELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 \u0026lt;\u0026gt; 和 !=，使用 \u0026gt;= 或 \u0026lt;= 來取代\n  避免使用 or 來連接條件\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 UNION ALL SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 5   避免使用 IN 或 NOT IN\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID IN (3,4,5) -- 若是連續數值，能用 BETWEEN 就不要用 IN SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID BETWEEN 3 AND 5   使用 EXISTS 來代替 IN\nSELECT ID FROM A WHERE ID IN (SELECT ID FROM B) -- 將 IN 替換成 EXISTS 語句 SELECT ID FROM A WHERE ID EXISTS (SELECT 1 FROM B WHERE NUM = A.NUM)   避免使用 Like\n  避免使用 %\n  避免在子句對欄位進行運算\nSELECT ID FROM A WHERE NUM/2 = 100 -- 應更改為 SELECT ID FROM A WHERE NUM = 100*2   避免在子句對欄位進行函數操作\nSELECT ID FROM A WHERE SUBSTRING(ProductName, 1, 3)=\u0026#39;abc\u0026#39; SELECT ID FROM A WHERE DATEDIFF(DAY, CreateDate, \u0026#39;2021-03-26\u0026#39;) = 0 -- 應更改為 SELECT ID FROM A WHERE ProductName Like \u0026#39;abc\u0026#39; SELECT ID FROM A WHERE CreateDate \u0026gt;= \u0026#39;2021-03-26\u0026#39; AND CreateDate \u0026lt; \u0026#39;2021-03-27\u0026#39;   避免再子句中的 = 左邊進行函數、算術運算或其他運算式，因系統可能無法正確的使用索引\n  索引優化 欲對查詢進行優化，首先應考慮在 WHERE 和 ORDER BY 涉及的欄位建立索引。\n但也不是所有索引對查詢都有效，當索引列有大量資料重複時，SQL Agent 也會放棄使用索引改為使用 Full Table scan。如對某欄位建立索引，而該欄位只有 true \u0026amp; false，資料量分別為各半，那該索引在查詢時無法有作用，SQL Agent 最終會走 Full Table scan。\n在使用索引欄位為條件時，如果索引為複合式索引，那麼在搜尋時的條件必須以複合式索引中的欄位順序來查詢，否則索引將不會被使用到。\n索引並非越多越好，索引固然能提高查詢效率，但同時也會降低 INSERT 和 UPDATE 的效率，因為這兩個動作有可能會重建索引。一般來說一個資料表的索引不超過六個，若太多則應考慮剔除一些非必要索引。\n其他優化   盡量不使用星號查詢 SELECT * FROM A，用具體的欄位來替代星號，只返回需要使用的欄位，減少返回用不到的資料\n  Table Name 給予 Alias Name，使用時連同別名一起給予，如 [AliasName].[ColumnName]\n  UNION ALL 效能會優於 UNION，因為不用排序\n  FROM 之後的資料表來源在 JOIN 時，由左到右依序 JOIN RECORD 由多到少的 TABLE\n  避免向 Client Side 返回大量數據\n  能用 DISTINCT 就不用 GROUP BY\nSELECT OrderID FROM Order WHERE UnitPrice \u0026gt; 10 GROUP BY OrderID -- 應改為 SELECT DISTINCT OrderID FROM Order WHERE UnitPrice \u0026gt; 10   用 EXISTS 替代 DISTINCT\n  避免使用 SELECT INTO 語句 因為 SELECT INTO 語句會造成資料表鎖定，其他使用者則無法訪問該資料表。\n  Note 前陣子在工作上遇到需要效能調教問題，在解決的過程中得知有些基礎的效能優化方法，就誕生了這篇文章，至於工作上遇到的問題，模擬情境需要點時間思考，之後有空會在記錄。\n","permalink":"https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/","summary":"Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。\n查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）\n何謂全表掃描（Full Table Scan）？\n簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。\n以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。\n  避免使用 NULL\nSELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 \u0026lt;\u0026gt; 和 !=，使用 \u0026gt;= 或 \u0026lt;= 來取代\n  避免使用 or 來連接條件\nSELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].","title":"【MSSQL】如何改善 SQL 常見的效能問題"},{"content":"Prerequisites .NET 5.0 SDK 或之後的版本\nStart 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。\n建立新專案 選擇【Blazor 應用程式】專案\n選擇【Blazor Server 應用程式】樣板\n建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。\n建立 Razor 元件時要注意\n 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page \u0026quot;/todo\u0026quot;\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼\n\u0026lt;ul class=\u0026#34;nav flex-column\u0026#34;\u0026gt; ... \u0026lt;li class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Todo \u0026lt;/NavLink\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.cs 類別，以保存待辦清單集合\npublic class TodoItem { public string Title { get; set; } public bool IsDone { get; set; } } 在 UI 渲染清單 在 Pages/Todo.razor 變更下列代碼\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!--走訪 todo 集合，添加清單標記--\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt;@todo.Title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; @code { // 建立 todo 清單集合  private IList\u0026lt;TodoItem\u0026gt; todos = new List\u0026lt;TodoItem\u0026gt;(); } 此時還不會有任何清單呈現，因為在 todos 集合中尚未添加項目。\n添加新增功能 繼續在 Pages/Todo.razor 新增文字輸入框及按鈕\n\u0026lt;ul\u0026gt; ... \u0026lt;/ul\u0026gt; \u0026lt;!--bind:屬性繫結--\u0026gt; \u0026lt;input placeholder=\u0026#34;Something todo\u0026#34; @bind=\u0026#34;newTodo\u0026#34;/\u0026gt; \u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; 在 @code 區塊內加入一個與文字輸入框綁定的 string，以及按下 Add Todo 按鈕後呼叫的 AddTodo 方法\n@code { ... // 取得新的 todo 標題  private string newTodo; /// \u0026lt;summary\u0026gt;  /// 新增清單項目  /// \u0026lt;/summary\u0026gt;  private void AddTodo() { // Todo: Add the todo  // 將綁定的 newTodo 文字新增至 todos 集合中  if (!string.IsNullOrWhiteSpace(newTodo)) { todos.Add(new TodoItem { Title = newTodo }); newTodo = string.Empty; } } } 變更清單呈現方式  每個清單項目前添加核取方塊 checkbox ，供使用者紀錄已完成項目 每個清單項目的文字輸入框設定為可編輯  \u0026lt;!--走訪 todo 集合，添加清單標記--\u0026gt; @foreach(var todo in todos) { \u0026lt;li\u0026gt; \u0026lt;!--綁定 todo 屬性--\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; @bind=\u0026#34;todo.IsDone\u0026#34; /\u0026gt; \u0026lt;input @bind=\u0026#34;todo.Title\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; } 標題顯示未完成項目數量 更新 \u0026lt;h3\u0026gt; 標頭為可計算未完成項目的數量\n\u0026lt;h3\u0026gt;Todo (@todos.Count(todo =\u0026gt; !todo.IsDone))\u0026lt;/h3\u0026gt; Done 啟動本地瀏覽，享受成品！\n使用 command shell 建立專案 前面建立專案時是使用 IDE 介面，這裡補充一下如何使用指令來建立專案。\n建立 Blazor 專案 先 CD 到欲建立資料夾的目錄，使用下列指令來建立 Blazor 專案，執行完後會看到該目錄下已建立 TodoList 資料夾\n$ dotnet new blazorserver -o TodoList 將當前目錄更換到 TodoList 資料夾\n$ cd TodoList 新增 Razor Component -n 為建立元件的名稱， -o 為輸出的位置，下列該指令會在 Pages 資料夾下建立一個 Todo.razor 的元件\n$ dotnet new razorcomponent -n Todo -o Pages 到目前為止已經建立一個 Blazor 專案，並為專案內建立 Razor 元件，接下來的程式碼修改如同上述操作，這邊就不再重複介紹。\n完成後使用下列代碼來啟用本地伺服器瀏覽\n$ dotnet watch run Reference Build a Blazor todo list app\n","permalink":"https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/","summary":"Prerequisites .NET 5.0 SDK 或之後的版本\nStart 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。\n建立新專案 選擇【Blazor 應用程式】專案\n選擇【Blazor Server 應用程式】樣板\n建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。\n建立 Razor 元件時要注意\n 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page \u0026quot;/todo\u0026quot;\n@page \u0026#34;/todo\u0026#34; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼\n\u0026lt;ul class=\u0026#34;nav flex-column\u0026#34;\u0026gt; ... \u0026lt;li class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Todo \u0026lt;/NavLink\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.","title":"【.NET】打造 Blazor ToDoList"},{"content":"Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！\nSolution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】\nStep2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。\nNote 【OS】Win10\n","permalink":"https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/","summary":"Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！\nSolution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】\nStep2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。\nNote 【OS】Win10","title":"【Windows】如何改變命令提示字元(cmd)視窗預設大小"},{"content":"Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C \u0026amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。\nSolution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。\nStep1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】\nStep2 展開磁碟機選擇要與遠端分享的硬碟\nStep3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享\nNote OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。\n","permalink":"https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/","summary":"Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C \u0026amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。\nSolution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。\nStep1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】\nStep2 展開磁碟機選擇要與遠端分享的硬碟\nStep3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享\nNote OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。","title":"【Windows】分享本地硬碟供遠端使用"},{"content":"Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 \u0026amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。\nSolution Step1 檢查剪貼簿功能是否有開啟\n【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能\nStep2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。\nNote 那麼為何 File Copy 會當掉？\n有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。\n","permalink":"https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/","summary":"Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 \u0026amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。\nSolution Step1 檢查剪貼簿功能是否有開啟\n【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能\nStep2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。\nNote 那麼為何 File Copy 會當掉？\n有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。","title":"【Windows】遠端桌面連線無法複製貼上？"},{"content":"Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可\nNote 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？\n【傳送門】【Windows】遠端桌面連線無法複製貼上？\n","permalink":"https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/","summary":"Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可\nNote 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？\n【傳送門】【Windows】遠端桌面連線無法複製貼上？","title":"【Windows】開啟遠端桌面連線剪貼簿/印表機功能"},{"content":"GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。\n在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。\nCreate a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。\n首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。\n下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！\nGit client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git\n Terminal GitHub Desktop  使用 Terminal 要了解 git 操作指令，而 GitHub Desktop 對新手較為友善，提供 UI 介面來操作 git 指令。兩者相較下，前者需要了解的指令相對多，且對指令的熟悉度必須較高，才能適時的選出合適的指令進行操作。\n下列介紹終端機的使用方法，移動到專案要儲存的位置，將剛剛建立的倉儲 clone 到該路徑下，記得替換 username 為自己的 GitHub 帳戶。\n$ git clone https://github.com/username/username.github.io 此時該路徑會建立名為 username.github.io 的資料夾，進入到新建的目錄下，建立內容為 Hello world 的 index.html 作為首頁。\n$ cd username.github.io $ echo \u0026#34;Hello world\u0026#34; \u0026gt; index.html 使用 git 指令 add、commit、push 將專案推送到 GitHub repository.\n# 將全部檔案添加到欲提交的暫存區域 $ git add --all # 將暫存區域的檔案提交出去 $ git commit -m \u0026#34;Initial commit\u0026#34; # 將本地儲存庫推送到遠端儲存庫 $ git push -u origin main 開啟瀏覽器進入到 https://username.github.io 即可看到剛剛 Hello world 的畫面！\nChoose a theme 目前我們只新增一個 index.html 的頁面，還只是個簡陋的靜態網站，GitHub Pages 提供幾個佈景主題可供套用，進入 repository 的 Setting，往下拉會看到 GitHub Pages 的 panel，此 panel 為靜態網站提供一些設置，找到 Choose a theme 按鈕，從中挑選一個主題套用，套用後會看到主題的代碼已經存放在 repository 內，而不單單只有先前建立的 index.html，再次打開瀏覽器進入 https://username.github.io 就可看到剛剛套用的 theme。\n恭喜，完成了一個靜態網站！\nReference GitHub Pages\n","permalink":"https://fakestandard.github.io/post/github/github-1-githubpage/","summary":"GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。\n在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。\nCreate a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。\n首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。\n下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！\nGit client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git","title":"【GitHub】在 GitHub Pages 建立靜態網站"},{"content":"【紀錄 2021/3/20】\n美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。\n這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～\n想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～\n周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…\n本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～\n正門口\n建築物外觀\n湯屋內設施\n正門木頭椅\n整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。\n結論，下次想使用客房得提前先預訂。\nBTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！\n泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。\n取自網路的招牌\n美食享用\n兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。\n原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～\n到家時間 am 2:30\n","permalink":"https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/","summary":"【紀錄 2021/3/20】\n美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。\n這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～\n想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～\n周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…\n本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～\n正門口\n建築物外觀\n湯屋內設施\n正門木頭椅\n整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。\n結論，下次想使用客房得提前先預訂。\nBTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！\n泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。\n取自網路的招牌\n美食享用\n兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。\n原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～\n到家時間 am 2:30","title":"【Life Trip】北投享溫泉/石牌老牌肉丸"},{"content":"前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。\n應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。\n標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高\n# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。\n斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 \u0026lt;em\u0026gt; 標籤包圍\n*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 \u0026lt;strong\u0026gt;\n**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現\n***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 \u0026lt;p\u0026gt;。\nThis is the first paragraph. This is the second paragraph. 清單 分為無序清單及有序清單兩種，無序清單使用 * 、 + 或 - 作為清單標記，有序清單使用數字接著一個英文句點做為清單標記\n* Red * Green * Blue + Red + Green + Blue - Red - Green - Blue 1. Apple 2. Bird 3. Candy 上面無序清單和有序清單所產生的 HTML 標記分別為\n\u0026lt;!--無序清單--\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Red\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Green\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Blue\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!--有序清單--\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Apple\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Bird\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Candy\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 若要使用多層級清單，可在下一層級使用一個縮排或是兩個半形空白\n- Red - Green - Blue - Sub red - Sub green - three CheckBox CheckBox 常用於待辦事項或確認項目，使用 -[] 符號放到項目開頭，中括號內有 x 代表被選取。\n- [x] This is a complete item - [ ] This is an incomplete item 分隔線 在一行內使用三個或以上的 *、-、_ 來建立分隔線，符號內不可有其他東西，但可以在符號內插入空白。\n*** --- ___ 效果 下列寫法都可建立分隔線\n******** * * * ---------- - - - 圖片 使用語法如下\n 一個驚嘆號 ! 開頭 一對中括號，放置圖片的替代文字 一對小括號，放置圖片的路徑或網址，另外還可選擇性的添加 prompt，當滑鼠停留在圖片上時，會自動顯示這段文字，並使用雙引號包住。  ![Text](/path/image.jpg) ![Text](/path/image.jpg \u0026#34;title\u0026#34;)  路徑可使用絕對路徑或相對路徑\n 連結 使用語法如下\n 一個中括號，放置連結文字 一個小括號，放置連結路徑或網址，一樣可使用雙引號來添加 prompt 文字  [Github](https://fakestandard.github.io \u0026#34;my github\u0026#34;) 效果 自動連結 Markdown 使用一組括號 \u0026lt; \u0026gt; 支援較簡易的連結，如網址或信箱。與連結不同之處就是自動連結不產出連結文字。\n\u0026lt;https://fakestandard.github.io\u0026gt; 效果 表格 Markdown 表格有點囉嗦，排版上也不是很美觀，若非必要盡量不做大張表格，實際運用時不太親民。\n 最外圍的豎線不一定需要。 靠左對齊的寫法是添加 : 在左側，如 :---，同理靠右對齊為在右側添加冒號 ---: 置中對齊呈現的方式為在兩側都添加冒號 :--:。  | Plugin | README | | ------ | ------ | | Dropbox | [plugins/dropbox/README.md][PlDb] | | GitHub | [plugins/github/README.md][PlGh] | | Google Drive | [plugins/googledrive/README.md][PlGd] | | OneDrive | [plugins/onedrive/README.md][PlOd] | | Medium | [plugins/medium/README.md][PlMe] | | Google Analytics | [plugins/googleanalytics/README.md][PlGa] | 效果\n程式碼  要標記一小段程式碼，可以使用反引號 ` 包起來。 如果想在程式碼內插入反引號，可以使用兩個反引號來開啟和結束程式碼  Example\nUse the `print()` function ``There is a literal backtick (`) here.`` A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 效果\n程式碼區塊 要標記多行的程式碼，可簡單的使用 4 個空白或一個 tab 縮排即可\nHere is an example of AppleScript: tell application \u0026#34;Foo\u0026#34; beep end tell 效果\n也可連續使用三個反引號 ``` 把程式碼包起來，並在首行的三個反引號後面加上該段程式碼的語言，就可輸出 Highlight 效果，例如 ```html。\n\u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; \u0026amp;copy; 2004 Foo Corporation \u0026lt;/div\u0026gt; 區塊引言 Markdown 使用 email 形式的 blockquotes，在每行前面加上 \u0026gt;，區塊引言與清單一樣可以有階層，只要根據階層加上不同數量的 \u0026gt; 即可完成\n\u0026gt; This is the first quoting. \u0026gt; This is the second quoting. \u0026gt; This is the first level of quoting. \u0026gt;\u0026gt; This is the second level of quoting. \u0026gt;\u0026gt;\u0026gt; This is the third level of quoting. \u0026gt; Back to the first level. 效果\n列表縮進  黃鶴樓送孟浩然之廣陵 故人西辭黃鶴樓，煙花三月下揚州。 孤帆遠影碧山盡，唯見長江天際流。  黃鶴樓送孟浩然之廣陵 : 故人西辭黃鶴樓，煙花三月下揚州。 孤帆遠影碧山盡，唯見長江天際流。 跳脫字元 前面介紹那麼多格式所使用的符號，若要將這些符號呈現出來，而非作為有意義的符號使用，可使用反斜線 \\ 來插入普通的符號。\n\\\\ 反斜線 \\` 反引號 \\* 星號 \\_ 底線 \\{} 大括號 \\[] 方括號 \\() 括號 \\# 井字號 \\+ 加號 \\- 減號 \\. 英文句點 \\! 驚嘆號 效果\n結語 首發先來記錄 Markdown 語法，因 Hugo 寫作時也支援 Markdown，順手先記錄一篇常用到的，有空再寫一篇較進階的用法。下次見囉！\n題外話，部落格新開張那天，筆者裝了矯正牙套，那晚真是有苦說不出，有香雞排難下嚥，上排和下排牙齒能分多開就多開，要是碰再一起可得酸個三秒五秒。能咬的東西越來越少，太硬的咬不動，而菜梗也成為較硬的食物，我還天真地以為可以吃它（泣）…\nReference Markdown\nMastering Markdown\n","permalink":"https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/","summary":"前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。\n應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。\n標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高\n# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 \u0026lt;h1\u0026gt; 到 \u0026lt;h6\u0026gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。\n斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 \u0026lt;em\u0026gt; 標籤包圍\n*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 \u0026lt;strong\u0026gt;\n**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現\n***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 \u0026lt;p\u0026gt;。","title":"【Markdown】筆記神器"},{"content":"前言 恭賀本人的部落格又開張了！\n歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…\nOK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…\n正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。\n某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…\n接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…\n過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…\n說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…\n前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo \u0026amp; pick theme，終於大功造成！\n結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。\n隨著年紀增長，大腦效能逐漸降低，也該是時候有個小角落來記錄技術疑難雜症，以及生活點滴，再加上筆者未點到寫作技能，現在點不知來不來得及（笑）\n期許，2022 年這部落格還能存活著\nReference Hugo offcial website\n","permalink":"https://fakestandard.github.io/post/other/other-1-newblog/","summary":"前言 恭賀本人的部落格又開張了！\n歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…\nOK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…\n正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。\n某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…\n接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…\n過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…\n說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…\n前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo \u0026amp; pick theme，終於大功造成！\n結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。","title":"【賀】新開張！"},{"content":"","permalink":"https://fakestandard.github.io/zone/example/","summary":"","title":"Example"}]