<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>How can I help</title>
    <link>https://fakestandard.github.io/</link>
    <description>Recent content on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 02 Jul 2021 15:50:31 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】堆疊應用—陣列實作堆疊</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</link>
      <pubDate>Fri, 02 Jul 2021 15:50:31 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用陣列結構模擬堆疊工作運算，且使用迴圈控制推入與取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。
建立堆疊類別
/// &amp;lt;summary&amp;gt; /// 以陣列模擬堆疊的類別 /// &amp;lt;/summary&amp;gt; class StackArray { // 宣告陣列  private int[] stack; // 指向堆疊頂端的索引  private int top; /// &amp;lt;summary&amp;gt;  /// 建構子  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;stack_size&amp;#34;&amp;gt;堆疊大小&amp;lt;/param&amp;gt;  public StackArray(int size) { // 建立陣列  stack = new int[size]; top = -1; } /// &amp;lt;summary&amp;gt;  /// 判斷堆疊是否為空  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Empty() { if (top == -1) return true; else return false; } /// &amp;lt;summary&amp;gt;  /// 推入資料到頂端的方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Push(int data) { // 判斷堆疊頂端的索引是否大於陣列大小  if (top &amp;gt;= stack.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—費氏搜尋法（Fibonacci Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</link>
      <pubDate>Wed, 30 Jun 2021 13:28:24 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</guid>
      <description>【5/31 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  費氏搜尋演算法（Fibonacci Search） 費氏搜尋演算法又稱費伯納搜尋法，Fibonacci 還有其他譯名如斐波那契數列、費氏數列等等，該數列非常特別，對於大自然而言，整個自然界都存在這個的定律，它是一個神奇的黃金比例；對於數學而言，只不過是個公式—每個值是前兩項的總和，但是，每個值除以前一項的商數，都近似於 1.618…
OK. 我們也不能偏離主題太遠，不過 1.618 這個數字會存放於筆者內心的深處，近期受疫情的肆虐，筆者拾起達文西密碼，拜本書之賜，重新認識斐波那契數列這個「上帝之數」。
費氏級數如同先前所說，每個值都是前兩項的加總，故其公式為
雖然每個值都是前兩項的加總，其中並不包含第零個元素和第一個元素，第零個元素定義為 0，第一個元素定義為 1，從這兩個元素開始，每個值才是前兩項的總和，故該數列會是 0,1,1,2,3,5,8,13,21,34,55,89,144...
費氏樹列以遞迴程式碼表現方式為
static int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 了解費氏級數後，就來認識費氏搜尋數，所謂費氏搜尋數就是以費氏數列的特性，所建立的二元數，其建立原則如下</description>
    </item>
    
    <item>
      <title>【OOP】物件導向設計的五大原則</title>
      <link>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</link>
      <pubDate>Tue, 29 Jun 2021 21:47:25 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-3-oop-principles/</guid>
      <description>Start 前篇講解 OOP 的特性卻還沒介紹基本原則，馬上來惡補一下內功心法。
物件導向設計五大原則「SOLID」由羅伯特·C·馬丁在21世紀早期提出，SOLID分別為單一功能原則、開閉原則、里氏替換原則、介面隔離原則、依賴反轉原則。
了解物件導向基本原則及特性，透過不斷練習和思考就可寫出閱讀性、維護性、擴充性高的程式碼，然而開發易維護與擴展的系統也變得不難。
單一職責（Single Responsibility Principle） 對一個類別來說，應該只有一個引起他變化的理由，意為一個類別應只專注做一件事，當類別需要做兩件以上的工作時，就承擔了過多的職責，一旦需變更代碼，耦合度會比一件工作還要高，而當發生錯誤時很難快速定位錯誤原因，間接導致程式碼可閱讀性降低。
開放封閉（Open-Closed Principle） 增加新的代碼來擴充系統，而非修改原本已存在的代碼來擴充新功能。所以在設計類別時對擴充保持開放及對修改保持封閉。若面對需求變化時，有無法封閉的變化，此時就須建立抽象點來隔離那些變化。
里氏替換（Liskov Substitution Principle） 子類別必須可以替換父類別而不影響程式架構。若使用繼承，子類別實作的行為必須與父類別或介面所定義的行為一致，且子類別可完全取代父類別。
介面隔離（Interface Segregation Principle） 抽取相同的功能形成介面，再讓各類別去實作。即針對不同類別開放對應需求的介面，需抽換時只需實作介面類別即可，大量降低耦合度。
依賴反轉（Dependency Inversion Principle） 高階模組不應依賴低階模組，兩者都應依賴在抽象概念上；抽象概念不依賴細節，而細節依賴在抽象概念。模組之間若太過耦合，很容易出現修改A又被迫修改B的情況，若依賴抽象則兩只只要關注自己本身即可。
Reference 【大話設計模式】</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—內插搜尋法（Interpolation Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</link>
      <pubDate>Mon, 28 Jun 2021 10:27:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  內插搜尋演算法（Interpolation Search） 內插搜尋法又稱插補搜尋法，是二分搜尋法的改良版，主要是針對以排序的資料進行搜尋，與二分法相同。其原理為透過斜率公式預測資料的所在位置，再以二分法逐漸逼近。
參考斜率公式說明
實作公式
Mid = left + ((key-data[left]) * (right - left) / (data[right] - data[left])) 演算法分析  資料需事先排序 資料分佈越平均，搜尋速度越快。時間複雜度取決於資料分佈情況，平均會優於 O(logn)  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作內插搜尋法的過程
建立靜態陣列物件及內插搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; static int Interpolation(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—二分搜尋法（Binary Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</link>
      <pubDate>Fri, 25 Jun 2021 12:37:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。
假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。
演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程
建立靜態陣列物件及二分搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; /// &amp;lt;summary&amp;gt; /// 二分搜尋方法 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;val&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【.NET Core】環境變數 Environments</title>
      <link>https://fakestandard.github.io/netcore/netcore5-7-environments/</link>
      <pubDate>Thu, 24 Jun 2021 10:05:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-7-environments/</guid>
      <description>【ASP.NET Core 5】
Start ASP.NET Core 會根據執行階段的環境變數，來設定應用程式的行為。如開發環境、測試環境及正式環境的組態設定會不太相同，使用的資料庫也會不同。
Environment Variable 預設的三種環境
 Development 開發環境 Staging 暫存(測試)環境 Production 正式環境  環境名稱由系統變數 ASPNETCORE_ENVIRONMENT 的內容值而來，該變數可在 launchSettings.json 作變更。
開啟 launchSettings.json，在 profiles 節點找到 IIS Express\..\environmentVariables 的 ASPNETCORE_ENVIRONMENT，將原本的 Development 變更為 Production。
&amp;#34;profiles&amp;#34;: { &amp;#34;IIS Express&amp;#34;: { &amp;#34;commandName&amp;#34;: &amp;#34;IISExpress&amp;#34;, &amp;#34;launchBrowser&amp;#34;: true, &amp;#34;environmentVariables&amp;#34;: { &amp;#34;ASPNETCORE_ENVIRONMENT&amp;#34;: &amp;#34;Production&amp;#34; } } } 開啟 Startup.cs，Configure 方法已注入 IWebHostEnvironment，在方法內使用下列程式碼判斷環境變數內容值
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsProduction()) // 假設是生產環境  { app.Run(async (context) =&amp;gt; { await context.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</link>
      <pubDate>Wed, 23 Jun 2021 11:19:30 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。
它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。
假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。
利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。
演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n+1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程</description>
    </item>
    
    <item>
      <title>【OOP】物件導向特性—封裝、繼承、多型</title>
      <link>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</link>
      <pubDate>Tue, 22 Jun 2021 20:56:20 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-2-oop-feature/</guid>
      <description>Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。
 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明
 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。
封裝的好處
 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。
static void Main(string[] args) { Swordman swordman = new Swordman(); } /// &amp;lt;summary&amp;gt; /// 封裝類別 /// &amp;lt;/summary&amp;gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。
原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。
/// &amp;lt;summary&amp;gt; /// 盜賊類別 /// &amp;lt;/summary&amp;gt; class Thief { private string name = string.</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</link>
      <pubDate>Mon, 21 Jun 2021 13:59:42 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。
假設有一陣列，陣列資料分別為
                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—基數排序法（Radix Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</link>
      <pubDate>Fri, 18 Jun 2021 13:58:45 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</guid>
      <description>【5/20 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例
LSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較
Step 1 將每個元素依照「個位數」放到相對應的串列中
                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259</description>
    </item>
    
    <item>
      <title>【.NET Core】組態設定 Configuration</title>
      <link>https://fakestandard.github.io/netcore/netcore5-6-configuration/</link>
      <pubDate>Thu, 17 Jun 2021 10:34:36 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-6-configuration/</guid>
      <description>【ASP.NET Core 5】
Start .NET Framework 的組態通常在 app.config 或 web.config 中設定，在 .NET Core 不再使用過往讀取單一檔案方法，它使用一個或多個 Configuration Provider 來提供多種設定組態的方式。
預設組態 應用程式在 Program.cs 預設產生 Host.CreateDefaultBuilder(args) 程式碼，CreateDefaultBuilder 會依照下列 Provider 的順序提供應用程式預設組態
 ChainedConfigurationProvider appsettings.json appsettings.Environment.json Environment Variables configuration provider Command-line configuration provider  使用下列程式碼，依新增順序來顯示 Configuration Provider
private IConfigurationRoot ConfigRoot; public HomeController(IConfiguration configRoot) { ConfigRoot = (IConfigurationRoot)configRoot; } public ContentResult OnGet() { string str = &amp;#34;&amp;#34;; foreach (var provider in ConfigRoot.Providers.ToList()) { str += provider.ToString() + &amp;#34;\n&amp;#34;; } return Content(str); } 結果與前述說明的順序相同</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—合併排序法（Merge Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</link>
      <pubDate>Wed, 16 Jun 2021 10:57:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。
步驟非常好理解，如下
 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—快速排序法（Quick Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</link>
      <pubDate>Sun, 13 Jun 2021 14:01:03 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</guid>
      <description>【5/17 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。
其步驟如下
 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I &amp;gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K
               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J</description>
    </item>
    
    <item>
      <title>【C#】位移運算元 &lt;&lt; 和 &gt;&gt;</title>
      <link>https://fakestandard.github.io/post/csharp/csharp-2-bitwiseshiftoperators/</link>
      <pubDate>Sat, 12 Jun 2021 16:00:21 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/csharp/csharp-2-bitwiseshiftoperators/</guid>
      <description>昨天在刷 LeetCode 時，發現解題方式可以使用位移運算元，雖然筆者早就看過這個運算元，卻沒實際了解過，也趁這個機會快速了解位移運算元是個什麼樣的概念。
首先，筆者遇到的題型非常簡單，將二進位制轉換為十進位制，如將二進位 1110 轉換成十進位，得解為 14，在 C# 中可直接使用 Convert 來實現進位之間的轉換
string binary = &amp;#34;1110&amp;#34;; // 二進位轉十進位, 第二個參數為 base Convert.ToInt32(binary, 2); 如此是透過現成方法來實現轉換，為了更了解二進制的應用，特意觀察不少的解法，其中不少解法是透過位移運算元，撰寫起來也非常簡潔且優雅，那什麼是位移運算元？
位移運算元有兩種
 左位移 &amp;lt;&amp;lt; 右位移 &amp;gt;&amp;gt;  區分方式也非常易懂，純粹是位移方向的不同，以 1110 為例，對此二進位制的所有位元進行左位移一個位元，即將所有位元往左邊移動一位，而最右邊的第一個數則補上 0，得到結果為 11100，若左位移兩個位元則為 111000；反之右位移則是向右移動，對 1110 右位移一個位元得到 0111，若右位移兩個位元則得 0011。
 左位移一個位元的表示方式為 num &amp;lt;&amp;lt; 1 左位移一個位元的表示方式為 num &amp;lt;&amp;lt; 2 右位移一個位元的表示方式為 num &amp;gt;&amp;gt; 1 右位移一個位元的表示方式為 num &amp;gt;&amp;gt; 1  實際使用程式碼測試，先宣告一個整數變數 num，因為該變數是以十進位表示之，故筆者特意註解 num 二進位的表示方式，接著透過位移運算元，向左搬移一位，最後得十進位的結果。
// 十進位 14, 二進位 1110 int num = 14; // 向左位移 1 位 num = num &amp;lt;&amp;lt; 1; // 得到十進位 28, 二進位 11100 Console.</description>
    </item>
    
    <item>
      <title>【.NET Core】記錄 Logging</title>
      <link>https://fakestandard.github.io/netcore/netcore5-5-logging/</link>
      <pubDate>Fri, 11 Jun 2021 11:10:37 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-5-logging/</guid>
      <description>【ASP.NET Core 5】
過去在記錄 Log 時，會使用第三方套件來記錄，在 .NET Core 預設就已經將 Logger 注入到 DI 容器，直接使用 ILogger 介面來執行。
Start 此篇會紀錄的部分有以下
 Logging Provider Create Logs Log Level Log EventID Log Message Log Exceptions Configure Logging  Logging Provider Logging Provider 會儲存記錄檔，但 Console 顯示記錄的提供者除外。
在 Program.cs 調用 CreateDefaultBuilder 會新增下列記錄提供者
 Console Debug EventSource EventLog: Windows only  欲 override 由 Host.CreateDefaultBuilder 設置的 logging provider 集合，可呼叫 ClearProviders 移除所有 ILoggerProvider 實例，再加入需要的記錄提供者。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
    <item>
      <title>【OOP】物件導向基礎概念（Object Oriented Programming）</title>
      <link>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</link>
      <pubDate>Thu, 10 Jun 2021 14:08:57 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/oop/oop-1-object-oriented-programming/</guid>
      <description>Start 物件導向（Object-Oriented Programming），意為針對物件進行程式設計。而學習設計模式前必須先了解物件導向設計，不然難以體會設計模式的魅力。
接下來我們會知道
 類別（Class） 物件（Object） 實體（Instance） 建構式（Constructor） 多載（Overloading） 欄位（Field） 屬性（Property） 修飾詞（Modifiers）  類別（Class） 類別是具有相同「屬性（Attribute）」和 「功能（Method）」的物件之抽象集合。在 C# 中定義類別的關鍵字為 class，類別命名規則為第一個字母為大寫，多個單字命名時各個首字母為大寫。
// 建立 Swordman 類別 class Swordman { // 建立公開的攻擊方法使外部可以呼叫，修飾詞用 public  public string Attack() { return &amp;#34;基本攻擊！&amp;#34;; } } 物件（Object） 物件是一個獨立的實體，實體裡包含許多資料，資料彼此之間不會互相影響，每個皆為獨立的資料。物件與類別的關係，最簡單易懂又不抽象的解釋為—物件是類別的實體。
// 宣告一個Swordman 物件，物件名為 swordman Swordman swordman; // 先前建立的 Swordman 類別 class Swordman { ... }  在程式碼的世界裡，萬物皆為物件。
 實體（Instance） 實體就是一個真實的物件。實體化是建立物件的過程，使用 new 關鍵字建立。
// 實體化 swordman 物件 swordman = new Swordman(); 綜合上述介紹的類別、物件和實體，實際演練一次程式碼並觀察結果。 在 Swordman 有一個公開的 Attack 方法，當物件被實體化後，未來就能一直呼叫該方法</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—謝耳排序法（Shell Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</link>
      <pubDate>Wed, 09 Jun 2021 10:34:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</guid>
      <description>【5/2 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  謝耳排序法（Shell Sort） 在插入排序法中，若大部分資料已經排序完成，該排序法會相當有效率，而謝耳排序法可以看作是一種使插入排序法減少資料搬移次數的衍伸排序法。
其原理為將資料區分成特定間隔的區塊，以插入排序法對區塊內資料進行排序，再漸漸減少間隔的距離。
舉例，有一陣列為 [50] [60] [10] [30] [20] [80] [40] [70]，以劃分數為 2，將資料分成四等份 (8/2)，得到下列區塊組合 (50,20)(60,80)(10,40)(30,70)，規則為第一個數與第五個數為一組，第二個數與第六個數為一組，以此類推。
接著透過插入排序法，對區塊內的資料做排序，使其成為 (20,50)(60,80)(10,40)(30,70)，排序完後，解散區塊組合，還原成原數列 [20] [60] [10] [30] [50] [80] [40] [70]
繼續縮小間隔為 (8/2)/2，得到下列區塊組合 (20,10,50,40)(60,30,80,70)，其規則為第一、三、五、七個數字為一組，二、四、六、八為一組，一樣以插入排序法對區塊內資料做排序，得結果為 (10,20,40,50)(30,60,70,80)，解散組合區塊，還原成原數列 [10] [30] [20] [60] [40] [70] [50] [80]
進行第三次排序，縮小間隔為 ((8/2)/2)/2，如此一來變成對每一個元素進行排序，直接使用插入排序法得結果為 [10] [20] [30] [40] [50] [60] [70] [80]</description>
    </item>
    
    <item>
      <title>【C#】不規則陣列（Jagged Array）</title>
      <link>https://fakestandard.github.io/post/csharp/csharp-1-jaggedarray/</link>
      <pubDate>Tue, 08 Jun 2021 10:18:14 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/csharp/csharp-1-jaggedarray/</guid>
      <description>最近在 LeetCode 刷題時，發現一個我不知道的東西—不規則陣列（Jagged Array）
從古自今，筆者對於陣列的認知不外乎就是一維與多維陣列，然而在工作上也從未遇過不規則陣列的使用，導致近日在刷題時，曾一度懷疑自己的眼睛，這是不是打錯了？井底之蛙的我馬上跪拜古哥，結果在 C# 程式設計手冊發現了它的蹤影，廢話不多說，馬上來看！
不規則陣列（Jagged Array）是陣列的一種，其陣列內的元素也是陣列，不規則陣列的元素可以具有不同維度及大小，也是與多維陣列明顯的差異之處。
不規則陣列的宣告及初始化
// 不規則陣列的宣告方式 int[][] array = new int[5][]; // 初始化元素 array[0] = new int[6]; array[1] = new int[5]; array[2] = new int[4]; array[3] = new int[3]; // 使用 Initializer 直接填入陣列元素的值，無須設置大小 array[0] = new int[]{ 1, 2, 3 }; array[1] = new int[]{ 4, 6 }; array[2] = new int[]{ 7 }; 從上述可知，多維陣列在同一維度下的元素大小必須相同，而不規則陣列的元素大小可以不同，不規則陣列內的元素是陣列，又稱為陣列中的陣列。
我們也可以在宣告時直接初始化元素
// 宣告時直接初始化 int[][] array = new int[][] { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; // 或是不使用 new 運算子的縮寫格式 int[][] array = { new int[]{ 1, 2, 3 }, new int[]{ 4, 6 }, new int[]{ 7 } }; 其指派值的方式與多維陣列相同</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—插入排序法（Insert Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</link>
      <pubDate>Mon, 07 Jun 2021 12:31:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  插入排序法（Insert Sort） 插入排序法原理是將陣列中的元素，逐一與已經排序好的資料作比較，例如前兩個元素已經排序好，再將第三個元素與這兩個元素作比較，插入到適當的位置，接著將第四個元素，與前三個已排序好的元素進行比較，再插入到適當位置，重複此步驟，直到排序完成為止。
透過插入排序法，一樣對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先第一個元素 [30] 定義為已排序，取得第二個元素 [20]，與第一個元素進行比較，插入到適當位置
初始已排序序列 [30]
插入後結果序列 [20] [30]
Step 2 取得第三個元素 [40]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30]
插入後結果序列 [20] [30] [40]
Step 3 取得第四個元素 [50]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30] [40]
插入後結果序列 [20] [30] [40] [50]</description>
    </item>
    
    <item>
      <title>【.NET Core】靜態檔案 Static Files</title>
      <link>https://fakestandard.github.io/netcore/netcore5-4-staticfiles/</link>
      <pubDate>Sun, 06 Jun 2021 16:17:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-4-staticfiles/</guid>
      <description>【ASP.NET Core 5】
靜態檔案是 HTML、css、image、js 等資源檔案，過去 .NET Framework 可直接被存取，在 ASP.NET Core 中，已不能直接被瀏覽，對於存取有特定的限制。
Start 首先，先了解 Content root 以及 Web root，硬翻成中文為內容根目錄 &amp;amp; Web 根目錄。
Content root（內容根目錄） Content root 預設為專案的根目錄，包含
 裝載應用程式的可執行檔 .exe 組成應用程式的已編譯元件 .dll 應用程式所使用的內容檔案  Razor(.cshtml、.razor) 設定檔(.json、.xml) 資料檔案(.db)   Web 根目錄(Web root)  Web root（Web 根目錄） Web root 為公共靜態資源的基本路徑，預設路徑為 {content root}/wwwroot
 樣式 .css JavaScript .js 影像檔 .png、.jpg  建立一個專案，在方案總管中找到 wwwroot，可看到預設已建立 css、js、lib 資料夾，使用路徑 https://localhost:5000/css/site.css 嘗試讀取 ~/css/site.css 該檔案， 可直接瀏覽檔案內容。
測試自行建立的資料夾是否能存取，在 wwwroot 目錄下建立 images 資料夾以自定義靜態檔案路徑，並放置一張影像檔在該目錄下，嘗試使用 URL https://localhost:5000/images/MyImages.</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—選擇排序法（Selection Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</link>
      <pubDate>Thu, 03 Jun 2021 15:19:41 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  選擇排序法（Selection Sort） 選擇排序法顧名思義是以選擇的概念來進行排序，也算是枚舉法的應用，原理為反覆從未排序的數列中取出最小元素，加入到另一個數列中，達到排序的結果。
選擇排序可以由大到小排序，將最大值放到第一位置；或是由小到大排序，將最大值放到最後一個位置。
透過選擇排序法，對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先進行第一次掃描，找到數列中最小值，直接與第一個元素交換
初始序列 [30] [20] [40] [50] [10]
結果序列 [10] [20] [40] [50] [30]
Step 2 進行第二次掃描，排除第一個元素，從第二個位置開始找起，找到最小值，與第二個位置元素交換，因為 [20] 是此次搜尋中最小值，其結果位置不變
上次結果 [10] [20] [40] [50] [30]
結果序列 [10] [20] [40] [50] [30]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—氣泡排序法（Bubble Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</link>
      <pubDate>Tue, 01 Jun 2021 13:56:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  氣泡排序法（Bubble Sort） 氣泡排序法可稱為交換排序法，其構思為觀察水中氣泡變化而成，甚至可稱為冒泡排序等類似名稱。
其原理為從第一個元素開始，比較相鄰元素的大小，如大小順序有誤，就將其對調，再與下一個元素進行比較，彷彿氣泡逐漸冒出水面上的概念，使用該方法掃描過一次後，就可以確保最後一個元素是位於正確的位置，進行第二次掃描，就能確認第二個元素的正確位置，逐步進行直到所有元素排序完成。
使用白話一點的說法，逐一拆解每一個步驟，首先有一個序列，初始的狀態和順序為 [30] [20] [40] [50] [10]，目標將此序列由小到大排列，變成 [10] [20] [30] [40] [50]
我們透過氣泡排序法進行排序，步驟解析如下
Step 1 首先進行第一次掃描，會先拿到第一個元素 [30]，接著與相鄰的元素 [20] 進行比較，如果第二個元素小於地一個元素，就進行位置交換。
初始序列 [30] [20] [40] [50] [10]
結果序列 [20] [30] [40] [50] [10]
Step 2 依然拿著 [30] 這個元素，繼續與相鄰的元素比較，因為該元素已經調換到第二個元素的位置，所以下一個相鄰的元素會是 [40]，接著進行比較，經比較後兩個元素順序不變，依然維持下列結果
結果序列 [20] [30] [40] [50] [10]</description>
    </item>
    
    <item>
      <title>【.NET Core】中介軟體 Middleware</title>
      <link>https://fakestandard.github.io/netcore/netcore5-3-middleware/</link>
      <pubDate>Mon, 31 May 2021 14:52:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-3-middleware/</guid>
      <description>【ASP.NET Core 5】
ASP.NET Core 引入一個新概念稱為中介軟體（Middleware），Middleware 會在 ASP.NET Core 應用程式中的每個請求上執行。
過去 ASP.NET 中 HttpHandlers 和 HttpModules 在 ASP.NET Core 已不復存在，更準確地說，它們已成為 Request Pipeline 的一部分，Middleware 類似於 HttpHandlers、HttpModules，都需要在每個請求中進行配置及執行。
Start Middleware 是組成應用程式 Pipeline 的軟體，每個組件可以選擇是否將請求傳遞到管線中的下一個組件，也可以在下一個組件中的前後執行工作。
通常 ASP.NET Core Web 應用程式中有許多 Middleware，它可以是 Framework provided 的中介軟體，也可以通過 NuGet 添加，甚至可以自行定義 Middleware。我們可以在請求管道中設置中介軟體的執行順序，每個中介軟體都會新增或修改 Http 請求，且可選擇將控制權傳遞給下一個中介軟體。
請求委派用於建構請求管道，請求委派會處理每個 Http 請求。該句的原文是這樣
 Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.
 Request delegates 使用 Run、Map 和 Use 三種擴充方法來配置。單個請求委派可以指定嵌入式（in-line）匿名方法，稱為嵌入式中介軟體，也可以在重複使用的類別中進行定義。這些可重用的類別和嵌入式匿名方法就是 middleware ，也稱之為 middleware components。在請求管道中的每個中介軟體元件負責調用 Pipeline 中的下一個元件，或對管線執行最少運算，當中介軟體短路時（short-circult），會阻止接下來的中介軟體處理請求，稱之為終端中介軟體 terminal middleware。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—雜湊表（Hash Table）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-9-hashtable/</link>
      <pubDate>Sat, 29 May 2021 13:55:36 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-9-hashtable/</guid>
      <description>【5/24 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄雜湊表定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  雜湊表（Hash Table） 雜湊是一種電腦對資料的處理方式，它通過某種特定的雜湊函數應用，將鍵值轉換成相對應的資料儲存位址，形成一種快速存取與搜尋資料的資料結構—雜湊表，而雜湊表是一種儲存紀錄的連續記憶體。
相關專有名詞  雜湊函數（Hashing Function）
將未經雜湊的資料，透過特定的計算公式，轉換成對應的資料儲存位址，計算後的結果必須隨著明文改變而改變。 雜湊值（Hash Code）
原始資料經由雜湊函數計算的結果，稱為雜湊值，且雜湊值為不可逆。不可逆的意思是，轉換後的結果無法反推原來的資料，只能由 A 變成 B，無法從 B 找回 A，例如將蘋果透過果汁機打成蘋果汁，蘋果就是原始資料，果汁機是雜湊函數，蘋果汁是雜湊值，我們無法將蘋果汁再透過果汁機變回蘋果，這就是不可逆。 桶（Bucket）
雜湊表中儲存資料的位置，每個位置對應唯一的位址（Bucket Address） 槽（Slot）
每一筆紀錄可能包含多個欄位，Slot 指的就是 Bucket 的欄位 碰撞（Collision）
兩筆不同的資料，經雜湊函數運算後，對應到相同位址時，稱為碰撞 溢位（Overflow）
資料經過雜湊函數運算後，對應的 Bucket 已滿，則會使 Bucket 發生溢位 雜湊表（Hash Table）
儲存紀錄的連續記憶體，它類似於資料表的索引表格，可將 Column 和 Row 看待成 Slot 與 Bucket 完美雜湊（Perfect Hashing）
指沒有發生碰撞，也沒有發生溢位的雜湊函數  雜湊應用 雜湊通常應用於加密或驗證，但雜湊不等於加密，加密不等於雜湊。其應用有身份證字號是透過公式來驗證是否合法，或者是 MD5 密碼雜湊函式，將使用者的 password 經由 MD5 產生雜湊值，再將雜湊值儲存於資料庫中，等下次使用者登入時，將輸入的密碼經由 MD5 運算，將其結果與資料庫中儲存的雜湊值進行比對即可。</description>
    </item>
    
    <item>
      <title>【.NET】使用 C# 操作檔案 I/O 與檔案系統（二）</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-9-filesystemandfileio-two/</link>
      <pubDate>Thu, 27 May 2021 11:04:04 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-9-filesystemandfileio-two/</guid>
      <description>在 .NET 框架中，命名空間System.IO已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西
 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。
流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。
Start 流（Stream）為所有資料流的基礎類別，繼承該類別的資料流常見的有
 FileStream StreamReader StreamWriter MemoryStream  FileStream FileStream可以用來讀取、寫入、開啟和關閉檔案系統上的檔案，或操縱其他與檔案相關的檔案處理系統。該類別主要是要操作位元組陣列， Stream 類別則直接操作字元，是兩者較不同的地方。
文字讀起來沒感覺，直接使用FileStream來讀寫二進位制檔案。
先建立一個含有文字內容的文字檔，透過FileStream開啟該文字檔，除了讀取出二進位制內容，也順便將 binary 轉換為字元打印出來。
/// &amp;lt;summary&amp;gt; /// 使用 FileStream 讀取檔案 /// &amp;lt;/summary&amp;gt; public static void FileStreamRead() { string path = @&amp;#34;D:\Test.txt&amp;#34;; // 建立 FileStream 並實例化  // 開啟或建立指定路徑檔案，訪問權限唯讀  FileStream fs = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Read); // 讀取 binary 檔案  byte[] array = new byte[fs.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—圖形（Graph）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-8-graph/</link>
      <pubDate>Wed, 26 May 2021 09:27:51 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-8-graph/</guid>
      <description>【5/25 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄圖形定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  圖形（Graph） 圖形理論是由一位瑞士數學家所想出的一種資料結構，是比樹狀結構更複雜的非線性結構，許多問題都可以轉換成圖形資料結構，因此，圖形資料結構被廣泛應用於程式的實作，在所有資料結構中的應用也最為廣泛。
例如在網路的地圖上搜尋兩點之間的最短路徑，可以將地點轉換成圖形中的頂點，地點與地點之間的距離轉換成邊，最後使用最短路徑的演算法，即可以找出最短路徑。
圖的定義是由**頂點（Vertice）和邊（Edge）**所組成的集合，邊是連結圖形中的兩個頂點，可以有循環，也可以不跟其他頂點相連，通常以 G=(V,E) 來定義一個圖形
 G：圖（Graph） V：所有頂點（Vertice）的集合 E：所有邊（Edge）的集合  圖形的種類有兩種，分別是無向圖形和有向圖形
無向圖形（Undirected Graph） 無向圖形的邊只代表頂點之間是相連，不會標示方向箭頭，可以說是不具有方向性，無向圖以 (V1,V2) 來表示，例如 (V1,V2) 與 (V2,V1) 表示相同的邊。
以上圖來說
V = {A,B,C,D,E} E = {(A,B),(A,C),(B,D),(B,E),(C,D),(C,E)} 有向圖形（Directed Graph） 有向圖形的每個邊都具有方向性，以 &amp;lt;V1,V2&amp;gt; 來表示，若無向圖是不具方向性，那麼有向圖就是具有方向性的，V1 是指尾端，V2 是指頂端，&amp;lt;V1,V2&amp;gt; 則代表著由 V1 尾端指向 V2 頂端。例如 &amp;lt;V1,V2&amp;gt; 和 &amp;lt;V2,V1&amp;gt; 表示兩個不同方向的邊。
以上圖來說，與無向圖形的範例圖差異在於，該圖的邊是具有方向性箭頭，表示方式如下
V = {A,B,C,D,E} E = {&amp;lt;A,B&amp;gt;,&amp;lt;A,C&amp;gt;,&amp;lt;B,D&amp;gt;,&amp;lt;C,D&amp;gt;,&amp;lt;E,B&amp;gt;,&amp;lt;E,C&amp;gt;} 相關專有名詞   頂點（Vertice）</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—樹（Tree）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-7-tree/</link>
      <pubDate>Mon, 24 May 2021 09:54:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-7-tree/</guid>
      <description>【5/17 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。
上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。
對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。
樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）
樹的基本術語有許多種，利用上圖的樹狀圖一一解說
  根節點（Root）
先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點
  葉節點（Leaf）或終點節點（Terminal Nodes）
節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點
  非終端節點（Nonterminal Nodes）
除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H
  子節點（Children）
每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D
  父節點（Parent）
每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C
  祖先節點（Ancestor）
指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—佇列（Queue）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-6-queue/</link>
      <pubDate>Fri, 21 May 2021 10:54:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-6-queue/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。
佇列基本運算具備以下五種工作定義
   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET Core】相依性注入 Dependency Injection</title>
      <link>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</link>
      <pubDate>Thu, 20 May 2021 15:41:33 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</guid>
      <description>【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&amp;#34;Message:{message}&amp;#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&amp;#34;MyClass get a message&amp;#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—堆疊（Stack）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-5-stack/</link>
      <pubDate>Wed, 19 May 2021 13:53:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-5-stack/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。
堆疊基本運算具備以下五種工作定義
   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET】使用 C# 操作檔案 I/O 與檔案系統（一）</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</link>
      <pubDate>Tue, 18 May 2021 11:11:56 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</guid>
      <description>在 .NET 框架中，命名空間 System.IO 已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西
 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。
流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。
Start FileSystemInfo 類別是檔案系統類別的基礎類別，繼承該類別的子類別有
 File - 負責檔案系統中的檔案，屬靜態類別 FileInfo - 負責檔案系統中的檔案 Directory - 負責檔案系統中的資料夾，屬靜態類別 DirectoryInfo - 負責檔案系統中的資料夾  另外還有位於 System.IO 命名空間下其餘相關的類別
 Path - 負責檔案系統中的路徑 DriveInfo - 負責磁碟機資訊的訪問  File 與 FileInfo 的區別在於 Info 類別需要實體化，而一般 File 是屬於靜態類別；Directory 與 DirectoryInfo 同理，Directory 是靜態類別，DirectoryInfo 需實體化類別。
FileInfo 使用 FileInfo 類別建立檔案，並且寫入資料
/// &amp;lt;summary&amp;gt; /// 建立檔案並寫入資料 /// &amp;lt;/summary&amp;gt; public static void CreateFileByFileInfo() { // 實體化 FileInfo 並指予路徑  FileInfo file = new FileInfo(@&amp;#34;D:\Test.</description>
    </item>
    
    <item>
      <title>【MSSQL】顯示 SQL 執行指令的時間</title>
      <link>https://fakestandard.github.io/post/mssql/mssql-2-setstatisticstime/</link>
      <pubDate>Fri, 14 May 2021 16:58:49 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/mssql/mssql-2-setstatisticstime/</guid>
      <description>紀錄一項非常基本的常識。
MS SQL 在預設的情況下執行查詢指令，會將結果訊息顯示在下方，如下圖
其實在預設情況下也是可以在右下角看到執行時間，不過這個執行時間只能讀到秒。某天無意間看到別人在執行查詢指令時，在結果訊息視窗竟能印出詳細資訊，特別紀錄一下這非常簡單我卻不會的技能。
Step 1 新增一個查詢視窗，在功能列表選擇查詢→查詢選項
Step 2 左側選擇執行→進階，勾選【SET STATISTICS TIME】
Step 3 左側選擇結果→文字，勾選【在結果集裡包含查詢】
Step 4 執行查詢指令查看結果訊息
非常簡單的操作，如果還想知道關於結果訊息的相關設定，也都在查詢選項裡面設置！</description>
    </item>
    
    <item>
      <title>【.NET Core】Application Startup Class</title>
      <link>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</link>
      <pubDate>Thu, 13 May 2021 16:23:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</guid>
      <description>【ASP.NET Core 5】
在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。
Start 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup&amp;lt;T&amp;gt; 方法，其中泛型 &amp;lt;T&amp;gt; 預設為 Startup
public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { // 配置啟動類別位置  webBuilder.UseStartup&amp;lt;Startup&amp;gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup&amp;lt;T&amp;gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯入 Excel</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</link>
      <pubDate>Tue, 11 May 2021 10:00:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</guid>
      <description>在網站開發時，總會遇到匯出 EXCEL 的需求，除了匯出之外，偶爾也會遇到匯入 EXCEL 這種懶人需求。
為何是懶人需求呢？通常使用者可以透過 UI 介面來維護資料，包括 CRUD 等功能，所以 Excel 資料會先透過前端介面在將資料傳遞到資料庫儲存。而匯入的方式，可以一次傳遞多筆資料，並且直達資料庫，過程中不需要使用 UI 介面逐筆輸入，非常省時又省力。
註：此篇使用 ASP.NET Core 5 實作
Start 首先到 NuGet 下載 NPOI 套件並安裝到專案中
建立 ImportController.cs
public class ImportController : Controller { public IActionResult Index() { return View(); } } 建立 Index.cshtml
&amp;lt;h2&amp;gt;Import&amp;lt;/h2&amp;gt; @using (Html.BeginForm(&amp;#34;Upload&amp;#34;, &amp;#34;Import&amp;#34;, FormMethod.Post, new { enctype = &amp;#34;multipart/form-data&amp;#34; })) { &amp;lt;input type=&amp;#34;file&amp;#34; class=&amp;#34;form-control&amp;#34; name=&amp;#34;file&amp;#34; /&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; class=&amp;#34;btn btn-primary&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; } 在 Controller 中新增一個接收 HttpPost 的 ActionResult Upload，除了返回頁面之外，沒有任何代碼。</description>
    </item>
    
    <item>
      <title>【.NET】將資料匯出成 CSV</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</link>
      <pubDate>Sun, 09 May 2021 14:31:15 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</guid>
      <description>前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。
Start 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下
Model public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable&amp;lt;Export_ClosedXML.</description>
    </item>
    
    <item>
      <title>【.NET】使用 ClosedXML 實現匯出 Excel 功能</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</link>
      <pubDate>Sat, 08 May 2021 10:28:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</guid>
      <description>開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。
這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub
【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用
Start 首先到 NuGet 安裝套件
Model 建立資料模型
public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料
public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—鏈結串列（Linked List）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</link>
      <pubDate>Fri, 30 Apr 2021 16:09:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</guid>
      <description>【4/14 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。
在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成
 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。
日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。
對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。
Note 特性
 記憶體空間配置的儲存方式為不連續且隨機  優點
 刪除或插入資料無須移動大量資料  缺點
 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【Life Trip】五峰星空下露營區</title>
      <link>https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/</link>
      <pubDate>Thu, 29 Apr 2021 21:40:22 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/lifetrip/lifetrip-2-hsinchu-wufeng/</guid>
      <description>【紀錄 2021/4/2-4/4】
2021 年，排除春節時的假期，就屬四月份的假期最熱鬧，月初有個清明，月底有個勞動，雙節恰巧都遇假日，賺到整整三天的假期（調整放假），上班族們放的不亦樂乎，筆者卻是放到筋疲力盡…然而今年清明節與兒童節在同一日，不巧的是剛好這兩個節日都需要補假（不是補班喔！貫老闆請閃邊～）
這次難得四天連假，索性安排其中三日出遊，留下一日給開工前的收心做準備，以及最重要的事——回血。由於本人血條實在沒有太厚，每次露營結束的隔日，體力幾乎是透支光光，一滴血都不剩，返家當日也是倒頭就睡，隔日血條還不一定能回滿，這血條的厚度以及恢復的能力實在是非常人能及阿～
話說回來，這次 W 找了一夥人參與此次露營，至於當時是如何湊起「九人團」 ，已記不清，只知道大家很用心的在準備，非常認真地看待這次露營，反觀自己真是小廢物，因為這次九人團根本不是我的局，這些人之中有見過幾次面，但不是很熟悉的人，也有一面之識，甚至還有素昧平生之人，豈能不是場硬仗！
因人數眾多，出遊前各路好手已準備「露營清單」，清楚地列出每餐要吃的食物，以及要準備的食材，需要租借的露營用品等等，每個項目的後方，也都清楚標記認領該項目的人士，當然酒水也是不可或缺的項目。
出發前一日晚上的行程，我與 W 先前往橡木桶採買我們要準備的部分—Vodka &amp;amp; Lime juice，接著與同行友人 Tina 前往 Costco 採買蔬菜，採買完各自放飛回家整理行李，待 Tina 整理完再去接她的大型行李，出發日再接她本人；為了讓我的乘客坐的舒適，以及所有物品也能在行車中穩穩地不亂滑，所以，行李和露營裝備到期後，就輪到本人與後車箱的空間戰。
出發當日，載到友人 Tina 便快速駛向高速公路，假期雖有實施高乘載，估計湧入的車潮不容小覷，不想遇到塞車的我，便要求本車乘客早早出發，抵達集合點在睡個回籠覺等待集合時間到來。在自認為會是第一台抵達集合點的同時，得知同行的別台車已搶先抵達目的地準備入睡，不得不佩服，避開高乘載搶在六點前駛上高速公路的他們，給予愛的鼓勵三次！
第一站集合地點是全聯芎林文德店，隔壁有間 7-11，它的側邊非常好停車，所有人到齊後便前往全聯採買一些新鮮蔬果，怕生的我，決定留在原地顧車，緩衝一下待會要面對一個不熟悉的群體，本以為 W 會拒絕，希望我能與大夥一同前往，沒想到她爽快的答應，只因她覺得車看起來很髒，要求我緩衝的同時，順便清理車上的鳥屎，一大清早人煙稀少，清一下也無妨，趁大夥背影消失，拿起衛生紙和礦泉水快速地擦拭，在沒有抹布的情況下，終於結束這個不太簡單的任務。
第二站來到「早點名」芎林店，是間露營生活館，除販售露營器材也有租借用品，我們此次要租借的主要項目是共同空間使用的天幕，額外還有同行友人的帳篷及充氣床等等。確認好所有裝備、食材等物品都到齊，出發上山！
沿途的山路蠻好開，會車的空間蠻OK，路也不會太陡峭，一路開上山可以發現，這座山頭露營區非常密集，我們途中不多做停留，一路殺到目的地「星空下露營區」
這次營區的營地空間非常大，車可直接停在帳篷旁邊，就算停在帳篷旁，剩下能使用的空間還蠻寬敞，不會感覺到擁擠；有些營區在營地空間上規劃不太好，為了多賺一帳的錢，會把每個營地的空間縮小，想辦法再擠出一個位置，讓帳與帳之間非常緊密，相對活動空間也會變小，再者，若隔壁帳非自己人而是陌生人，這麼近距離的相處，想必有些人是無法接受的。
敲敲打打的一行人
因租借的天幕很大，原本有點擔心會沒有空間搭設，但是完全不會！搭完天幕剩餘的空間還綽綽有餘，這個營地的空間，讓我們非常滿意，衛浴設備也蠻乾淨，會有人定時清掃，旁邊還有小小咖啡廳以及誠實商店！我們在誠實商店出入的頻率算蠻高的，主要都在買飲料和啤酒，而且都是冰涼的～對了！小小咖啡廳內有製冰機，可以向櫃台購買 $40/袋。
努力掛內帳的孩子
第一日除努力搭帳外，大夥之間也還不太熟悉，彼此還在慢慢摸索相互認識，且找出最合適的相處方式，在天幕搭設完成後，主廚團就開始料理午餐，因為時間關係，煮了最快速就能食用的餃子，讓大夥填飽肚子。完食後，麻將團已經等不及摸兩把了！
度過優閒的下午，迅速地來到晚餐時間，第一天晚餐「麻辣鴛鴦鍋」，筆者要特別讚賞一下這鍋物，首先湯底選的很不錯，不論是麻辣或不辣，兩者吃起來非常順口又搭配，另火鍋肉片雖然價位偏貴，卻神算的無敵好吃，必須推薦！值得再回味！
麻辣鴛鴦鍋
晚飯後，大夥會一起收拾碗盤，且陸陸續續的去盥洗，沒事的時候坐回共用桌子，滑滑手機或與其他人閒聊，這點大家很有默契，筆者也非常喜歡這種感覺，而且，大家在使用手機的時間都不會太長，這點也蠻優秀的。
山裡的夜晚，配上一杯香醇的酒，遠離都市繁忙的步調，靜靜地品上一口，在天黑時刻，閉上眼，開啟一場毀滅人性的桌遊「獵巫鎮」！
因筆者沒有參加，過程中的刺激感沒有體會到，從旁觀戰也有得到不少心得，像這種類型的遊戲，在互相不熟悉的情況下，感覺會比較好玩和刺激。大夥簡單玩了幾場後，也到了該睡覺的時間，大家陸陸續續的收拾，由於山裡野狗野貓很多，有時半夜會有狗來巡邏，建議要把食材等食品收拾好，食材都整理到筆者的帳篷內之後，大夥也就陸續的入睡。
無用配件
冰淇淋燈在夜晚時超趣味，最近與 W 的新歡之一，雖然它很無用 XD
隔日，天一亮，隔壁帳的夥伴起床後就想覓食，聽說他們在天幕東敲敲西找找，就是找不到食物 XD，後來才得知食材都在筆者帳篷內，於是他們強行進入帳篷奪取食材，還不忘叫醒我們。
第二日的早餐，有蛋餅和熱壓吐司可以食用，筆者也煎了自己的蛋餅，其實今年筆者慢慢地發現烹飪其實不難，難的是備料的過程，最重要的是如何煮出極佳的味道，我想其中的道理應該跟軟體工程相似，需要細嚼慢嚥了解其中的奧妙。
早餐剛吃完準備接續準備午餐，午餐有從好市多購入的牛排，其次有超強羅宋湯，這鍋主廚團可是熬煮了很久，貌似因為馬鈴薯煮不爛 XD，還有專業的義大利麵，結束這回合。
專業備料
專業煎牛排組
羅宋湯 &amp;amp; 牛排
結束一輪吃貨回合，悠閒的下午，大夥喝著酒聊天，最後還是逃不過命運轉盤，準備上戰場開殺！筆者第一天沒有下去打，原因是礙於多年未打，反應應該會延遲不少，再加上逢賭必輸，近似值為零的偏財運，筆者對此有著深刻覺悟，說不就不！
大夥從第一天熱情邀約，一直來到第二天，這熱情彷彿不會退去似，連勇敢說不的我，也只好與大夥打上一場，結果不用想，依然是輸錢，牆壁上的正字記號在添上一筆。
打的過程中，得知其中兩位朋友有在接觸股票，另一位則完全沒有接觸，於是乎，他邊打邊請益二位朋友，不過筆者聽起來，這二位朋友貌似已走遠，由於有注入資金且持續操作，理解的範圍已有一定的落差。個人認為應先對基礎觀念有一定的了解，且對市場持續觀望尚未進場，再來請教，才會有較大的收穫。
這天的下午，男伴們都在牌桌上打牌，女伴們窩在筆者帳篷，享受下午茶點心。
W 老闆的下午茶
時間飛快地來到傍晚，有個意外小插曲，我們家 W 貌似被工作纏身，筆者只好默默陪伴工作，請大夥先繼續活動，我與 W 要離開現場一會去工作，此時大家也說還不太餓，決定晚點在準備晚餐，大夥人都挺好。
有位 J 朋友貌似剛好生日，一行人早就在上山前準備好蛋糕，請 J 的老公拿蛋糕出場，過程中 J 不頓詢問怎麼有蛋糕，大夥配合度也是相對高，一直說蛋糕是吳柏毅送來的，備註寫上五千小費，它就來了，很有趣。</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯出 Excel 的基本應用</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</link>
      <pubDate>Tue, 27 Apr 2021 14:08:05 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</guid>
      <description>開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。
代碼存放於 GitHub
Start 首先到 NuGet 套件添加 NPOI Package
建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable
/// &amp;lt;summary&amp;gt; /// 資料庫連線方法 /// &amp;lt;/summary&amp;gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = &amp;#34;.&amp;#34;; cnsb.InitialCatalog = &amp;#34;Northwind&amp;#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = &amp;#34;SELECT * FROM [Northwind].[dbo].[Orders]&amp;#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—陣列（Array）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-3-array/</link>
      <pubDate>Mon, 26 Apr 2021 16:34:39 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-3-array/</guid>
      <description>【4/11 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。
靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。
操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。
陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。
使用一維陣列尋找和儲存 1~num 之間的所有質數
const int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m &amp;lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i &amp;lt; num; i++) { if (prime[i]) { if (c == 10) { Console.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構定義與資料型態</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</link>
      <pubDate>Sun, 25 Apr 2021 13:26:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</guid>
      <description>【4/11 閱讀紀錄】
此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。
Start 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。
一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。
資料型態
 基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）  記憶體儲存方式
 靜態資料結構（Static data structure） 動態資料結構（Dynamic data structure）   資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。
  基本資料型態（Primitive Data Type）
基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。
  結構化資料型態（Structured Data Type）
結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。
  抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。
  記憶體儲存方式 若以記憶體儲存的方式來看資料結構，可以區分為兩種
  靜態資料結構（Static data structure）
靜態資料結構是將有序數列的資料，儲存於連續的記憶體空間，故在編譯時就得先配置記憶體空間，所以在初期須先宣告固定的記憶體空間，優點是連續記憶體設計時叫簡易，且讀取與修改任一元素的時間都是固定，缺點則是刪除或加入需要移動大量的資料，而最典型的靜態資料結構就是陣列。
  動態資料結構（Dynamic data structure）
動態資料結構是將有序數列的資料，儲存於不連續的記憶體空間，不須在編譯時先配置記憶體，因記憶體配置是發生在執行時，故能節省記憶體空間，在插入和刪除也相當方便，它不需要移動大量資料，缺點則是設計時較麻煩，讀取、修改或搜尋時，無法像靜態資料結構一樣直接取出資料，必須透過走訪找到目標資料為止。動態資料結構的代表是鏈結串列。
  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET】西元年與民國年相互轉換</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</link>
      <pubDate>Mon, 19 Apr 2021 14:58:59 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</guid>
      <description>這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。
一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。
西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。
Solution 有三種解決方案
 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間
引用命名空間
 System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $&amp;#34;{year}/{month}/{day}&amp;#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。
/// &amp;lt;summary&amp;gt; /// 靜態擴展類別 /// &amp;lt;/summary&amp;gt; public static class DateTimeExtend { /// &amp;lt;summary&amp;gt;  /// 靜態擴展方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;dateTime&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.</description>
    </item>
    
    <item>
      <title>【人森】如何計算個人綜合所得稅？</title>
      <link>https://fakestandard.github.io/post/other/other-2-incometax/</link>
      <pubDate>Wed, 14 Apr 2021 11:19:05 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/other/other-2-incometax/</guid>
      <description>一年一度的報稅季節即將來臨，過去在申報時並未了解太多資訊，反正申報沒問題即可，有問題再給補差額就好（奶茶加價概念），去年 2020 年所得稅申報的基本規範出現變動，去年的我也只是快速瀏覽過這些變革，並未詳細了解內容，趁著報稅季開始前，依照個人情況順手作個整理。
首先要了解所得稅分為以下兩種
 綜合所得稅 營利事業所得稅  這篇只探討綜合所得稅的部分，因筆者也沒有營利的事業可以被扣稅，希望有天也能被要求繳納營利事業所得稅，屆時有經驗再分享（笑）
所得稅申報時間？ 有申報經驗的人這題已是基本常識，對於申報新手請務必牢記一年一度的申報時間從 5 月 1 日 到 5 月 31 日，若未在報稅期間申報，除了補報之外，繳納金額還會加上利息，若被稅捐機關發現則會處置 3倍 以下的罰緩。
收入多少需要報稅？ 在所得稅改制之後，單身者在去年整年度的收入未滿 40.8 萬者免繳稅，該身份（單身者）就是在下，接下來也會依照筆者身份加以紀錄且計算，如果你是第一次申報者但有收入免繳稅，建議還是要申報，因為隔年度收到稅額試算表時，或許能輕鬆完成報稅流程。
計算綜合所得稅淨額 進入絕大部分的人覺得複雜的部分，要如何計算綜合所得稅淨額？其實很簡單，它是用一個公式可計算出來的
綜合所得淨額 = 所得總額 - 免稅額 - 標準/列舉扣除額 - 特別扣除額 - 基本生活費差額
接下來一一拆解公式內的專有名詞，將符合自身情況的金額填入完成該公式計算。
所得總額 所得總額是過去整年度的收入總額（有點饒舌），以一般上班族來說，「薪資所得」佔該總額的絕大部分，基本上可以直接以薪資所得填入，但是！該收入還包含其他林林總總的項目，包括營利、執行業務、利息、租賃、權利金、財產交易、競技競賽、機會中獎之獎金或給予、退職等所得項目，如果個人有以上這些項目收入，也要一併計入。
假設你今天是包租公/婆，將一套個人房屋出租，每年能收到的租金為 12 萬，該筆收入就得計入租賃項目；假設你今天是一般小職員，在尾牙抽中頭獎 5 萬，該筆收入以機會中獎之獎金項目計入。
那薪資所得是要填實領薪資還是申報薪資？一般公司年末時會提供扣繳憑單，依照扣繳憑單上的給付總額來填寫，可以注意到該欄位後方註明「結算申報時應按本欄數額填報」，就按單子上所的規範填入；在給付總額後方可以看到「扣繳率」以及「扣繳稅額」，該欄位是公司先預扣稅額的部分，如果有被預先扣除，申報時要記得申報已經被扣的金額，最後結算時若預扣金額大於繳納金額，政府會退稅給納稅義務人喔！
另外，一般公司年末會發放年終獎金，通常該項目公司會一起申報成薪資所得部分，如果公司已經申報成薪資部分，千萬不要再以獎金計入囉，不然這個金額就會重複申報兩次，那可是虧大了！BTW 年終獎金若超過 84,501 元，公司需按全數金額預先扣繳 5% 稅款，所以有被扣除這 5% 的部分也要記得申報。
免稅額 該項目是可扣除的稅額，分為以下兩種，通常以第一項計算，第二項適用年滿 70 歲的納稅義務人
   身份 可扣除額度     納稅義務人、配偶、受扶養親屬（兒童或年長者） 88,000/人   年滿70歲之納稅義務人、配偶、受扶養之直系尊親屬 132,000/人    由上述可知，納稅義務人就是自己本身，未滿 70 歲的納稅義務人可先扣除額 88,000，若有配偶或是有申報扶養眷屬，每一個人頭的額度為 88,000（聽起來像詐騙集團），假設我有扶養一個眷屬，除自身外還可多扣除一人的額度，可扣除的免稅額為 88,000 * 2 = 176,000，以此類推。</description>
    </item>
    
    <item>
      <title>【Windows】開啟運行程式的所在資料夾位置</title>
      <link>https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/</link>
      <pubDate>Mon, 12 Apr 2021 11:48:04 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-7-openwindowsexplorer/</guid>
      <description>Issue 應用程式安裝時會讓使用者選擇安裝路徑，假設安裝路徑有天忘記了，或是資料夾位置太深層，需要每個資料夾打開確認。
還好有個方法可以快速開啟安裝位置，不過有個前提，必須先運行應用程式。
Solution 該解決方法是針對已經開啟的程式，首先開啟工作管理員，切換到【應用程序】頁簽或是【詳細資料】頁簽也可以，找到運行的應用程式執行右鍵，選擇【開啟檔案位置】就開啟安裝位置囉！</description>
    </item>
    
    <item>
      <title>【.NET】適合初心者的 .NET Core MVC 實作</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/</link>
      <pubDate>Sat, 10 Apr 2021 14:06:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-2-mvc-movielist/</guid>
      <description>此篇會照著官方文件 Step by step 從中學習 Web 應用程式之 MVC，過程中會了解如何建立 Web 應用程式、新增及 Scaffold 模型、使用資料庫、資料的 CRUD、新增搜尋和驗證，最後會完成一個有關電影清單的應用程式。
UI 的介紹會以 IDE 為主，除 UI 外也會介紹 dotnet 指令。
代碼部分已上傳到 GitHub
Start  建立 Web app 新增控制器（Controller） 新增檢視器（View）auto 新增模型（Model） 新增 NuGet 套件 建立 DbContext 新增 ConnectionString 使用 Scaffold 進行初始移轉（Initial Migration） 植入資料以初始資料庫 使用資料註釋 Data Annotations 新增搜尋引擎 新增資料驗證 使用 Bootstrap 增強外觀效果  建立 Web app 提供兩種方法，一種透過 Visual Studio IDE，一種是使用 Command shell 操作，兩種皆可達相同結果。
Visual Studio IDE 建立 【ASP.NET Core Web 應用程式】</description>
    </item>
    
    <item>
      <title>【Algorithm】經典演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</link>
      <pubDate>Mon, 05 Apr 2021 13:41:55 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</guid>
      <description>【3/28 閱讀紀錄】
此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。
Start 演算法種類很多，經典的演算法有以下幾種
 分治演算法（Divide and conquer） 迭代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Exhaustive Searching） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。
像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。
然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。
所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。
迭代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為迭代演算法，像是透過迴圈去循環重複的程式碼來得到答案。
舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果
// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i &amp;lt;= n; i++) { for (int j = i; j &amp;gt; 0; j--) { sum = sum * j; } Console.</description>
    </item>
    
    <item>
      <title>【Windows】如何分割視窗/畫面</title>
      <link>https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/</link>
      <pubDate>Thu, 01 Apr 2021 12:59:03 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-6-cutoverwindows/</guid>
      <description>Issue 我們在使用文件或是檔案時，需同時對兩份文件做比對，所以不想只有一個視窗佔滿整個螢幕，那要如何在 Windows 畫面上同時開啟兩個視窗，並將其視窗放置一左一右？
Solution 最簡單的方法是調整視窗大小，將視窗大小調成螢幕大小的一半，一個放左，一個放右，讓彼此不重疊。
如果不常需要這樣的操作倒也還好，但若久久就要一次，這個動作就顯得麻煩許多了，心裡不禁暗自問「有沒有可以直接將視窗分割的辦法」，答案是有的！甚至還可以幫你調整成固定大小！
視窗分割為兩個畫面 假設有兩份 Word 分別為 A、B 檔
 開啟 A 檔案 使用 Win + ← （Windows 鍵 + 方向左鍵）  此時 A 檔案就會以固定的大小開啟在螢幕左側
 開啟 B 檔案 使用 Win + → （Windows 鍵 + 方向右鍵）  B 檔案也會以固定大小開啟在螢幕的右側，此時你會發現，兩個檔案已經成功的放置在一左一右，而且還以滿版的方式填滿了螢幕。
視窗分割為四個畫面 除了左右分割畫面之外，還提供四個等份分割的畫面，分別為左上、左下、右上及右下。方法很簡單，先將前兩個檔案固定好視窗位置
 開啟第三個檔案 使用上述的快捷鍵將檔案放置欲放置的其中一側 使用 Win + ↓（Windows 鍵 + 方向下鍵）  此時檔案就會開啟在選定的一側的下方，等同於左側的視窗又被對半切割，而這次切割的方向為上下，與前述不同的地方就是切割方向改變，如此一來第四份檔案也可使用相同的步驟放置到欲擺放的視窗位置。</description>
    </item>
    
    <item>
      <title>【Windows】使用 DOS 指令切換當前硬碟</title>
      <link>https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/</link>
      <pubDate>Wed, 31 Mar 2021 15:53:25 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-5-cmdcutoverdisk/</guid>
      <description>紀錄一下每次使用命令提示字元想從 C:\ 切換到 D:\ 時，都會喪失記憶，一直使用 CD D:\ 都沒有反應，切老半天就是想不起來，每次都依賴谷哥大神。
其實切換硬碟只要直接下 D: 即可，每每看到切換方法後都捶心肝，這裡也順便紀錄，CD 是切換當前目錄，切換硬碟是另一回事，所以直接對欲切換的硬碟下該硬碟名稱即可。</description>
    </item>
    
    <item>
      <title>【MSSQL】如何改善 SQL 常見的效能問題</title>
      <link>https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/</link>
      <pubDate>Tue, 30 Mar 2021 10:42:18 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/mssql/mssql-1-performanceissues/</guid>
      <description>Start 一直以來筆者在寫 SQL 語法時從不考量效能問題，以為效能調教是等到發生後由高手們來解題，輪不到我們這種小咖來煩惱，殊不知我們這種咖小也可以提前優化效能！所以這篇要來紀錄 SQL 一些常見的效能問題，比如應該避免使用哪些語法，為何要避免使用？在筆者有限的能力下也會盡量寫 Lab 觀察數據。
查詢優化 同樣的查詢結果會有不同寫法，但哪些寫法是比較好的？其實查詢時，應該要避免全表掃描（Full Table Scan）
何謂全表掃描（Full Table Scan）？
簡單來說，就是 SQL Agent 在查詢時會從頭開始掃描整張資料表，無論是否已經取得最終結果，都會掃描到最後一筆資料才結束。
以下是在 WHERE 條件中應盡量避免使用的語法，它們會導致 SQL Agent 放棄使用索引，從而進行 Full Table Scan。
  避免使用 NULL
SELECT OrderID FROM A WHERE ProductID IS NULL -- 應改為 SELECT OrderID FROM A WHERE ProductID = 0   避免使用 &amp;lt;&amp;gt; 和 !=，使用 &amp;gt;= 或 &amp;lt;= 來取代
  避免使用 or 來連接條件
SELECT OrderID FROM [Northwind].[dbo].[Orders] WHERE EmployeeID = 4 OR EmployeeID = 5 -- 將 or 替換成 UNION ALL SELECT OrderID FROM [Northwind].</description>
    </item>
    
    <item>
      <title>【.NET】打造 Blazor ToDoList</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/</link>
      <pubDate>Sun, 28 Mar 2021 21:47:49 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-1-blazor/</guid>
      <description>Prerequisites .NET 5.0 SDK 或之後的版本
Start 使用 VS 2019 建立 Blazor，跟隨官網文件 Step by step。
建立新專案 選擇【Blazor 應用程式】專案
選擇【Blazor Server 應用程式】樣板
建立 Razor 元件 新建立的專案在方案總管下的 Pages 資料夾內，可以看到已經有建立好的預設頁面，在該資料夾下建立 Todo.razor。
建立 Razor 元件時要注意
 檔案名稱開頭第一個字母必須大寫 副檔名為 .razor 結尾  將 Todo 元件添加到導航列 開啟 Pages/Todo.razor 添加相對應的 URL @page &amp;quot;/todo&amp;quot;
@page &amp;#34;/todo&amp;#34; &amp;lt;h3&amp;gt;Todo&amp;lt;/h3&amp;gt; @code { } 開啟 Shared/NavMenu.razor，此 razor 為應用程式其中一個版面配置，可避免應用程式中使用重複的元件，在此配置中添加以下代碼
&amp;lt;ul class=&amp;#34;nav flex-column&amp;#34;&amp;gt; ... &amp;lt;li class=&amp;#34;nav-item px-3&amp;#34;&amp;gt; &amp;lt;NavLink class=&amp;#34;nav-link&amp;#34; href=&amp;#34;todo&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;oi oi-list-rich&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; Todo &amp;lt;/NavLink&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 建立 TodoItem 類別 在專案目錄下建立 /TodoList/TodoItem.</description>
    </item>
    
    <item>
      <title>【Windows】如何改變命令提示字元(cmd)視窗預設大小</title>
      <link>https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/</link>
      <pubDate>Sat, 27 Mar 2021 21:56:15 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-4-cmdadjustmentdefaultsize/</guid>
      <description>Issue 常常在使用命令提示字元時，發現視窗大小總是不如我意，原本看順眼的視窗大小，不知道為何會跑掉？視窗太大或太小對我來說的干擾不高，比較麻煩的是每次打開都變成寬度超長的長方形，在下達指令時心裡總是有種不舒服。讓我來改變一下作業系統對命令提示字元預設的視窗大小吧！
Solution Step1 開啟 cmd.ext，對左上視窗名稱【命令提示字元】左邊的圖標點一下開啟選單，或是右鍵也可以開啟選單，選擇【預設值】
Step2 切換到【版面配置】頁簽，找到【視窗大小】的控制版（panel），這邊就可以直接對寬度與高度做調整，甚至還有其他控制版的數據可供設定。
Note 【OS】Win10</description>
    </item>
    
    <item>
      <title>【Windows】分享本地硬碟供遠端使用</title>
      <link>https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/</link>
      <pubDate>Fri, 26 Mar 2021 16:45:48 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-3-remotedesktopconnection-sharedisk/</guid>
      <description>Issue 某次使用遠端桌面時想把 .bak 複製到本地機器，熱鍵 Ctrl + C &amp;amp; Ctrl + V 後跑到一半就不跑了，天真以為這容量不大就可以用【複製/貼上】功能，殊不知有正統的作法。
Solution 當本地和遠端想要分享檔案時，最好使用 Share Disk，將本地硬碟 Share 給遠端使用，此時遠端就可以存取本地的硬碟。
Step1 開啟顯示選項，切換到【本機資源】頁簽，在【本機裝置和資源】 panel 按下【其他】
Step2 展開磁碟機選擇要與遠端分享的硬碟
Step3 開啟檔案總管就可以在本機下看到本地硬碟已與遠端共享
Note OK. 如此一來就可以直接在遠端將資源儲存到本地硬碟，當遠端關閉時，Share 的硬碟也會隨之關閉。</description>
    </item>
    
    <item>
      <title>【Windows】遠端桌面連線無法複製貼上？</title>
      <link>https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/</link>
      <pubDate>Thu, 25 Mar 2021 16:13:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-2-remotedesktopconnection-rdpclip/</guid>
      <description>Issue 最近在 Win10 上使用遠端桌面連線時，需要在本地和遠端進行複製 &amp;amp; 貼上動作，但此功能忽然失效？不論是快捷鍵或介面操作，就是無法使用。
Solution Step1 檢查剪貼簿功能是否有開啟
【傳送門】【Windows】開啟遠端桌面連線剪貼簿功能
Step2 可能原因是遠端的檔案複製（File Copy）程序沒有回應，開啟工作管理員找到 Rdpclip.exe 將它關閉，再結束遠端連線，隨後再使用本地主機執行遠端連線即可恢復。
Note 那麼為何 File Copy 會當掉？
有可能是伺服器的記憶體不足或者記憶體滿載，較忙碌的伺服器也有高機率發生當掉的情況。</description>
    </item>
    
    <item>
      <title>【Windows】開啟遠端桌面連線剪貼簿/印表機功能</title>
      <link>https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/</link>
      <pubDate>Wed, 24 Mar 2021 20:25:01 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/windows/windows-1-remotedesktopconnection-rdp/</guid>
      <description>Issue  一般操作電腦複製/貼上功能總少不了，當使用本地機器遠端到其他機器也想使用該功能時，發現不能用？ 當遠端桌面連線想共用本機的印表機資源時，該怎麼辦？  Solution 開啟遠端桌面連線並展開顯示選項，切換到【本機資源】頁簽，在本機和裝置資源的 panel 將欲操作的【印表機】或【剪貼簿】勾選即可
Note 假設剪貼簿已經開啟，遠端依然無法使用複製/貼上功能？
【傳送門】【Windows】遠端桌面連線無法複製貼上？</description>
    </item>
    
    <item>
      <title>【GitHub】在 GitHub Pages 建立靜態網站</title>
      <link>https://fakestandard.github.io/post/github/github-1-githubpage/</link>
      <pubDate>Mon, 22 Mar 2021 15:56:58 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/github/github-1-githubpage/</guid>
      <description>GitHub 提供一個 Web hosting service（網頁託管服務）為使用者提供存放靜態網頁、文檔等功能，讓其他人可以透過服務端來存取使用者寄放之網頁，那就是 GitHub Pages。
在開始使用 GitHub Pages 前，必須先擁有一個 GitHub 帳戶，和一些 git 的基礎知識如 pull 、 push 等。目前 GitHub 分別有免費及付費版，付費版更著重於 private repository，而免費版只接受一個私人的倉儲，其餘的 repository 皆會公開，So 若是比較私人的代碼或公開後較有爭議的 project，盡量別推送到 GitHub 上。
Create a repository 建立一個倉儲的方法不只一種，約有兩三個地方可以進入下圖建立 repository 的畫面。
首先可以看到最上方的 Owner 為自己的 GitHub 帳戶，Repository name 就是字面上的意思，但我們要使用的是 GitHub Pages，在這需要使用 github.io 的子域名作為靜態網站的網址，且在 username 的位置需與 GitHub 帳戶相同，如 GitHub 帳戶為 github123，那這裡的 Repository name 需填上 github123.github.io，在後續設置中，用戶也可以使用第三方域名。
下方的 Description 為可選填的項目，public 和 private 的單選項中必須選擇一個，預設為公開，再來還有些倉儲的初始化項目可勾選，決定好後就按下 Create repository 按鈕吧！
Git client 先為裝置安裝 git CLI，再從下列選擇一種方式來使用 Git</description>
    </item>
    
    <item>
      <title>【Life Trip】北投享溫泉/石牌老牌肉丸</title>
      <link>https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/</link>
      <pubDate>Sun, 21 Mar 2021 14:04:26 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/lifetrip/lifetrip-1-xinbei-beitou/</guid>
      <description>【紀錄 2021/3/20】
美好的禮拜六夜晚，最適合小酌一杯再搭配一部電影，結果 W 來電表示想去北投泡溫泉。
這裡穿插一個小故事，上回去新竹露營回程時找 W 去泡溫泉，毫不猶豫地拒絕我，這次主動提議說要去，理由是溫泉就是要晚上泡，下午泡沒感覺，我也是醉了～
想了想，也很久沒泡溫泉，再加上下午與妹妹一同去打球運動，懶骨頭差點散光光，不是差點扭到，就是差點閃到腰，跑沒三步就想偷懶休息，既然都要運動，也是有用力給它動起來，只是感嘆體力不如從前也。正好體力流失的我，也適合泡一下溫泉，沒有想太多就立馬答應 W，晚上十點啟程，驅車前往北投的「享溫泉」桑一下～
周末台北的夜晚，終於不那麼塞車，咻一下的就來到北投，不得不說北投這兒的路，不是在地、沒有導航，別輕易嘗試，有導航的我一下高速公路就遺失方向感…
本想試試看價格略高的客房，出發前先打給店家詢問，因周末的關係生意好到客房已滿位，只剩下湯屋可以享用，但也無妨。兩人就開始一趟悶汗之旅，把身體毒素通通排出體外～
正門口
建築物外觀
湯屋內設施
正門木頭椅
整體上來說算不錯，泡湯時間為 60 + 30 分鐘，走到外面才發現原來這棟建築物不大，樓層也不高，兩人猜測客房數量應該也不多。這裡距離新北投車站及捷運站都還算近，店家的介紹裡面表示步行 10 分鐘能抵達，是個挺方便的位置。
結論，下次想使用客房得提前先預訂。
BTW 我們是當晚從 KLOOK 上面購買，再前往實體店家使用，不過當日購買要當日使用的情形，建議先打電話給店家確認是否可以當日使用票券會比較保險！
泡完後，兩人肚子相繼演奏起交響樂，便快速地搜尋在地宵夜，找到 石牌老牌肉丸 傳統小吃攤販，位於裕民一路20號，導航路線不算遠，飢腸轆轆的兩人，馬上出發前往石牌夜市來飽食一頓。
取自網路的招牌
美食享用
兩人分別點了兩個肉圓、一碗甜不辣、菜頭貢丸湯和四神湯各一碗，整體上來說算不錯吃，但熱愛四神的我，發現湯裡沒有淮山（山藥）和蓮子，老實說心裡很不是滋味。
原先預計吃完宵夜想買個鹹酥雞在回程的路上享用，但吃完這頓後，胃已無空間放下任何食物，只好等待下次再來泡溫泉時享用～
到家時間 am 2:30</description>
    </item>
    
    <item>
      <title>【Markdown】筆記神器</title>
      <link>https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/</link>
      <pubDate>Fri, 19 Mar 2021 09:46:52 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/markdown/markdown-1-heymarkdown/</guid>
      <description>前言 Markdown 易讀易寫，學一次就會，許久不用也不會忘。
應用 目前越來越多服務支援 Markdown 編寫，而每個環境能接受的語法略有不同，以下則介紹通用的使用方式。
標題 標題分為六個層級（有些環境只接受三個層級），標題以 # 符號為主，數量越多層級越低，反之則越高
# 標題一 ## 標題二 ### 標題三 #### 標題四 ##### 標題五 ###### 標題六  根據 HTML 結構，相應的轉換為 &amp;lt;h1&amp;gt; 到 &amp;lt;h6&amp;gt;，呈現效果如下 文字強調 文字可使用粗體、斜體以強調字詞，分別使用 * 和 _ 符號包圍，且必須有頭有尾，意即用什麼符號開啟標籤，就要用什麼符號結束。
斜體 使用 * 或 _ 包圍文字，被包圍的文字會被轉換成 &amp;lt;em&amp;gt; 標籤包圍
*Single asterisks* _Single underscores_ 粗體 一樣使用 * 和 _ 標記，與斜體不同的地方為一次需使用兩個標記，最後轉換成 &amp;lt;strong&amp;gt;
**Double asterisks** __Double underscores__ 粗斜體 根據上面兩個格式衍伸，粗斜體直接使用三個 * 或 _ 即可呈現
***Bold italic*** ___Bold italic___ 文字段落 一般撰寫未添加任何標記符號時，該區塊文字即為文字段落區塊，當區塊文字與區塊文字之間使用 Enter 鍵換行，會形成兩個段落，段落與段落之間會明顯地保留一行空白，且轉換成 HTML 對應的 &amp;lt;p&amp;gt;。</description>
    </item>
    
    <item>
      <title>【賀】新開張！</title>
      <link>https://fakestandard.github.io/post/other/other-1-newblog/</link>
      <pubDate>Wed, 17 Mar 2021 17:10:35 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/other/other-1-newblog/</guid>
      <description>前言 恭賀本人的部落格又開張了！
歷經長久思考，最終還是得有個小角落紀錄生活點滴，更多的是工作日常以及技術方面的哩哩叩叩，對 IT 人而言，技術這東西許久不用，那可是大腦折騰三百回合，也會找不到答案的折磨阿…
OK. 如果你有認真看了第一行，應該會注意到「又」這個字，為何新開張卻是又呢？請聽我娓娓道來…
正文 本人從小未有筆記的習慣，從學生時期一直到出社會工作以來，都沒有這個良好的習慣，原因很複雜。
某年某月某一天，心血來潮翻遍各大部落格平台，於是乎選擇主打「IT 技術人的部落格平台」的點部落開啟人生第一個部落格，那時欣喜落狂的想要在部落格上記錄自己所學之技術，最後敵不過懶字…
接著 WordPress 網站如雨後春筍般地出現，不僅可以建立個人平台、打造商業品牌，甚至使用 WordPress 來接案。於是自己也跳入不需要寫任何一行 Code 即可客製化個人網站的 WordPress，寫了一陣子，還是敵不過懶字…
過了好陣子，Static site generator 慢慢受到 Frontend 喜愛，身為 Backend Engineer 怎能錯失這塊學習的機會，於是東挑挑西選選，最終選擇 Hexo 且辦了個 Github 帳號，同時還學習 Version Control System - git，再搭配 Markdown 寫作，可謂一箭三雕，對我來說 Github 及 git 當時都還是遲遲未入手的 Skill 阿…
說了這麼多，Hexo 搭建的 website 依然敵不過懶字又關門大吉了…
前路多彎折，最終還是需要部落格來擴充大腦記憶體，這次選擇用 Go 寫的 Hugo 搭建，建立過程則沒有像當初碰到 Hexo 那麼多波折（雖然還是很撞牆），因腦中對靜態網站生成器產生的結構已經有點雛形，不管選用哪個 Static site generator 都大同小異，今日花一兩個小時在 install hugo &amp;amp; pick theme，終於大功造成！
結語 在打造部落格的過程中，自己也嘗試過其他打造部落格的平台，甚至以筆記著名的 One Note 和 Notion 也佔有一席小天地，至於上述所提到的是有經營一陣子且有文章產出的，其餘未有產出的部分則不一一寫出來，實在是太多太囉嗦。</description>
    </item>
    
    <item>
      <title>Example</title>
      <link>https://fakestandard.github.io/zone/example/</link>
      <pubDate>Wed, 17 Mar 2021 14:41:48 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/zone/example/</guid>
      <description></description>
    </item>
    
    
    
  </channel>
</rss>
