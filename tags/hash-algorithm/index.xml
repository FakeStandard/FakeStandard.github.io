<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hash Algorithm on How can I help</title>
    <link>https://fakestandard.github.io/tags/hash-algorithm/</link>
    <description>Recent content in Hash Algorithm on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 09 Sep 2021 12:09:06 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/hash-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】雜湊應用—碰撞與溢位處理</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-47-hashcollisionandoverflow/</link>
      <pubDate>Thu, 09 Sep 2021 12:09:06 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-47-hashcollisionandoverflow/</guid>
      <description>【5/25 閱讀紀錄】
根據先前文章介紹的雜湊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 當要把資料放到某個 Bucket 時，若該 Bucket 已滿，則會發生溢位（Overflow）；另一種情況是，不同資料經雜湊函數運算後，得到相同的位址，則發生碰撞（Collision）。
當溢位及碰撞發生時，通常會透過下列四種演算法處理
 線性探測法 平方探測法 再雜湊 鏈結串列  線性探測法 當兩資料經雜湊函數運算後，得到相同雜湊值，則發生碰撞，此時透過線性探測法，以線性的方式往後尋找空的位置，一旦有空的位置就把資料放進去，直到找到空位，或儲存空間位址皆存滿為止。線性探測法通常把雜湊位置視為環狀結構，比如說，當雜湊值是儲存空間的最後一個位置，以線性探測法往下搜尋空位，第一個搜尋的位置會是儲存空間的第一個，所以儲存空間會是以環狀的方式進行探索。
不過線性探測法因簡易所以有先天的缺陷，若資料鍵值容易聚集在一起，要尋找空位就要尋找很久。但還是要實作一下代碼，使用除法雜湊函數取得雜湊值，以線性探測法來儲存資料。
建立靜態變數與陣列
static int INDEX = 17; static int MAX = 13; // 建立資料雜湊最大元素 static int?[] index = new int?[INDEX]; // 建立陣列儲存空間 static int[] data = new int[MAX]; 建立相關方法
/// &amp;lt;summary&amp;gt; /// 亂樹建立資料 /// &amp;lt;/summary&amp;gt; static void CreateData() { int i; Random r = new Random(); for (i = 0; i &amp;lt; MAX; i++) data[i] = r.</description>
    </item>
    
    <item>
      <title>【Algorithm】雜湊應用—雜湊演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-46-hashalgorithm/</link>
      <pubDate>Mon, 06 Sep 2021 12:08:35 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-46-hashalgorithm/</guid>
      <description>【5/24 閱讀紀錄】
根據先前文章介紹的雜湊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 雜湊法是利用雜湊函數來計算鍵值所對應的位址，進而建立雜湊表。
常見的雜湊函數有四種
 除法 中間平方法 折疊法 數位分析法  除法 除法是最簡單的雜湊演算法，原理是將資料除以某個常數（通常會選擇質數），取其餘數作為索引，在將資料儲存於索引相對應的位址。
公式是 H(key) = key mod B
假設一陣列大小為 7，欲將 12, 65, 70, 99, 67 這五個值經由雜湊法，放入相對應的位置，因陣列大小為 7，故將 B 帶入質數 7 進行雜湊，得到結果會界於 0-6 之間以符合陣列大小，如 H(12) = 12 mod 7 = 5，最後可得雜湊表如下
中間平方法 中間平方法是將資料自己做平方，再取中間的某段數字做為索引。
假設一陣列的位址空間大小為 100，欲將 12, 65, 70, 99, 67 五個值經由雜湊法，放入相對應的位址。首先，先將每個資料平方，就是資料與自己相乘，可得 144, 4225, 4900, 9801, 4489，分別取得這五個值的百位數及十分數，分別為 14, 22, 90, 80, 48，將得到的索引鍵值分別放入原先的對應值，即
f(14) = 12 f(22) = 65 f(90) = 70 f(80) = 99 f(67) = 48 折疊法 折疊法是先將資料轉換成一串數字，再將數字拆成數個部分，最後再將它們相加得到 Bucket Address。折疊法區分為以下兩種</description>
    </item>
    
  </channel>
</rss>
