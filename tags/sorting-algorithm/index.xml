<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sorting Algorithm on How can I help</title>
    <link>https://fakestandard.github.io/tags/sorting-algorithm/</link>
    <description>Recent content in Sorting Algorithm on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 21 Jun 2021 13:59:42 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/sorting-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</link>
      <pubDate>Mon, 21 Jun 2021 13:59:42 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。
假設有一陣列，陣列資料分別為
                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—基數排序法（Radix Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</link>
      <pubDate>Fri, 18 Jun 2021 13:58:45 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-16-radixsort/</guid>
      <description>【5/20 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例
LSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較
Step 1 將每個元素依照「個位數」放到相對應的串列中
                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—合併排序法（Merge Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</link>
      <pubDate>Wed, 16 Jun 2021 10:57:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-15-mergesort/</guid>
      <description>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。
步驟非常好理解，如下
 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—快速排序法（Quick Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</link>
      <pubDate>Sun, 13 Jun 2021 14:01:03 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-14-quicksort/</guid>
      <description>【5/17 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。
其步驟如下
 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I &amp;gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K
               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—謝耳排序法（Shell Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</link>
      <pubDate>Wed, 09 Jun 2021 10:34:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-13-shellsort/</guid>
      <description>【5/2 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  謝耳排序法（Shell Sort） 在插入排序法中，若大部分資料已經排序完成，該排序法會相當有效率，而謝耳排序法可以看作是一種使插入排序法減少資料搬移次數的衍伸排序法。
其原理為將資料區分成特定間隔的區塊，以插入排序法對區塊內資料進行排序，再漸漸減少間隔的距離。
舉例，有一陣列為 [50] [60] [10] [30] [20] [80] [40] [70]，以劃分數為 2，將資料分成四等份 (8/2)，得到下列區塊組合 (50,20)(60,80)(10,40)(30,70)，規則為第一個數與第五個數為一組，第二個數與第六個數為一組，以此類推。
接著透過插入排序法，對區塊內的資料做排序，使其成為 (20,50)(60,80)(10,40)(30,70)，排序完後，解散區塊組合，還原成原數列 [20] [60] [10] [30] [50] [80] [40] [70]
繼續縮小間隔為 (8/2)/2，得到下列區塊組合 (20,10,50,40)(60,30,80,70)，其規則為第一、三、五、七個數字為一組，二、四、六、八為一組，一樣以插入排序法對區塊內資料做排序，得結果為 (10,20,40,50)(30,60,70,80)，解散組合區塊，還原成原數列 [10] [30] [20] [60] [40] [70] [50] [80]
進行第三次排序，縮小間隔為 ((8/2)/2)/2，如此一來變成對每一個元素進行排序，直接使用插入排序法得結果為 [10] [20] [30] [40] [50] [60] [70] [80]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—插入排序法（Insert Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</link>
      <pubDate>Mon, 07 Jun 2021 12:31:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-12-insertsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  插入排序法（Insert Sort） 插入排序法原理是將陣列中的元素，逐一與已經排序好的資料作比較，例如前兩個元素已經排序好，再將第三個元素與這兩個元素作比較，插入到適當的位置，接著將第四個元素，與前三個已排序好的元素進行比較，再插入到適當位置，重複此步驟，直到排序完成為止。
透過插入排序法，一樣對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先第一個元素 [30] 定義為已排序，取得第二個元素 [20]，與第一個元素進行比較，插入到適當位置
初始已排序序列 [30]
插入後結果序列 [20] [30]
Step 2 取得第三個元素 [40]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30]
插入後結果序列 [20] [30] [40]
Step 3 取得第四個元素 [50]，與上次結果進行比對，並插入適當位置
初始已排序序列 [20] [30] [40]
插入後結果序列 [20] [30] [40] [50]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—選擇排序法（Selection Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</link>
      <pubDate>Thu, 03 Jun 2021 15:19:41 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-11-selectionsort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  選擇排序法（Selection Sort） 選擇排序法顧名思義是以選擇的概念來進行排序，也算是枚舉法的應用，原理為反覆從未排序的數列中取出最小元素，加入到另一個數列中，達到排序的結果。
選擇排序可以由大到小排序，將最大值放到第一位置；或是由小到大排序，將最大值放到最後一個位置。
透過選擇排序法，對 [30] [20] [40] [50] [10] 該數列進行排序，目標結果為由小到大排列
Step 1 首先進行第一次掃描，找到數列中最小值，直接與第一個元素交換
初始序列 [30] [20] [40] [50] [10]
結果序列 [10] [20] [40] [50] [30]
Step 2 進行第二次掃描，排除第一個元素，從第二個位置開始找起，找到最小值，與第二個位置元素交換，因為 [20] 是此次搜尋中最小值，其結果位置不變
上次結果 [10] [20] [40] [50] [30]
結果序列 [10] [20] [40] [50] [30]</description>
    </item>
    
    <item>
      <title>【Algorithm】排序演算法—氣泡排序法（Bubble Sort）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</link>
      <pubDate>Tue, 01 Jun 2021 13:56:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-10-bubblesort/</guid>
      <description>【4/29 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  氣泡排序法（Bubble Sort） 氣泡排序法可稱為交換排序法，其構思為觀察水中氣泡變化而成，甚至可稱為冒泡排序等類似名稱。
其原理為從第一個元素開始，比較相鄰元素的大小，如大小順序有誤，就將其對調，再與下一個元素進行比較，彷彿氣泡逐漸冒出水面上的概念，使用該方法掃描過一次後，就可以確保最後一個元素是位於正確的位置，進行第二次掃描，就能確認第二個元素的正確位置，逐步進行直到所有元素排序完成。
使用白話一點的說法，逐一拆解每一個步驟，首先有一個序列，初始的狀態和順序為 [30] [20] [40] [50] [10]，目標將此序列由小到大排列，變成 [10] [20] [30] [40] [50]
我們透過氣泡排序法進行排序，步驟解析如下
Step 1 首先進行第一次掃描，會先拿到第一個元素 [30]，接著與相鄰的元素 [20] 進行比較，如果第二個元素小於地一個元素，就進行位置交換。
初始序列 [30] [20] [40] [50] [10]
結果序列 [20] [30] [40] [50] [10]
Step 2 依然拿著 [30] 這個元素，繼續與相鄰的元素比較，因為該元素已經調換到第二個元素的位置，所以下一個相鄰的元素會是 [40]，接著進行比較，經比較後兩個元素順序不變，依然維持下列結果
結果序列 [20] [30] [40] [50] [10]</description>
    </item>
    
  </channel>
</rss>
