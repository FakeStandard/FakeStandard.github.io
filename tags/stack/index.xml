<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Stack on How can I help</title>
    <link>https://fakestandard.github.io/tags/stack/</link>
    <description>Recent content in Stack on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 07 Jul 2021 16:59:27 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】堆疊應用—經典河內塔</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-24-towerofhanoi/</link>
      <pubDate>Wed, 07 Jul 2021 16:59:27 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-24-towerofhanoi/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 這篇紀錄經典的智力遊戲—河內塔，使用遞迴式和堆疊概念來解決問題的經典範例。
河內塔的問題描述如下：在古老的印度神廟中，有三個木樁，在第一個木樁上，有數量和大小不同的圓盤，由大到小堆疊，最大的圓盤放在最下面，最小的圓盤在最上面，天神希望將第一個木樁的圓盤，全部移動到第三個木樁。
搬動時必須要遵守規則下列規則
 直徑較小的圓盤只能置於直徑大的圓盤上，比如直徑三的圓盤可以放置在直徑四或直徑五的上方 圓盤可以任意由一個木樁移動到其他木樁上，共有三個木樁可使用 每次只能移動一個圓盤，只能從最上方的圓盤開始移動（與堆疊相同）  【解析】
假設 n 為圓盤數量，逐步解析情境
  n = 1
當圓盤只有一個時，直接從第一個木樁移動到地三個木樁，完成天神願望。
  n = 2
當圓盤為兩個時，由上往下數，將第一個圓盤移動到第二個木樁，接著將第二個圓盤移動到第三個木樁，第一個圓盤從第二個木樁移動到第三個木樁，完成天神願望。
在這裡可以得到一個小結論
 圓盤移動的次數為 (2^2)-1 = 3 次，即 2 的平方-1 次 圓盤移動的次序為 1→2→1 木樁移動的次序為 1→2、1→3、2→3    n = 3
當圓盤為三個時，由上往下數
 第一個圓盤移動到第三個木樁 第二個圓盤移動到第二個木樁 第一個圓盤從第三個木樁移至第二個木樁，此時第二個木樁有兩個圓盤 第三個圓盤移動到第三個木樁 第一個圓盤從第二個木樁移動到第一個木樁 第二個圓盤從第二個木樁移動到第三個木樁 最後，將第一個圓盤從第一個木樁移動到第三個木樁  完成天神願望（懶得畫圖，請讀者發揮想像力…）
此情境得出以下結論
 圓盤移動的次數為 2^3-1 = 7 次，即 2 的次方-1 次 圓盤移動的次序為 1→2→1→3→1→2→1 木樁移動的次序為 1→3、1→2、3→2、1→3、2→1、2→3、1→3    【結論】</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—串列實作堆疊</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-23-stacklist/</link>
      <pubDate>Mon, 05 Jul 2021 14:06:01 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-23-stacklist/</guid>
      <description>【5/17 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 使用串列製作堆疊的好處是可以隨時動態改變串列長度，缺點則是設計較為複雜。相較於使用陣列製作堆疊設計上較為簡易，缺點則是陣列大小需事先宣告，無法動態改變。
利用串列結構模擬堆疊工作運算，使用迴圈控制推入或取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。
宣告一個鏈結串列節點的類別
/// &amp;lt;summary&amp;gt; /// 鏈結串列節點的類別 /// &amp;lt;/summary&amp;gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } 宣告串列模擬堆疊的類別，其中包含推入和取出的方法
/// &amp;lt;summary&amp;gt; /// 以串列模擬的堆疊 /// &amp;lt;/summary&amp;gt; class StackByLink { /// &amp;lt;summary&amp;gt;  /// 指向堆疊頂端的指標  /// &amp;lt;/summary&amp;gt;  public Node front; /// &amp;lt;summary&amp;gt;  /// 指向堆疊末端的指標  /// &amp;lt;/summary&amp;gt;  public Node rear; /// &amp;lt;summary&amp;gt;  /// 判斷堆別是否為空的方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool IsEmpty() { return front == null; } /// &amp;lt;summary&amp;gt;  /// 輸出堆疊內容  /// &amp;lt;/summary&amp;gt;  public void Display() { Node current = front; while (current !</description>
    </item>
    
    <item>
      <title>【Algorithm】堆疊應用—陣列實作堆疊</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</link>
      <pubDate>Fri, 02 Jul 2021 15:50:31 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-22-stackarray/</guid>
      <description>【5/16 閱讀紀錄】
根據先前文章介紹的堆疊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用陣列結構模擬堆疊工作運算，且使用迴圈控制推入與取出的元素，其中需包含推入（push）和取出（pop）函數，最後要輸出堆疊中所有元素。
建立堆疊類別
/// &amp;lt;summary&amp;gt; /// 以陣列模擬堆疊的類別 /// &amp;lt;/summary&amp;gt; class StackArray { // 宣告陣列  private int[] stack; // 指向堆疊頂端的索引  private int top; /// &amp;lt;summary&amp;gt;  /// 建構子  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;stack_size&amp;#34;&amp;gt;堆疊大小&amp;lt;/param&amp;gt;  public StackArray(int size) { // 建立陣列  stack = new int[size]; top = -1; } /// &amp;lt;summary&amp;gt;  /// 判斷堆疊是否為空  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Empty() { if (top == -1) return true; else return false; } /// &amp;lt;summary&amp;gt;  /// 推入資料到頂端的方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public bool Push(int data) { // 判斷堆疊頂端的索引是否大於陣列大小  if (top &amp;gt;= stack.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—堆疊（Stack）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-5-stack/</link>
      <pubDate>Wed, 19 May 2021 13:53:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-5-stack/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。
堆疊基本運算具備以下五種工作定義
   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
  </channel>
</rss>
