<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Search Algorithm on How can I help</title>
    <link>https://fakestandard.github.io/tags/search-algorithm/</link>
    <description>Recent content in Search Algorithm on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 30 Jun 2021 13:28:24 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/search-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】搜尋演算法—費氏搜尋法（Fibonacci Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</link>
      <pubDate>Wed, 30 Jun 2021 13:28:24 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-21-fibonaccisearch/</guid>
      <description>【5/31 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  費氏搜尋演算法（Fibonacci Search） 費氏搜尋演算法又稱費伯納搜尋法，Fibonacci 還有其他譯名如斐波那契數列、費氏數列等等，該數列非常特別，對於大自然而言，整個自然界都存在這個的定律，它是一個神奇的黃金比例；對於數學而言，只不過是個公式—每個值是前兩項的總和，但是，每個值除以前一項的商數，都近似於 1.618…
OK. 我們也不能偏離主題太遠，不過 1.618 這個數字會存放於筆者內心的深處，近期受疫情的肆虐，筆者拾起達文西密碼，拜本書之賜，重新認識斐波那契數列這個「上帝之數」。
費氏級數如同先前所說，每個值都是前兩項的加總，故其公式為
雖然每個值都是前兩項的加總，其中並不包含第零個元素和第一個元素，第零個元素定義為 0，第一個元素定義為 1，從這兩個元素開始，每個值才是前兩項的總和，故該數列會是 0,1,1,2,3,5,8,13,21,34,55,89,144...
費氏樹列以遞迴程式碼表現方式為
static int Fibonacci(int value) { if (value == 0) return 0; else if (value == 1) return 1; else return Fibonacci(value - 1) + Fibonacci(value - 2); } 了解費氏級數後，就來認識費氏搜尋數，所謂費氏搜尋數就是以費氏數列的特性，所建立的二元數，其建立原則如下</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—內插搜尋法（Interpolation Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</link>
      <pubDate>Mon, 28 Jun 2021 10:27:54 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-20-interpolationsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  內插搜尋演算法（Interpolation Search） 內插搜尋法又稱插補搜尋法，是二分搜尋法的改良版，主要是針對以排序的資料進行搜尋，與二分法相同。其原理為透過斜率公式預測資料的所在位置，再以二分法逐漸逼近。
參考斜率公式說明
實作公式
Mid = left + ((key-data[left]) * (right - left) / (data[right] - data[left])) 演算法分析  資料需事先排序 資料分佈越平均，搜尋速度越快。時間複雜度取決於資料分佈情況，平均會優於 O(logn)  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作內插搜尋法的過程
建立靜態陣列物件及內插搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; static int Interpolation(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—二分搜尋法（Binary Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</link>
      <pubDate>Fri, 25 Jun 2021 12:37:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。
假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。
演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程
建立靜態陣列物件及二分搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; /// &amp;lt;summary&amp;gt; /// 二分搜尋方法 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;val&amp;#34;&amp;gt;&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data.</description>
    </item>
    
    <item>
      <title>【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</link>
      <pubDate>Wed, 23 Jun 2021 11:19:30 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/</guid>
      <description>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。
它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。
假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。
利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。
演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n+1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程</description>
    </item>
    
  </channel>
</rss>
