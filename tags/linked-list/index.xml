<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Linked List on How can I help</title>
    <link>https://fakestandard.github.io/tags/linked-list/</link>
    <description>Recent content in Linked List on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 30 Apr 2021 16:09:07 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/linked-list/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】資料結構—鏈結串列（Linked List）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</link>
      <pubDate>Fri, 30 Apr 2021 16:09:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</guid>
      <description>【4/14 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。
在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成
 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。
日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。
對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。
Note 特性
 記憶體空間配置的儲存方式為不連續且隨機  優點
 刪除或插入資料無須移動大量資料  缺點
 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】</description>
    </item>
    
  </channel>
</rss>
