<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Linked List on How can I help</title>
    <link>https://fakestandard.github.io/tags/linked-list/</link>
    <description>Recent content in Linked List on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 05 Aug 2021 20:54:11 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/linked-list/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】樹的應用—串列實作二元樹</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/</link>
      <pubDate>Thu, 05 Aug 2021 20:54:11 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以串列來表示二元樹，假設有一顆樹，如下
該如何使用串列來表示？
使用鏈結串列來表示二元樹的優點，是在新增和刪除節點時非常容易，缺點則是不容易找到父節點。在使用陣列儲存歪斜樹時，會造成許多的空間被浪費，對於歪斜樹來說，使用串列儲存較為節省空間。
根據上一篇的慘痛經驗，這篇偷偷將樹的值改了一個，讓樹高只維持在 4，上一篇做到 5 層，可真是毅力與耐力的考驗。
首先，先了解一下要如何使用串列來表示二元樹，在先前學過的串列，都具有一個資料欄和指標欄，指標欄存放著下一個節點的記憶體位置，作為節點與節點之間的連結，透過指標的特性，我們將指標欄設置為兩個，分別為左指標與右指標，左指標存放左子樹的節點位址，右指標存放右子樹的節點位址，如下圖所示
使用一個陣列先將樹的節點值儲存起來
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。
在使用串列表示二元樹時，也必須符合二元樹的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值，最後以串列表示的方式如下
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 31, 23, 11, 30, 7, 10 }，按照二元樹的定義，形成一顆以串列表示的完整二元樹。
先建立樹節點類別
/// &amp;lt;summary&amp;gt; /// 樹節點類別 /// &amp;lt;/summary&amp;gt; class TreeNode { // 值  public int data; // 左子樹  public TreeNode leftNode; // 右子樹  public TreeNode rightNode; public TreeNode(int value) { this.</description>
    </item>
    
    <item>
      <title>【Algorithm】鏈結串列應用—單向串列反轉演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-35-linkedlistreverse/</link>
      <pubDate>Thu, 29 Jul 2021 14:03:26 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-35-linkedlistreverse/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 學會串列插入、刪除和連結的基本功之後，這篇要來思考如何反轉串列？反轉串列顧名思義就是將串列內的元素都顛倒過來，最後形成頂端節點變成末端節點，而末端節點成為頂端節點，但是串列指標只能知道下一個節點的位置，無法得知上一個節點，那該如何做？這就需要一點小技巧，直接實作程式碼
/// &amp;lt;summary&amp;gt; /// 節點類別 /// &amp;lt;/summary&amp;gt; class Node { public int data; public Node next; public Node(int data) { this.data = data; this.next = null; } } /// &amp;lt;summary&amp;gt; /// 鏈結串列類別 /// &amp;lt;/summary&amp;gt; class LinkedList { public Node first; public Node last; public bool IsEmpty() { return first == null; } public void Print() { Node current = first; while (current != null) { Write($&amp;#34;[{current.</description>
    </item>
    
    <item>
      <title>【Algorithm】鏈結串列應用—單向串列刪除節點演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-34-linkedlistdelete/</link>
      <pubDate>Mon, 26 Jul 2021 13:11:33 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-34-linkedlistdelete/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 以單向的鏈結串列來說，欲串列中的節點，可刪除的位置與插入節點相同會有三種
  刪除串列的第一個節點
第一個節點刪除後，第二個節點會成為頂端節點，只需將頂端節點指給第二個節點
  刪除串列的最後一個節點
最後一個節點刪除後，倒數第二個節點會成為末端節點，只需將末端節點指標只給倒數第二個節點
  從串列中刪除其中一個中間節點
將欲刪除節點的前一個節點指標，指給欲刪除節點的下一個節點即可
  實作串列刪除節點程式碼，先建立節點類別，類別內包含資料欄與指標欄，每當新節點建立時，新節點資料欄必須帶有值，而指標欄先指向 NULL，等待後續將指標指向特定節點作業。
/// &amp;lt;summary&amp;gt; /// 節點類別 /// &amp;lt;/summary&amp;gt; class Node { // 資料欄  public int data; // 指標欄  public Node next; /// &amp;lt;summary&amp;gt;  /// 帶有一個資料的建構子  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  public Node(int data) { this.data = data; this.next = null; } } 建立鏈結串列類別，串列類別需包含頂端節點和末端節點屬性，類別內再建立一個輸出當前串列的方法，以及判斷當前陣列是否為空，若沒有頂端節點則該串列為空。另外再建立兩個方法，一個是 Insert 用於插入新節點，一個是 Delete 用於刪除節點，下一步將實作這兩個方法。</description>
    </item>
    
    <item>
      <title>【Algorithm】鏈結串列應用—單向串列插入節點與連結兩串列演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-33-linkedlistinsertandconcatenation/</link>
      <pubDate>Sat, 24 Jul 2021 10:30:28 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-33-linkedlistinsertandconcatenation/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的鏈結串列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 以單向的鏈結串列來說，欲插入新節點到現有的串列，有三種位置可以插入
  插入於第一個節點之前
新節點成為串列的首節點，作法是將新節點的指標指向串列原來的第一個節點，再把串列的指標首指向新節點
  插入於最後一個節點之後
新節點成為串列的末節點，只需要將串列的最後一個節點指標指向新節點，新節點再指向 NULL 即可
  插入於串列中間的位置
假設插入於 A.B 節點之間，將 A 節點的指標指向新節點，新節點的指標再指向 B 節點即可
  實作串列插入節點程式碼，先建立節點類別，類別內包含資料欄與指標欄，每當新節點建立時，新節點資料欄必須帶有值，而指標欄先指向 NULL，等待後續將指標指向特定節點作業。
/// &amp;lt;summary&amp;gt; /// 節點類別 /// &amp;lt;/summary&amp;gt; class Node { // 資料欄  public int data; // 指標欄  public Node next; /// &amp;lt;summary&amp;gt;  /// 帶有一個資料的建構子  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;data&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  public Node(int data) { this.data = data; this.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—鏈結串列（Linked List）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</link>
      <pubDate>Fri, 30 Apr 2021 16:09:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</guid>
      <description>【4/14 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。
在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成
 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。
日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。
對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。
Note 特性
 記憶體空間配置的儲存方式為不連續且隨機  優點
 刪除或插入資料無須移動大量資料  缺點
 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】</description>
    </item>
    
  </channel>
</rss>
