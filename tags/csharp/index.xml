<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CSharp on How can I help</title>
    <link>https://fakestandard.github.io/tags/csharp/</link>
    <description>Recent content in CSharp on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 21 May 2021 10:54:12 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】資料結構—佇列（Queue）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-6-queue/</link>
      <pubDate>Fri, 21 May 2021 10:54:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-6-queue/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。
佇列基本運算具備以下五種工作定義
   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET Core】相依性注入 Dependency Injection</title>
      <link>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</link>
      <pubDate>Thu, 20 May 2021 15:41:33 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-2-dependencyinjection/</guid>
      <description>【ASP.NET Core 5】
如果要問 ASP.NET Core 最精華的部份是什麼，必定是 DI 無誤。
Start 相依性是另一個物件所依賴的物件。
建立 MyDependency 類別，內含一個無返回值的 WriteMessage 方法
public class MyDependency { public void WriteMessage(string message) { Console.WriteLine($&amp;#34;Message:{message}&amp;#34;); } } 再建一個 MyClass 類別，類別內建立 MyDependency 實例，在 MyClass 內實作無返回值的 Get 方法，該方法內調用 MyDependency 實例的 WriteMessage 方法。
public class MyClass { private readonly MyDependency _myDependency = new MyDependency(); public void Get() { _myDependency.WriteMessage(&amp;#34;MyClass get a message&amp;#34;); } } 到目前為止程式是沒什麼問題，在未使用 DI 前，我們絕大部分都是這麼做，MyClass 物件直接依賴於 MyDependency 物件，彼此之間有著很強的相依性，也存在著一些問題。舉例來說，若要以不同實作替代 MyDependency，MyClass 必須修改此類別，再來該實作也難以進行單元測試。</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—堆疊（Stack）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-5-stack/</link>
      <pubDate>Wed, 19 May 2021 13:53:44 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-5-stack/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄堆疊定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  堆疊（Stack） 堆疊是一種抽象型資料結構（Abstract Data Type, ADT），是由一群相同資料型別的組合，所有動作均在頂端執行，具有後進先出（Last In, First Out: LIFO）的特性。
堆疊基本運算具備以下五種工作定義
   Action Description     create 建立一個空堆疊   push 存放頂端資料，並傳回新堆疊   pop 刪除頂端資料，並傳回新堆疊   isEmpty 判斷堆疊是否為空堆疊，是回傳 Ture，反之   full 判斷堆疊是否已滿，是回傳 True，反之    堆疊非常好理解，生活中也有很多堆疊的應用，假設要收拾餐桌上的餐盤，需要將它們一一疊起，先放第一個餐盤，再將第二個餐盤放到第一個餐盤上方，接著再將第三個餐盤放到第二個餐盤上方，以該例來看，第一個餐盤就是第一個放入堆疊中，而第三個是最後一個放入堆疊中，此時欲取得第二餐盤，就需要先將第三個放入的餐盤拿起，意思是，需要先將頂端的先拿起，才能在往下拿起，該例證明後進先出的特性，並且所有動作都是由頂端執行，從頂端加入，從頂端刪除，即是堆疊的概念。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET】使用 C# 操作檔案 I/O 與檔案系統（一）</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</link>
      <pubDate>Tue, 18 May 2021 11:11:56 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-8-filesystemandfileio-one/</guid>
      <description>在 .NET 框架中，命名空間 System.IO 已經提供多種檔案操作類別，用於對資料檔案和資料流的讀寫。談到檔案系統，要先知道兩個東西
 檔案（File） 流（Stream）  檔案是在硬碟或光碟機等媒體上可永久儲存資料的有序集合，它是一種進行資料讀寫操作的基本物件，通常按照樹狀目錄結構進行組織，每個檔案皆有檔名、所在路徑、建立時間、訪問許可權等屬性。
流是位元組序列的抽象概念，例如檔案、輸入/輸出裝置、處理程序間的通訊管道（an inter-process communication pipe）或 TCP/IP 通訊端。資料流包含讀取、寫入以及支援搜尋三種基本作業。
Start FileSystemInfo 類別是檔案系統類別的基礎類別，繼承該類別的子類別有
 File - 負責檔案系統中的檔案，屬靜態類別 FileInfo - 負責檔案系統中的檔案 Directory - 負責檔案系統中的資料夾，屬靜態類別 DirectoryInfo - 負責檔案系統中的資料夾  另外還有位於 System.IO 命名空間下其餘相關的類別
 Path - 負責檔案系統中的路徑 DriveInfo - 負責磁碟機資訊的訪問  File 與 FileInfo 的區別在於 Info 類別需要實體化，而一般 File 是屬於靜態類別；Directory 與 DirectoryInfo 同理，Directory 是靜態類別，DirectoryInfo 需實體化類別。
FileInfo 使用 FileInfo 類別建立檔案，並且寫入資料
/// &amp;lt;summary&amp;gt; /// 建立檔案並寫入資料 /// &amp;lt;/summary&amp;gt; public static void CreateFileByFileInfo() { // 實體化 FileInfo 並指予路徑  FileInfo file = new FileInfo(@&amp;#34;D:\Test.</description>
    </item>
    
    <item>
      <title>【.NET Core】Application Startup Class</title>
      <link>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</link>
      <pubDate>Thu, 13 May 2021 16:23:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/netcore/netcore5-1-startupclass/</guid>
      <description>【ASP.NET Core 5】
在 .NET Core 出現的 Startup 類別非常重要，該類別用來配置應用程式的「服務」和「請求管道」，由它的名稱可知，在應用程式啟動時該類別首先被執行，它與傳統應用程式內的 Global.asax 相似。
Start 開啟 Program 類別找到 Main 方法，這裡即是程式的進入點（Entry point），與 Console 專案的啟動方式相同都是 Program.Main，再從程式進入點將網站實例化，該方法配置 Host 時使用了 UserStartup&amp;lt;T&amp;gt; 方法，其中泛型 &amp;lt;T&amp;gt; 預設為 Startup
public class Program { public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&amp;gt; { // 配置啟動類別位置  webBuilder.UseStartup&amp;lt;Startup&amp;gt;(); }); } 該類別依照 ASP.NET Core 慣例命名為 Startup，顧名思義為啟動類別，但是，我們也可以為該類別指定任何名稱，且在 UseStratup&amp;lt;T&amp;gt; 的泛型更換為指定後的名稱即可。如下將該類別命名為 MyStartup，配置啟動類別的位置也要替換為新類名。
public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt; Host.</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯入 Excel</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</link>
      <pubDate>Tue, 11 May 2021 10:00:16 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-7-npoi-import/</guid>
      <description>在網站開發時，總會遇到匯出 EXCEL 的需求，除了匯出之外，偶爾也會遇到匯入 EXCEL 這種懶人需求。
為何是懶人需求呢？通常使用者可以透過 UI 介面來維護資料，包括 CRUD 等功能，所以 Excel 資料會先透過前端介面在將資料傳遞到資料庫儲存。而匯入的方式，可以一次傳遞多筆資料，並且直達資料庫，過程中不需要使用 UI 介面逐筆輸入，非常省時又省力。
註：此篇使用 ASP.NET Core 5 實作
Start 首先到 NuGet 下載 NPOI 套件並安裝到專案中
建立 ImportController.cs
public class ImportController : Controller { public IActionResult Index() { return View(); } } 建立 Index.cshtml
&amp;lt;h2&amp;gt;Import&amp;lt;/h2&amp;gt; @using (Html.BeginForm(&amp;#34;Upload&amp;#34;, &amp;#34;Import&amp;#34;, FormMethod.Post, new { enctype = &amp;#34;multipart/form-data&amp;#34; })) { &amp;lt;input type=&amp;#34;file&amp;#34; class=&amp;#34;form-control&amp;#34; name=&amp;#34;file&amp;#34; /&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; class=&amp;#34;btn btn-primary&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; } 在 Controller 中新增一個接收 HttpPost 的 ActionResult Upload，除了返回頁面之外，沒有任何代碼。</description>
    </item>
    
    <item>
      <title>【.NET】將資料匯出成 CSV</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</link>
      <pubDate>Sun, 09 May 2021 14:31:15 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-6-exportcsv/</guid>
      <description>前篇在紀錄使用第三方套件來匯出 Excel，忽然看到匯出 csv 的方法，其實很簡單，就順便記錄一下。
Start 按照前篇建立一個 .Net Core MVC 的專案，同樣地建立 Model、Controller 及 View，讓畫面呈現一個 Employee 的列表，將按鈕名稱改為 csv Export，相關代碼如下
Model public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View @model IEnumerable&amp;lt;Export_ClosedXML.</description>
    </item>
    
    <item>
      <title>【.NET】使用 ClosedXML 實現匯出 Excel 功能</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</link>
      <pubDate>Sat, 08 May 2021 10:28:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-5-closedxmlsimple/</guid>
      <description>開發應用程式或網頁時一定會遇到匯出 Excel 功能，而匯出的 Libaray 除了微軟原生的程式庫之外，還可以使用第三方的程式庫，先前已有介紹過使用 NPOI 套件，有興趣可參考傳送門。
這篇則會介紹如何使用 ClosedXML 簡易的匯出，代碼已存放於 GitHub
【傳送門】【NPOI】使用 NPOI 匯出 Excel 的基本應用
Start 首先到 NuGet 安裝套件
Model 建立資料模型
public class Employee { public int ID { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Title { get; set; } public string City { get; set; } } Controller 建立控制項和產生資料
public class EmployeeController : Controller { private List&amp;lt;Employee&amp;gt; employees; public EmployeeController() { if (employees == null) { employees = new List&amp;lt;Employee&amp;gt;() { new Employee{ ID = 1, LastName = &amp;#34;Davolio&amp;#34;, FirstName = &amp;#34;Nancy&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 2, LastName = &amp;#34;Fuller&amp;#34;, FirstName = &amp;#34;Andrew&amp;#34;, Title = &amp;#34;Vice President, Sales&amp;#34;, City = &amp;#34;Tacoma&amp;#34; }, new Employee{ ID = 3, LastName = &amp;#34;Leverling&amp;#34;, FirstName = &amp;#34;Janet&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Kirkland&amp;#34; }, new Employee{ ID = 4, LastName = &amp;#34;Peacock&amp;#34;, FirstName = &amp;#34;Margaret&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;Redmond&amp;#34; }, new Employee{ ID = 5, LastName = &amp;#34;Buchanan&amp;#34;, FirstName = &amp;#34;Steven&amp;#34;, Title = &amp;#34;Sales Manager&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 6, LastName = &amp;#34;Suyama&amp;#34;, FirstName = &amp;#34;Michael&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 7, LastName = &amp;#34;King&amp;#34;, FirstName = &amp;#34;Robert&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; }, new Employee{ ID = 8, LastName = &amp;#34;Callahan&amp;#34;, FirstName = &amp;#34;Laura&amp;#34;, Title = &amp;#34;Inside Sales Coordinator&amp;#34;, City = &amp;#34;Seattle&amp;#34; }, new Employee{ ID = 9, LastName = &amp;#34;Dodsworth&amp;#34;, FirstName = &amp;#34;Anne&amp;#34;, Title = &amp;#34;Sales Representative&amp;#34;, City = &amp;#34;London&amp;#34; } }; } } public IActionResult Index() { return View(employees); } } View 在視圖渲染資料，且添加 Export 按鈕</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—鏈結串列（Linked List）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</link>
      <pubDate>Fri, 30 Apr 2021 16:09:07 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-4-linkedlist/</guid>
      <description>【4/14 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄鏈結串列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  鏈結串列（Linked List） 串列是由許多相同資料型態的項目，依照特定順序排列而成的線性串列，在記憶體中儲存方式是不連續且隨機，當資料插入時只需向系統取得一塊記憶體，將資料存放於該記憶體後，把該記憶體與上一個節點的記憶體連結起來，刪除時只需將資料刪除後，把記憶體釋放空間出來並交還給系統，再將下一塊記憶體與上一塊記憶體連結起來即可，無須像陣列一樣移動大量資料。
在動態配置記憶體空間時，最常使用的是單向鏈結串列，基本上由兩個欄位組成
 資料欄 指標欄  資料欄顧名思義為儲存資料的欄位，串列的重點精華在於指標欄，指標欄是用來紀錄下一塊元素的記憶體位置，所以第一塊記憶體的指標欄會記錄第二個元素的記憶體所在位置，第二個指標欄紀錄第三個元素的記憶體位置，以此類推，在單向串列裡第一個節點的指標欄稱為「串列指標首」，最後一個節點稱為「串列指標尾」，依照前面對指標欄的描述，串列指標尾的指標欄會儲存 Null，因為已經沒有下一個節點可讀取。
日常生活中也有許多類似串列的抽象應用，例如火車，假設今日乘客較多，當前的車廂數量已無法滿足乘載量，需增加一節車廂，我們只需將車廂掛在火車的最後面，使該車廂成為最後一節車廂，新增有如這樣的操作方式。假設第三節車廂折舊年限已到，需要將該節車廂撤下，我們只需將第三節車廂移除，再將第二節車廂掛到第四節車廂，火車就能一如往常的運作，刪除有如該操作模式。
對 CRUD 所有操作來說，因為串列只能得知下一個元素的記憶體位置，沒有像陣列一樣擁有索引功能，可隨心的指向記憶體位置，所以在進行 CRUD 操作時都必須對整個串列進行走訪。
Note 特性
 記憶體空間配置的儲存方式為不連續且隨機  優點
 刪除或插入資料無須移動大量資料  缺點
 讀取和修改速度相對慢，因要對整個串列進行走訪  Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET】使用 NPOI 匯出 Excel 的基本應用</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</link>
      <pubDate>Tue, 27 Apr 2021 14:08:05 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-4-npoisimple/</guid>
      <description>開發應用程式或網頁時總是會遇到匯出 Excel 的需求，常見的如匯出報表。然而在眾多匯出 Excel 的套件中，這篇選擇以 NPOI 作為介紹匯出的基本應用和觀念，資料則選擇現成的北風資料庫，這邊就不另外建立資料物件。
代碼存放於 GitHub
Start 首先到 NuGet 套件添加 NPOI Package
建立一個資料庫連線的方法，將 Orders 資料表的資料全部讀到 DataTable
/// &amp;lt;summary&amp;gt; /// 資料庫連線方法 /// &amp;lt;/summary&amp;gt; static DataTable Connect() { // 宣告並建立 SqlConnectionStringBuilder 物件，並設置連線資訊  SqlConnectionStringBuilder cnsb = new SqlConnectionStringBuilder(); cnsb.DataSource = &amp;#34;.&amp;#34;; cnsb.InitialCatalog = &amp;#34;Northwind&amp;#34;; cnsb.IntegratedSecurity = true; // 宣告並建立 SqlConnection  SqlConnection cn = new SqlConnection(cnsb.ConnectionString); // SQL Statement  string sql = &amp;#34;SELECT * FROM [Northwind].[dbo].[Orders]&amp;#34;; // 宣告並建立 SqlDataAdapter 物件  SqlDataAdapter da = new SqlDataAdapter(sql, cn); // 建立 DataSet 物件以儲存資料  DataSet ds = new DataSet(); da.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—陣列（Array）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-3-array/</link>
      <pubDate>Mon, 26 Apr 2021 16:34:39 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-3-array/</guid>
      <description>【4/11 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄陣列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖（Graph） 堆積（Heap） 雜湊表（Hash Table）  陣列（Array） 陣列是一種靜態資料結構，由相同名稱和相同資料型態的集合，使用連續記憶體作為儲存空間，陣列有提供索引功能，用來表示從記憶體起始位置的第幾個位置。
靜態資料結構在編譯時，就必須配置記憶體空間給變數，所以初期就需宣告變數的固定空間，容易造成記憶體浪費。
操作 CRUD 等功能時也各有優缺點，首先是設計時相當容易，因索引功能使得讀取和修改元素的時間都固定，但在刪除和加入資料時就必須移動大量資料，例如刪除陣列中某個元素，必須將被刪除元素後方記憶體的資料都往前移動。
陣列運用可分為一維陣列、二維陣列或多維陣列，一維陣列可想像成一條線，二維陣列則為一個平面，三維陣列（多維陣列）就會是 3D 立體，以此類推。
使用一維陣列尋找和儲存 1~num 之間的所有質數
const int num = 300; // true: 質數 false: 非質數 bool[] prime = new bool[num]; // 將 0,1 配置為非質數 prime[0] = false; prime[1] = false; int m = 2; int n = 2; // 找出 1~num 之間所有質數 while (m &amp;lt; num) { prime[m] = IsPrime(m); m++; } int c = 0; int count = 0; // 列印所有質數 for (int i = 0; i &amp;lt; num; i++) { if (prime[i]) { if (c == 10) { Console.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構定義與資料型態</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</link>
      <pubDate>Sun, 25 Apr 2021 13:26:46 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-2-datastructure/</guid>
      <description>【4/11 閱讀紀錄】
此篇為閱讀的紀錄，紀錄關於資料結構定義，以加強基礎觀念。
Start 資料結構為一種輔助程式設計最佳化的方法論，其中包含儲存的資料，以及資料儲存的方式，目的是要讓程式達到有效率的執行以及減少記憶體占用等。
一般來說，「資料」是最原始的資料，資料經過「資料處理」的過程後，成為可用的「資訊」。資料處理的過程是對原始資料進行整理和分析，將資料提煉成具有參考價值的資訊，其中整理與分析的過程會使用演算法和資料結構，所以我們要將電腦內的資料轉換為可用的文字、圖表等資訊時，首先要了解演算法和資料結構的觀念，才能精準的提煉出可用資訊。
 資料型態  基本資料型態（Primitive Data Type） 結構化資料型態（Structured Data Type） 抽象化資料型態（Abstraact Data Type）    資料型態 認識資料結構前，需先了解資料型態有哪些，以利在第一步選出正確地型態，避免規劃出沒有效率的程式，導致不堪的後果。
基本資料型態（Primitive Data Type） 基本資料型態又稱為純量資料型態（Scalar Data Type），它們是一組最基本資料型態，例如整數、布林、字串、浮點數等。
結構化資料型態（Structured Data Type） 結構化資料型態也可稱為虛擬資料型態（Virtual Data Type），比基本資料型態更高一層的型態，例如陣列、指標、串列、檔案等。
抽象資料型態（Abstract Data Type） 抽象資料型態在電腦中代表資訊隱藏的精神與某一種特定的關係模式，例如堆疊是一種後進先出的運作方式。
Reference 【圖說演算法 C#】</description>
    </item>
    
    <item>
      <title>【.NET】西元年與民國年相互轉換</title>
      <link>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</link>
      <pubDate>Mon, 19 Apr 2021 14:58:59 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/dotnet/dotnet-3-changetaiwancalendar/</guid>
      <description>這篇想記錄一下老掉牙的問題，是關於時間格式的「西元年」和「民國年」的愛恨糾葛。
一般電腦在安裝作業系統時預設會是西元年，而有些人習慣看民國年，這些人就從設定的「地區與語言」中，將行事曆變更為中華民國曆，這些人對日期看順眼了，卻為開發人員種下一個應該要懂得基本常識。
西元年扣掉 1911 就是民國年，這知識完全無誤，但若你是開發人員，並且在開發應用程式時使用 -1911 來算出民國年，這觀念可要重新來過了，因為 .NET 有提供 Taiwan Calendar 類別讓你在西元與民國之間盡情地轉換，甚至也無須擔心四年就要閏一次「閏年」。
Solution 有三種解決方案
 直接轉換 建立擴充方法 替換當前執行緒的文化特性  直接轉換 建立一個時間變數，透過 TaiwanCalendar 返回轉換後的時間
引用命名空間
 System.Globalization  DateTime dateTime = new DateTime(2020, 2, 29); TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.GetYear(dateTime); int month = dateTime.Month; int day = dateTime.Day; string newDateTime = $&amp;#34;{year}/{month}/{day}&amp;#34;; Console.WriteLine(newDateTime); 建立擴充方法 先撰寫一個擴展方法，需要使用時直接調用擴充方法，無須每次都撰寫相同代碼。
/// &amp;lt;summary&amp;gt; /// 靜態擴展類別 /// &amp;lt;/summary&amp;gt; public static class DateTimeExtend { /// &amp;lt;summary&amp;gt;  /// 靜態擴展方法  /// &amp;lt;/summary&amp;gt;  /// &amp;lt;param name=&amp;#34;dateTime&amp;#34;&amp;gt;&amp;lt;/param&amp;gt;  /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;  public static string ToTaiwanDate(this DateTime dateTime) { TaiwanCalendar tc = new TaiwanCalendar(); int year = tc.</description>
    </item>
    
    <item>
      <title>【Algorithm】經典演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</link>
      <pubDate>Mon, 05 Apr 2021 13:41:55 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</guid>
      <description>【3/28 閱讀紀錄】
此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。
Start 演算法種類很多，經典的演算法有以下幾種
 分治演算法（Divide and conquer） 迭代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Exhaustive Searching） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。
像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。
然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。
所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。
迭代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為迭代演算法，像是透過迴圈去循環重複的程式碼來得到答案。
舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果
// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i &amp;lt;= n; i++) { for (int j = i; j &amp;gt; 0; j--) { sum = sum * j; } Console.</description>
    </item>
    
  </channel>
</rss>
