<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CSharp | How can I help</title>
<meta name="keywords" content="" />
<meta name="description" content="不專業代碼">
<meta name="author" content="Polar Bear">
<link rel="canonical" href="https://fakestandard.github.io/tags/csharp/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d1b405b7c6bf1b09aebca33eb6e2d8bd070113d119bdfa2715c32f6408f9fbee.css" integrity="sha256-0bQFt8a/GwmuvKM&#43;tuLYvQcBE9EZvfonFcMvZAj5&#43;&#43;4=" rel="preload stylesheet" as="style">


<script data-ad-client="ca-pub-4877674098686024" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<meta name="google-site-verification" content="iCWzIE4kN0sAVM_Slr-q8E5zIT2Qfs-IxUuxhpFVD94" />







<link rel="icon" href="https://fakestandard.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fakestandard.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fakestandard.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fakestandard.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fakestandard.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.81.0" />
<link rel="alternate" type="application/rss+xml" href="https://fakestandard.github.io/tags/csharp/index.xml">
<meta property="og:title" content="CSharp" />
<meta property="og:description" content="不專業代碼" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fakestandard.github.io/tags/csharp/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CSharp"/>
<meta name="twitter:description" content="不專業代碼"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fakestandard.github.io/" accesskey="h" title="How can I help (Alt + H)">How can I help</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fakestandard.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/algorithm/" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/netcore/" title=".NET Core">
                    <span>.NET Core</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://fakestandard.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://fakestandard.github.io/tags/">Tags</a></div>
  <h1>CSharp</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】搜尋演算法—二分搜尋法（Binary Search）</h2>
  </header>
  <section class="entry-content">
    <p>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  二分搜尋演算法（Binary Search） 二分搜尋法是對已排序的資料進行搜尋，其原理是將資料分割成兩等份，對鍵值與分割的中間值進行比較大小，依照比較的結果，來確認要找的資料是在前半段或者後半段，反覆地分割比較，直到找到資料或無法再分割確定不存在為止，經由上述可知，未排序的資料不適用二分法。
假設有一數列由小到大排序 10 20 30 40 50 60 70 80 90，欲找尋鍵值 30，利用二分法進行第一次分割，得到中間值為 50，將鍵值 30 與中間值 50 進行比較，得鍵值小於中間值，確定要找尋的資料在前半段 10 20 30 40 50，在對前半段進行第二次分隔，得到中間值 30，將鍵值與中間值進行比較，結果為真，即搜尋中止。
演算法分析  時間複雜度為 O(logn) 必須事先排序，且資料量必須能載入到記憶體中執行 適用於不需增刪的靜態資料  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作二分搜尋法的過程
建立靜態陣列物件及二分搜尋方法
// 建立靜態陣列物件 static int[] data = new int[100]; /// &lt;summary&gt; /// 二分搜尋方法 /// &lt;/summary&gt; /// &lt;param name=&#34;val&#34;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static int BinarySearch(int val) { int mid; // 中間值  int left = 0; // 左邊極限  int right = data....</p>
  </section>
  <footer class="entry-footer">June 25, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】搜尋演算法—二分搜尋法（Binary Search）" href="https://fakestandard.github.io/algorithm/algorithm-19-binarysearch/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【.NET Core】環境變數 Environments</h2>
  </header>
  <section class="entry-content">
    <p>【ASP.NET Core 5】
Start ASP.NET Core 會根據執行階段的環境變數，來設定應用程式的行為。如開發環境、測試環境及正式環境的組態設定會不太相同，使用的資料庫也會不同。
Environment Variable 預設的三種環境
 Development 開發環境 Staging 暫存(測試)環境 Production 正式環境  環境名稱由系統變數 ASPNETCORE_ENVIRONMENT 的內容值而來，該變數可在 launchSettings.json 作變更。
開啟 launchSettings.json，在 profiles 節點找到 IIS Express\..\environmentVariables 的 ASPNETCORE_ENVIRONMENT，將原本的 Development 變更為 Production。
&#34;profiles&#34;: { &#34;IIS Express&#34;: { &#34;commandName&#34;: &#34;IISExpress&#34;, &#34;launchBrowser&#34;: true, &#34;environmentVariables&#34;: { &#34;ASPNETCORE_ENVIRONMENT&#34;: &#34;Production&#34; } } } 開啟 Startup.cs，Configure 方法已注入 IWebHostEnvironment，在方法內使用下列程式碼判斷環境變數內容值
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsProduction()) // 假設是生產環境  { app.Run(async (context) =&gt; { await context....</p>
  </section>
  <footer class="entry-footer">June 24, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【.NET Core】環境變數 Environments" href="https://fakestandard.github.io/netcore/netcore5-7-environments/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）</h2>
  </header>
  <section class="entry-content">
    <p>【5/21 閱讀紀錄】
搜尋屬於相當典型的演算法，在資料處理的過程中，用最短的時間內搜尋到所需要的資料，是一個相當重要的議題，其中與進行的方式和選擇的資料結構有很大的關聯。
依據資料量大小而言，搜尋可分為兩種
 內部搜尋：資料量小的檔案，可以一次載入到記憶體進行搜尋 外部搜尋：資料量大的檔案，無法全部載入到記憶體中，須將檔案加以組織化，再儲存於硬碟中，搜尋時須循著檔案組織性來達成  依據搜尋過程時，被搜尋的資料是否有異動，可分為兩種
 靜態搜尋（Static Search）：資料搜尋的過程中，資料不會有增加、刪除或更新等行為 動態搜尋（Dynamic Search）：在資料搜尋的過程中，資料會經常性的增加、刪除或更新  程式碼已放上 GitHub
Start 常見的搜尋演算法
 循序搜尋演算法（Sequential Search） 二分搜尋演算法（Binary Search） 內插搜尋演算法（Interpolation Search） 費氏搜尋演算法（Fibonacci Search）  循序搜尋演算法（Sequential Search） 循序搜尋法又稱線性搜尋法（Linear Search），它的原理是走訪所有的資料，不論資料順序從頭到尾逐次搜尋，也不需要在搜尋前對資料做任何處理或排序，在沒有重複資料下，找到資料就中止搜尋，是一種最簡單的排序法。
它的缺點是搜尋速度較慢，因為對資料從頭到尾的訪問，最好的情況就是一次就找到，只進行一次比較；最壞的情況則是第 n 次才找到，則進行了 n 次比較。所以在數列長度很大時，循序搜尋法則不太適合使用，它通常適用於對檔案小的資料進行搜尋。
假設有一數列 10 20 30 40 50，欲從數列中找到鍵值 30，透過循序搜尋法，從頭到尾走訪，第一個先找到 10 進行比較，不符合條件，繼續找尋到第二個 20，依然不符合條件，找尋到第三個鍵值，經比對後符合條件，此時演算法中止。
利用上面的數列來看，最佳的情況是第一次搜尋就符合條件，然後中止搜尋，只進行了一次比較，例如欲搜尋鍵值 10，即是最佳情況；最壞的情況就是從頭走訪到尾，直到搜尋到最後一個鍵值才符合條件，或數列中都沒有符合條件的鍵值，假設數列長度為 n，則需進行 n 次比較，例如欲搜尋鍵值 50 或不存在數列中的鍵值 60，即是最差情況。
演算法分析  最差的情況下，時間複雜度為 O(n) 平均情況下，需要 (n&#43;1)/2 次的比較  實際撰寫程式碼 亂數產生 1-150 之間的 100 個整數，並實作循序搜尋法的過程...</p>
  </section>
  <footer class="entry-footer">June 23, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】搜尋演算法—循序搜尋法（Sequential Search）" href="https://fakestandard.github.io/algorithm/algorithm-18-sequentialsearch/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【OOP】物件導向特性—封裝、繼承、多型</h2>
  </header>
  <section class="entry-content">
    <p>Start 說到物件導向就不能不知道OOP的三大特性—封裝、繼承、多型。
 建議閱讀本篇前先閱讀前篇「基礎概念」，在實例及解說上，若前篇已講解過，則此篇不再重複說明
 封裝（Encapsulation） 每個物件都包含進行操作時所需要的所有資訊，物件不必依賴其他物件來完成自己的操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。
封裝的好處
 良好的封裝能減少耦合（Coupling） 可自由修改類別內部的實現 類別具有清晰的對外界面  所以在設計 Swordman 類別時即為封裝，將自己的屬性及方法包裝起來，供給自己使用，不依賴他人。
static void Main(string[] args) { Swordman swordman = new Swordman(); } /// &lt;summary&gt; /// 封裝類別 /// &lt;/summary&gt; class Swordman { // Field  // ...  // Property  // ...  // Method  // ... } 繼承（Inheritance） 繼承很字面的意思，那有幾個特性須知道，子類別繼承父類別時，子類別擁有父類別 pirvate 以外的屬性和方法，子類別也可擁有自己的屬性和方法。最後，子類別可以用自己的方式實現父類別的功能，即方法重載。
原本有 Swordman 的類別，現在增加一個 Thief 類別，與 Swordman 擁有相同的屬性和方法。
/// &lt;summary&gt; /// 盜賊類別 /// &lt;/summary&gt; class Thief { private string name = string....</p>
  </section>
  <footer class="entry-footer">June 22, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【OOP】物件導向特性—封裝、繼承、多型" href="https://fakestandard.github.io/post/oop/oop-2-oop-feature/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）</h2>
  </header>
  <section class="entry-content">
    <p>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  堆積樹排序法（Heap Tree Sort） 堆積樹排序法是選擇排序法的改良版，它可以減少選擇排序法的排序次數，進而減少排序時間。樹是一種資料結構，而堆積樹是一顆二元樹，二元樹的定義的定義為每個父節點最多只能有兩個子節點，而堆積樹是一種特殊的二元樹，父節點若小於子節點，稱為最小堆積（Min heap），父節點偌大於子節點，稱為最大堆積（Max heap）。
假設有一陣列，陣列資料分別為
                索引 A[0] A[1] A[2] A[3] A[4] A[5] A[6] A[7]   數值 69 81 30 38 9 2 47 61    將此陣列用二元樹表示，每個節點第一個數字為索引，第二個為數值...</p>
  </section>
  <footer class="entry-footer">June 21, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】排序演算法—堆積樹排序法（Heap Tree Sort）" href="https://fakestandard.github.io/algorithm/algorithm-17-heaptreesort/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】排序演算法—基數排序法（Radix Sort）</h2>
  </header>
  <section class="entry-content">
    <p>【5/20 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  基數排序法（Radix Sort） 基數排序法與其他的排序法不太相同，不需要進行比較交換的動作，它是透過分配的方式進行排序。主要的分配的方向有兩種，其一是有效鍵優先（Most Significant Digit First, MSD），以及無效鍵優先（Least Significant Digit First, LSD），MSD 是從最左邊的位數開始比較，LSD 則是從最右邊開始比較，該怎麼說呢？馬上來看範例
LSD 以 LSD 方式對一數列 59 95 7 34 60 168 171 259 372 45 進行比較
Step 1 將每個元素依照「個位數」放到相對應的串列中
                 0 1 2 3 4 5 6 7 8 9   60 171 372  34 95  7 168 59        45    259    將分配的結果合併 60 171 372 34 95 45 7 168 59 259...</p>
  </section>
  <footer class="entry-footer">June 18, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】排序演算法—基數排序法（Radix Sort）" href="https://fakestandard.github.io/algorithm/algorithm-16-radixsort/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【.NET Core】組態設定 Configuration</h2>
  </header>
  <section class="entry-content">
    <p>【ASP.NET Core 5】
Start .NET Framework 的組態通常在 app.config 或 web.config 中設定，在 .NET Core 不再使用過往讀取單一檔案方法，它使用一個或多個 Configuration Provider 來提供多種設定組態的方式。
預設組態 應用程式在 Program.cs 預設產生 Host.CreateDefaultBuilder(args) 程式碼，CreateDefaultBuilder 會依照下列 Provider 的順序提供應用程式預設組態
 ChainedConfigurationProvider appsettings.json appsettings.Environment.json Environment Variables configuration provider Command-line configuration provider  使用下列程式碼，依新增順序來顯示 Configuration Provider
private IConfigurationRoot ConfigRoot; public HomeController(IConfiguration configRoot) { ConfigRoot = (IConfigurationRoot)configRoot; } public ContentResult OnGet() { string str = &#34;&#34;; foreach (var provider in ConfigRoot.Providers.ToList()) { str &#43;= provider.ToString() &#43; &#34;\n&#34;; } return Content(str); } 結果與前述說明的順序相同...</p>
  </section>
  <footer class="entry-footer">June 17, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【.NET Core】組態設定 Configuration" href="https://fakestandard.github.io/netcore/netcore5-6-configuration/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】排序演算法—合併排序法（Merge Sort）</h2>
  </header>
  <section class="entry-content">
    <p>【5/18 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  合併排序法（Merge Sort） 合併排序法的原理是將兩個或兩個以上的數列，經由合併的方式組合成一個排序好的數列。
步驟非常好理解，如下
 將 N 個長度為 1 的鍵值合併成 N/2 個長度為 2 的鍵值 將 N/2 個長度為 2 的鍵值，合併成 N/4 個長度為 4 的鍵值 將 N/4 個長度為 4 的鍵值，合併成 N/8 個長度為 8 的鍵值 重複地將鍵值合併，直到合併成一個長度為 N 的鍵值為止  使用一個未排序陣列解說步驟，目標是由小到大排序，陣列如下 38 16 41 72 52 98 63 25...</p>
  </section>
  <footer class="entry-footer">June 16, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】排序演算法—合併排序法（Merge Sort）" href="https://fakestandard.github.io/algorithm/algorithm-15-mergesort/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】排序演算法—快速排序法（Quick Sort）</h2>
  </header>
  <section class="entry-content">
    <p>【5/17 閱讀紀錄】
排序（Sorting）功能對於資訊領域而言，是一項非常重要且普通的工作。將一群資料按照特定規則重新排序，使其具有遞增或遞減的次序關係。
經由排序過的資料，會較容易閱讀，也利於統計及整理，甚至大幅減少資料搜尋的時間，進而提升資料參考價值。
程式碼已放上 GitHub
Start 常見的排序演算法
 氣泡排序法（Bubble Sort） 選擇排序法（Selection Sort） 插入排序法（Insert Sort） 謝耳排序法（Shell Sort） 快速排序法（Quick Sort） 合併排序法（Merge Sort） 基數排序法（Radix Sort） 堆積樹排序法（Heap Tree Sort）  快速排序法（Quick Sort） 快速排序法又稱分割交換排序法，也是目前公認最佳的排序法，原理為使用分治法的方式，從資料中找到一個虛擬中間值，依此中間值將資料分為兩部分，將小於中間值的資料放到左邊，反之，大於中間值放到右邊，以同樣的方式處理左右兩邊資料，直到排序完成。
其步驟如下
 將第一個資料作為中間值 K 從左至右找出大於 K 的第一值作為 I 從右向左找到小於 K 的第一個值作為 J 如果 I &gt; J，則 I 與 J 互換，然後回到第二步驟 若在尋找的過程中 I 與 J 有相遇，則 K 與 J 互換，接著以 K 作為基準點分割成左右兩部分，重複步驟一到步驟五，直到排序完成。  演示有一序列需要排序，數值為 1~8，將第一個值作為 K
               6 8 1 4 5 3 7 2   K           從左右兩邊開始分別找出 I 與 J，左邊找大於 K 值作為 I，右邊找小於 K 值作為 J...</p>
  </section>
  <footer class="entry-footer">June 13, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】排序演算法—快速排序法（Quick Sort）" href="https://fakestandard.github.io/algorithm/algorithm-14-quicksort/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【.NET Core】記錄 Logging</h2>
  </header>
  <section class="entry-content">
    <p>【ASP.NET Core 5】
過去在記錄 Log 時，會使用第三方套件來記錄，在 .NET Core 預設就已經將 Logger 注入到 DI 容器，直接使用 ILogger 介面來執行。
Start 此篇會紀錄的部分有以下
 Logging Provider Create Logs Log Level Log EventID Log Message Log Exceptions Configure Logging  Logging Provider Logging Provider 會儲存記錄檔，但 Console 顯示記錄的提供者除外。
在 Program.cs 調用 CreateDefaultBuilder 會新增下列記錄提供者
 Console Debug EventSource EventLog: Windows only  欲 override 由 Host.CreateDefaultBuilder 設置的 logging provider 集合，可呼叫 ClearProviders 移除所有 ILoggerProvider 實例，再加入需要的記錄提供者。
public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host....</p>
  </section>
  <footer class="entry-footer">June 11, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【.NET Core】記錄 Logging" href="https://fakestandard.github.io/netcore/netcore5-5-logging/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://fakestandard.github.io/tags/csharp/page/2/">« Prev Page</a>
    <a class="next" href="https://fakestandard.github.io/tags/csharp/page/4/">Next Page »</a>
  </nav>
</footer>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://fakestandard.github.io/">How can I help</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
