<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# on How can I help</title>
    <link>https://fakestandard.github.io/tags/c#/</link>
    <description>Recent content in C# on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 19 Apr 2021 18:33:22 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【C#】取得電腦名稱、作業系統版本、記憶體及文化特性資訊</title>
      <link>https://fakestandard.github.io/post/csharp-1-getosinformation/</link>
      <pubDate>Mon, 19 Apr 2021 18:33:22 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/post/csharp-1-getosinformation/</guid>
      <description>Start 近期為了在客戶的應用程式中添加一些裝置資訊，並將裝置資訊記錄成 LOG，以利下次客戶有問題時，可以先讓客戶提供有用資訊加以判斷。
引用 Microsoft.VisualBasic.Devices 命名空間，使用該命名空間下的 Computer 類別來取得資訊，Computer 類別提供許多屬性來操作電腦元件，這篇紀錄如何取得裝置資訊。
Computer computer = new Computer(); // 取得裝置名稱 Console.WriteLine(computer.Name); // 實體記憶體總量 Console.WriteLine(computer.Info.TotalPhysicalMemory); // 虛擬記憶體總量 Console.WriteLine(computer.Info.TotalVirtualMemory); // 可用實體記憶體總量 Console.WriteLine(computer.Info.AvailablePhysicalMemory); // 可用虛擬記憶體總量 Console.WriteLine(computer.Info.AvailableVirtualMemory); // 完整作業系統名稱 Console.WriteLine(computer.Info.OSFullName); // OS 平台識別項 Console.WriteLine(computer.Info.OSPlatform); // OS 版本 Console.WriteLine(computer.Info.OSVersion); // OS 文化特性 Console.WriteLine(computer.Info.InstalledUICulture); 除了使用 Computer 類別之外，也可以使用 ComputerInfo 取得裝置資訊
ComputerInfo info = new ComputerInfo(); 上述看到 computer.Info.InstalledUICulture 文化特性，在該屬性下還有很多屬性可以使用，如下。
// 系統所安裝的 UI 文化特性 Console.WriteLine(computer.Info.InstalledUICulture); // 預設行事曆 Console.WriteLine(computer.Info.InstalledUICulture.Calendar); // 該文化特性的曆法集合 foreach (var calendar in computer.</description>
    </item>
    
    <item>
      <title>【Algorithm】經典演算法</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</link>
      <pubDate>Mon, 05 Apr 2021 13:41:55 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-1-classicalgorithm/</guid>
      <description>【3/28 閱讀紀錄】
Introduce 此篇想記錄一些閱讀的筆記，演算法乃是運算思維的基石之一，藉由紀錄加深一下演算法的概念。
Start 演算法種類很多，經典的演算法有以下幾種
 分治演算法（Divide and conquer） 疊代演算法（Iterative Algorithm） 遞迴演算法（Recursion Algorithm） 動態規劃演算法（Dynamic Programming Algorithm） 枚舉演算法（Exhaustive Searching） 貪心演算法（Greedy Algorithm） 回溯演算法（Backtracking Algorithm）  分治演算法（Divide and conquer） 分治演算法是一種簡單又重要的演算法，它將複雜的問題逐一拆解成單元較小的問題，問題規模較小則容易求解，最終在合併子問題以得到原問題的解答，在日常生活中也能時時應用到。
像是以往在進行團體報告時，假設報告主題的章節共有五個章節，當然不可能讓一個人獨立完成五個章節，這時就可以透過分治法，將各章節逐一拆解成較小單元，每位成員負責一個章節，讓五位成員同時進行，在時間上遠遠勝於一人獨立完成所有章節，且透過分工還可能達到其他效果。
然而分治演算法還可應用在數字的分類和排序上，舉個例子，手邊有一副順序打亂的撲克牌，現在要將它們復原到起初開封時的排序，依序分類為黑桃、紅心、梅花、方塊，每個分類需從 A-K 逐一排序。此時有兩種做法，第一種為每拿到一張牌，就將它插入到適當的順序中，但缺點是在整理的過程中較繁瑣也較花時間。第二種作法則是應用分治演算法，以不考慮 A-K 順序的情況下，將黑桃分成一堆，紅心分成一堆，以此類推，最終會將黑桃、紅心、梅花、方塊分類出來，此時在逐一將每個分類的 A-K 順序整理好，再將其合併。
所以透過分治演算法可將複雜的大問題，拆解成規模小的子問題，雖然子問題的數量多，相對的更易於解決，解決的速度上也相對的快。
疊代演算法（Iterative Algorithm） 無法使用一次公式就能求解，需透過反覆的運算才能得解的方法稱為疊代演算法，像是透過迴圈去循環重複的程式碼來得到答案。
舉例：利用 for 迴圈設計 n! 的遞迴程式，n 是透過外部輸入得知，打算 1! ~ n! 所有結果
// 從外部輸入 n int n = int.Parse(Console.ReadLine()); // 用以計算結果 int sum = 1; // 使用迴圈計算 1! ~ n! for (int i = 1; i &amp;lt;= n; i++) { for (int j = i; j &amp;gt; 0; j--) { sum = sum * j; } Console.</description>
    </item>
    
  </channel>
</rss>
