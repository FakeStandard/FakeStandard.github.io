<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Tree | How can I help</title>
<meta name="keywords" content="" />
<meta name="description" content="不專業代碼">
<meta name="author" content="Polar Bear">
<link rel="canonical" href="https://fakestandard.github.io/tags/tree/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d1b405b7c6bf1b09aebca33eb6e2d8bd070113d119bdfa2715c32f6408f9fbee.css" integrity="sha256-0bQFt8a/GwmuvKM&#43;tuLYvQcBE9EZvfonFcMvZAj5&#43;&#43;4=" rel="preload stylesheet" as="style">


<script data-ad-client="ca-pub-4877674098686024" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<meta name="google-site-verification" content="iCWzIE4kN0sAVM_Slr-q8E5zIT2Qfs-IxUuxhpFVD94" />







<link rel="icon" href="https://fakestandard.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fakestandard.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fakestandard.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fakestandard.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fakestandard.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<link rel="alternate" type="application/rss+xml" href="https://fakestandard.github.io/tags/tree/index.xml">
<meta property="og:title" content="Tree" />
<meta property="og:description" content="不專業代碼" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fakestandard.github.io/tags/tree/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tree"/>
<meta name="twitter:description" content="不專業代碼"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fakestandard.github.io/" accesskey="h" title="How can I help (Alt + H)">How can I help</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fakestandard.github.io/post/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/algorithm/" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/netcore/" title=".NET Core">
                    <span>.NET Core</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://fakestandard.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://fakestandard.github.io/tags/">Tags</a></div>
  <h1>Tree</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—平衡樹（Balanced Binary Tree）</h2>
  </header>
  <section class="entry-content">
    <p>Start Reference 【圖說演算法 C#】</p>
  </section>
  <footer class="entry-footer">August 30, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—平衡樹（Balanced Binary Tree）" href="https://fakestandard.github.io/algorithm/algorithm-44-balancedbinarytree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—引線二元樹（Threaded Binary Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【6/9 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 一般來說，一個 n 節點的二元樹，共有 2n 個 LINK 欄位，實際上使用的數量只有 n-1 個鏈結，另外 n&#43;1 個都是空鏈結，等於有 n&#43;1 個空間被浪費，而引線二元樹就是將這些空鏈結加以利用，再指到其他節點，這些鏈結就稱為引線，其樹稱為引線二元樹（Threaded Binary Tree）。
將二元樹轉換成引線二元樹的第一步，先將二元樹以中序走訪方式將資料排出，接著找出所有節點的空指標，再將節點的空指標指向其左、右相鄰的節點，即使用引線取代指向 Null 的指標。
引線二元樹的資料結構
 LBit：左控制位元 LChild：左子樹指標 Data：節點資料 RChild：右子樹指標 RBit：右控制位元  引線二元樹會用一個額外的 Bit，以判斷指標內容是 Link 還是 Thread
 LBit = 1, LChild 是正常指標 LBit = 0, LChild 是引線 RBit = 1, RChild 是正常指標 RBit = 0, RChild 是引線  所以在定義引線二元樹的節點類別時，會比一般二元樹多了左、右控制位元兩屬性
/// &lt;summary&gt; /// 引線二元樹節點類別 /// &lt;/summary&gt; public class ThreadNode { public int data; public int lbit; public int rbit; public ThreadNode leftNode; public ThreadNode rightNode; public ThreadNode(int data) { this....</p>
  </section>
  <footer class="entry-footer">August 27, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—引線二元樹（Threaded Binary Tree）" href="https://fakestandard.github.io/algorithm/algorithm-43-threadedbinarytree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元運算樹（Binary Expression Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【6/7 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹應用範圍還可包含運算式間的轉換，我們可以把一個四則運算，使用二元樹來表示，再依二元樹的特性進行前中後序的走訪，即二元運算樹（Binary Expression Tree）
書中表示建立方法有以下二種規則
  考慮算術式中運算子的結合性與優先權，再適當地加上括號，其中樹葉一定是運算元，內部節點一定是運算子 再由最內層的括號逐步向外，利用運算子當樹根，左邊運算元當左子樹，右邊運算元當右子樹，其中優先權最低的運算子作為此二元運算樹的樹根   以 ((7&#43;8)/5)*(4&#43;9-3) 運算式為例，先建立二元運算樹
接著分別求出此運算式的前中後序表示法
前序（Prefix） 又稱波蘭表示法（Polish notation），上述例子利用前序走訪表示為 */&#43;785&#43;4-93
中序（Infix） 對於中序表示法而言，運算元是二元樹的葉節點，運算子是非終端節點，其表示法也是一般的運算式。以中序走訪表示為 ((7&#43;8)/5)*(4&#43;9-3)
後序（Postfix） 又稱逆波蘭表示法（Reverse Polish notation），上述例子利用後序走訪表示為 78&#43;5/493-&#43;*
利用鏈結串列實作二元運算樹之運算，先建立節點和二元樹類別
/// &lt;summary&gt; /// 節點類別 /// &lt;/summary&gt; class TreeNode { public int val; public TreeNode leftNode; public TreeNode rightNode; public TreeNode(int val) { this.val = val; this.leftNode = null; this.rightNode = null; } } /// &lt;summary&gt; /// 二元搜尋樹類別 /// &lt;/summary&gt; class BinarySearchTree { public TreeNode root; public BinarySearchTree() { root = null; } public BinarySearchTree(int[] data) { for (int i = 0; i &lt; data....</p>
  </section>
  <footer class="entry-footer">August 23, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元運算樹（Binary Expression Tree）" href="https://fakestandard.github.io/algorithm/algorithm-42-binaryexpressiontree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元排序樹在先前的文章都已經有實作過，一顆符合規定的二元樹，也就是二元排序樹，必須符合以下規則
 第一個輸入的值作為二元樹的樹根 逐一將後續的資料與樹根進行比較，大於樹根的資料放置右子樹，小於樹根的資料放置左子樹，以遞迴的方式進行比較，直到資料找到一個空節點可以放置。  假設有一陣列 12, 46, 10, 23, 11, 30, 7, 21，欲對此陣列建立二元排序樹，先將地一個元素作為樹根
接著取得第二個元素，與樹根作比較，因元素 46 大於樹根 12，故放置於右子樹
繼續取得第三個元素，與樹根作比較，因元素 10 小於樹根 12，故放置於左子樹
取得第四個元素，與樹根作比較，元素 23 大於樹根 12，故放置於右子樹，但右子樹已經存在 46 這個節點，所以繼續將元素 23 與右子樹根節點 46 進行比較，最後元素 23 小於 46，故放置於左子樹中。
使用此方式繼續將所有資料在樹中進行比較，欲到已被佔位的節點，就繼續比較，最後形成一顆二元排序樹。
實作程式碼的部分也相當簡單，先前也實作過很多遍，透過遞迴的方式進行比較，值到有空節點為止。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this....</p>
  </section>
  <footer class="entry-footer">August 20, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）" href="https://fakestandard.github.io/algorithm/algorithm-41-binarysorttree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹插入與刪除節點</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 這篇文章會紀錄節點插入與刪除的原理與應用
節點插入 在二元樹中節點插入非常簡單，利用先前學到的走訪與搜尋，先對二元樹進行走訪搜尋，若搜尋時發現樹中已存在相同值，則節點插入失敗，若樹中沒有找到值，才執行節點插入。
依據先前實作過的樹，逐一建立樹節點類別、二元樹類別，二元樹類別中至少需具有新增節點方法與搜尋節點方法，方能執行節點插入。在類別中額外添加前序走訪方法，供後續輸出二元樹節點使用。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } /// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array.Length; i&#43;&#43;) AddNode(array[i]); } public void AddNode(int value) { if (root == null) { root = new TreeNode(value); return; } TreeNode current = root; while (true) { if (value &gt; current....</p>
  </section>
  <footer class="entry-footer">August 17, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹插入與刪除節點" href="https://fakestandard.github.io/algorithm/algorithm-40-binarytreeinsertanddelete/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元搜尋樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元搜尋樹其實就是在樹中搜尋指定的值，只是二元搜尋樹必須符合以下特性
 可以是空集合，若非空集合，則節點上必須有一個鍵值 每個樹根的值須大於左子樹的值 每個樹根的值必須小於右子樹的值 左右子樹也同是二元搜尋樹 樹的每個節點值都不相同  那要如何搜尋？其實很簡單，只需在二元樹中比較樹節點值和欲搜尋的值，依序由左子樹→樹根→右子樹的順序進行走訪，直到找到值或搜尋完畢為止。
實作程式碼，先建立樹節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹類別，下一步實作搜尋方法
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 13, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元搜尋樹" href="https://fakestandard.github.io/algorithm/algorithm-39-binarysearchtree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹走訪</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 對於線性結構的陣列和串列而言，只能執行單向的走訪，如從頭到尾或反向走訪，而二元樹的走訪即是訪問樹中所有節點一次，並且在走訪後，將樹中的資料傳換成線性關係。
二元樹走訪方式有三種，以樹根訪問的順序作為區分，分別是
 前序走訪（Preorder Traversal）：樹根→左子樹→右子樹 中序走訪（Inorder Traversal）：左子樹→樹根→右子樹 後序走訪（Postorder Traversal）：左子樹→右子樹→樹根  從上可以明顯知道，先訪問樹根的稱為前序走訪，後訪問樹根稱為後續走訪，而樹根訪問順序在中間稱為中序走訪，非常的好記。
前序走訪 前序走訪的順序是由上往下進行訪問，從樹根開始，接著往左方移動走訪左子樹，若無法再繼續前進時，則往右方移動訪問右子樹，重複此步驟直到訪問完成。
以上圖為例，訪問的順序是 A→B→D→F→G→H→I→E→C
中序走訪 中序走訪的順序，是從樹根左側開始向下移動，直到無法移動時，追蹤此節點，再往右側移動，若右側無法再移動時，則返回上層父節點，重複左中右的順序進行訪問。
以上圖為例，訪問的順序是 F→D→H→G→I→B→E→A→C
後序走訪 後序走訪的順序，從左子樹開始，接著在往右子樹，最後訪問樹根，因樹根是最後訪問，訪問的方向是由下往上，與前序稍微不同的感覺。
以上圖為例，訪問的順序是 F→H→I→G→D→E→B→C→A
實作程式碼時間，分別為三種走訪方式設計方法，讓以串列表示的二元樹，可以分別輸出前序、中序和後序走訪的結果
建立樹的節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹的類別，其中前序、中序和後續走訪方法在下一步實作
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 9, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹走訪" href="https://fakestandard.github.io/algorithm/algorithm-38-binarytreetraversal/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—串列實作二元樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以串列來表示二元樹，假設有一顆樹，如下
該如何使用串列來表示？
使用鏈結串列來表示二元樹的優點，是在新增和刪除節點時非常容易，缺點則是不容易找到父節點。在使用陣列儲存歪斜樹時，會造成許多的空間被浪費，對於歪斜樹來說，使用串列儲存較為節省空間。
根據上一篇的慘痛經驗，這篇偷偷將樹的值改了一個，讓樹高只維持在 4，上一篇做到 5 層，可真是毅力與耐力的考驗。
首先，先了解一下要如何使用串列來表示二元樹，在先前學過的串列，都具有一個資料欄和指標欄，指標欄存放著下一個節點的記憶體位置，作為節點與節點之間的連結，透過指標的特性，我們將指標欄設置為兩個，分別為左指標與右指標，左指標存放左子樹的節點位址，右指標存放右子樹的節點位址，如下圖所示
使用一個陣列先將樹的節點值儲存起來
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。
在使用串列表示二元樹時，也必須符合二元樹的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值，最後以串列表示的方式如下
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 31, 23, 11, 30, 7, 10 }，按照二元樹的定義，形成一顆以串列表示的完整二元樹。
先建立樹節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { // 值  public int data; // 左子樹  public TreeNode leftNode; // 右子樹  public TreeNode rightNode; public TreeNode(int value) { this....</p>
  </section>
  <footer class="entry-footer">August 5, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—串列實作二元樹" href="https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—陣列實作二元樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以陣列來表示二元樹，假設有一顆樹，如下
該如何使用陣列來表示？
首先，我們可以先想像這是一顆完整二元樹，從樹根開始，依序由左到右、上到下編號，對於空的樹葉依然給它編號，但元素依然為空，如下
準備一個一維陣列，陣列大小為完滿二元樹的最大編號加一，以上圖來說最大編號是 15，其陣列大小為 15&#43;1，因為陣列首將不放任何元素，如下
依照前述的編號，將編號的樹葉值填入相對應的陣列位置
如此一來就完成使用陣列表示樹的方法，不過這個例子不能是一顆二元樹，因為它並不符合上述的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。
為了要讓它成為一顆符合定義個二元樹，先把這顆樹的值都取出來，存放於一個陣列中
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。如下
繼續將剩下的陣列元素，逐一放入完整二元樹中，其放置過程中必須符合樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。最後完成一顆符合規定的二元樹（例子又沒開好QQ）
接著為二元樹編上編號，再將完滿二元樹轉換成陣列表示法，大功造成！
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 10, 23, 11, 30, 7, 31 }，按照二元樹的定義，形成一顆以陣列表示的完整二元樹
static void Main(string[] args) { int i, j; // 原始陣列  int[] data = { 12, 46, 10, 23, 11, 30, 7, 31 }; int[] btree = new int[32]; for (i = 0; i &lt; btree....</p>
  </section>
  <footer class="entry-footer">August 2, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—陣列實作二元樹" href="https://fakestandard.github.io/algorithm/algorithm-36-arrayimplementationoftree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】資料結構—樹（Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【5/17 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。
上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。
對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。
樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）
樹的基本術語有許多種，利用上圖的樹狀圖一一解說
  根節點（Root）
先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點
  葉節點（Leaf）或終點節點（Terminal Nodes）
節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點
  非終端節點（Nonterminal Nodes）
除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H
  子節點（Children）
每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D
  父節點（Parent）
每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C
  祖先節點（Ancestor）
指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。...</p>
  </section>
  <footer class="entry-footer">May 24, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】資料結構—樹（Tree）" href="https://fakestandard.github.io/algorithm/algorithm-7-tree/"></a>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://fakestandard.github.io/">How can I help</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
