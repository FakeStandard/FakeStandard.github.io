<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tree on How can I help</title>
    <link>https://fakestandard.github.io/tags/tree/</link>
    <description>Recent content in Tree on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 09 Aug 2021 09:58:38 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】樹的應用—二元樹走訪</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-38-binarytreetraversal/</link>
      <pubDate>Mon, 09 Aug 2021 09:58:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-38-binarytreetraversal/</guid>
      <description>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 對於線性結構的陣列和串列而言，只能執行單向的走訪，如從頭到尾或反向走訪，而二元樹的走訪即是訪問樹中所有節點一次，並且在走訪後，將樹中的資料傳換成線性關係。
二元樹走訪方式有三種，以樹根訪問的順序作為區分，分別是
 前序走訪（Preorder Traversal）：樹根→左子樹→右子樹 中序走訪（Inorder Traversal）：左子樹→樹根→右子樹 後序走訪（Postorder Traversal）：左子樹→右子樹→樹根  從上可以明顯知道，先訪問樹根的稱為前序走訪，後訪問樹根稱為後續走訪，而樹根訪問順序在中間稱為中序走訪，非常的好記。
前序走訪 前序走訪的順序是由上往下進行訪問，從樹根開始，接著往左方移動走訪左子樹，若無法再繼續前進時，則往右方移動訪問右子樹，重複此步驟直到訪問完成。
以上圖為例，訪問的順序是 A→B→D→F→G→H→I→E→C
中序走訪 中序走訪的順序，是從樹根左側開始向下移動，直到無法移動時，追蹤此節點，再往右側移動，若右側無法再移動時，則返回上層父節點，重複左中右的順序進行訪問。
以上圖為例，訪問的順序是 F→D→H→G→I→B→E→A→C
後序走訪 後序走訪的順序，從左子樹開始，接著在往右子樹，最後訪問樹根，因樹根是最後訪問，訪問的方向是由下往上，與前序稍微不同的感覺。
以上圖為例，訪問的順序是 F→H→I→G→D→E→B→C→A
實作程式碼時間，分別為三種走訪方式設計方法，讓以串列表示的二元樹，可以分別輸出前序、中序和後序走訪的結果
建立樹的節點類別
/// &amp;lt;summary&amp;gt; /// 樹節點類別 /// &amp;lt;/summary&amp;gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹的類別，其中前序、中序和後續走訪方法在下一步實作
/// &amp;lt;summary&amp;gt; /// 二元樹類別 /// &amp;lt;/summary&amp;gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &amp;lt; array.</description>
    </item>
    
    <item>
      <title>【Algorithm】樹的應用—串列實作二元樹</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/</link>
      <pubDate>Thu, 05 Aug 2021 20:54:11 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-37-linkedlistimplementationoftree/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以串列來表示二元樹，假設有一顆樹，如下
該如何使用串列來表示？
使用鏈結串列來表示二元樹的優點，是在新增和刪除節點時非常容易，缺點則是不容易找到父節點。在使用陣列儲存歪斜樹時，會造成許多的空間被浪費，對於歪斜樹來說，使用串列儲存較為節省空間。
根據上一篇的慘痛經驗，這篇偷偷將樹的值改了一個，讓樹高只維持在 4，上一篇做到 5 層，可真是毅力與耐力的考驗。
首先，先了解一下要如何使用串列來表示二元樹，在先前學過的串列，都具有一個資料欄和指標欄，指標欄存放著下一個節點的記憶體位置，作為節點與節點之間的連結，透過指標的特性，我們將指標欄設置為兩個，分別為左指標與右指標，左指標存放左子樹的節點位址，右指標存放右子樹的節點位址，如下圖所示
使用一個陣列先將樹的節點值儲存起來
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。
在使用串列表示二元樹時，也必須符合二元樹的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值，最後以串列表示的方式如下
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 31, 23, 11, 30, 7, 10 }，按照二元樹的定義，形成一顆以串列表示的完整二元樹。
先建立樹節點類別
/// &amp;lt;summary&amp;gt; /// 樹節點類別 /// &amp;lt;/summary&amp;gt; class TreeNode { // 值  public int data; // 左子樹  public TreeNode leftNode; // 右子樹  public TreeNode rightNode; public TreeNode(int value) { this.</description>
    </item>
    
    <item>
      <title>【Algorithm】樹的應用—陣列實作二元樹</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-36-arrayimplementationoftree/</link>
      <pubDate>Mon, 02 Aug 2021 16:11:37 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-36-arrayimplementationoftree/</guid>
      <description>【5/27 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹建立的規則有以下特點
 可以是空集合，但若不是空集合，則節點一定要有一個鍵值 每一個樹根的值須大於左子樹的值 每一個樹根的值須小於右子樹的值 樹的每個節點值都不同 左右子樹也是二元搜尋樹  二元樹有兩種表示方法，分別是
 陣列 串列  這篇只紀錄如何以陣列來表示二元樹，假設有一顆樹，如下
該如何使用陣列來表示？
首先，我們可以先想像這是一顆完整二元樹，從樹根開始，依序由左到右、上到下編號，對於空的樹葉依然給它編號，但元素依然為空，如下
準備一個一維陣列，陣列大小為完滿二元樹的最大編號加一，以上圖來說最大編號是 15，其陣列大小為 15+1，因為陣列首將不放任何元素，如下
依照前述的編號，將編號的樹葉值填入相對應的陣列位置
如此一來就完成使用陣列表示樹的方法，不過這個例子不能是一顆二元樹，因為它並不符合上述的定義，樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。
為了要讓它成為一顆符合定義個二元樹，先把這顆樹的值都取出來，存放於一個陣列中
將陣列首作為樹根，並依照上述整理出的陣列，將陣列首放入完整二元樹的樹根，再依序將往後的值分別放入左右子樹，數值較樹根小的放左子樹，數值較樹根大的放右子樹。若比較完後，遇到左或右子樹的位置已有值，則往下一個階層進續比較，直到有樹葉為空可以擺放值。如下
繼續將剩下的陣列元素，逐一放入完整二元樹中，其放置過程中必須符合樹根的值須大於左子樹的值以及樹根的值須小於右子樹的值。最後完成一顆符合規定的二元樹（例子又沒開好QQ）
接著為二元樹編上編號，再將完滿二元樹轉換成陣列表示法，大功造成！
實作程式碼時間，以一開始的樹為例，用一維陣列儲存起來 A = { 12, 46, 10, 23, 11, 30, 7, 31 }，按照二元樹的定義，形成一顆以陣列表示的完整二元樹
static void Main(string[] args) { int i, j; // 原始陣列  int[] data = { 12, 46, 10, 23, 11, 30, 7, 31 }; int[] btree = new int[32]; for (i = 0; i &amp;lt; btree.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—樹（Tree）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-7-tree/</link>
      <pubDate>Mon, 24 May 2021 09:54:38 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-7-tree/</guid>
      <description>【5/17 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄樹定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  樹（Tree） 樹狀結構是一種階層架構的非線性結構，在生活中應用相當廣泛，舉凡組織架構、族譜、賽程，甚至在電腦中的作業系統、DBMS 和檔案管理系統都是樹狀結構的衍生運用。
上圖為樹狀結構的示例，它的名稱由來是取自於樹的象徵，在上圖中，看起來是一個上下顛倒樹，其根部在上方，是資料的開頭，而下方的資料稱為葉子。
對於合法的樹來說，節點間可以互相連結，但不能形成無出口的迴圈，例如下圖就是一個不合法的樹狀結構，因為在 H 節點與 C 節點形成了無出口的迴圈。
樹的概念是由一個或一個以上的節點（Node）所組成，而樹根稱為根節點（Root），樹根下的樹枝，稱為子節點（Children），每個子節點都會有向上一個樹根，稱為父節點（Parent）
樹的基本術語有許多種，利用上圖的樹狀圖一一解說
  根節點（Root）
先前已有大概解說過，一棵樹的樹根（即開頭）會被視為根節點，更準確地說是沒有父節點的節點是根節點。例如 A 是根節點
  葉節點（Leaf）或終點節點（Terminal Nodes）
節點沒有往下的子節點，稱為葉節點。例如 K、L、G 都是葉節點
  非終端節點（Nonterminal Nodes）
除了樹葉（葉節點）以外的節點都是非終端節點。例如 B、E、H
  子節點（Children）
每個節點連結的下層節點稱為子節點。例如 A 的子節點有 B、C、D
  父節點（Parent）
每個節點連結的上層節點稱為父節點。例如 H、I、J 的父節點為 D，G 的父節點為 C
  祖先節點（Ancestor）
指某個節點從自己本身到根節點之間的路徑，該路徑上所經過的所有節點皆是祖先節點。例如 M 的祖先為 A、D、H，F 的祖先為 A、B。</description>
    </item>
    
  </channel>
</rss>
