<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Algorithm | How can I help</title>
<meta name="keywords" content="" />
<meta name="description" content="不專業代碼">
<meta name="author" content="Polar Bear">
<link rel="canonical" href="https://fakestandard.github.io/tags/algorithm/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d1b405b7c6bf1b09aebca33eb6e2d8bd070113d119bdfa2715c32f6408f9fbee.css" integrity="sha256-0bQFt8a/GwmuvKM&#43;tuLYvQcBE9EZvfonFcMvZAj5&#43;&#43;4=" rel="preload stylesheet" as="style">


<script data-ad-client="ca-pub-4877674098686024" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<meta name="google-site-verification" content="iCWzIE4kN0sAVM_Slr-q8E5zIT2Qfs-IxUuxhpFVD94" />







<link rel="icon" href="https://fakestandard.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fakestandard.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fakestandard.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fakestandard.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://fakestandard.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<link rel="alternate" type="application/rss+xml" href="https://fakestandard.github.io/tags/algorithm/index.xml">
<meta property="og:title" content="Algorithm" />
<meta property="og:description" content="不專業代碼" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://fakestandard.github.io/tags/algorithm/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Algorithm"/>
<meta name="twitter:description" content="不專業代碼"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fakestandard.github.io/" accesskey="h" title="How can I help (Alt + H)">How can I help</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fakestandard.github.io/post/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/algorithm/" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/netcore/" title=".NET Core">
                    <span>.NET Core</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://fakestandard.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://fakestandard.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://fakestandard.github.io/tags/">Tags</a></div>
  <h1>Algorithm</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】雜湊應用—碰撞與溢位處理</h2>
  </header>
  <section class="entry-content">
    <p>【5/25 閱讀紀錄】
根據先前文章介紹的雜湊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 當要把資料放到某個 Bucket 時，若該 Bucket 已滿，則會發生溢位（Overflow）；另一種情況是，不同資料經雜湊函數運算後，得到相同的位址，則發生碰撞（Collision）。
當溢位及碰撞發生時，通常會透過下列四種演算法處理
 線性探測法 平方探測法 再雜湊 鏈結串列  線性探測法 當兩資料經雜湊函數運算後，得到相同雜湊值，則發生碰撞，此時透過線性探測法，以線性的方式往後尋找空的位置，一旦有空的位置就把資料放進去，直到找到空位，或儲存空間位址皆存滿為止。線性探測法通常把雜湊位置視為環狀結構，比如說，當雜湊值是儲存空間的最後一個位置，以線性探測法往下搜尋空位，第一個搜尋的位置會是儲存空間的第一個，所以儲存空間會是以環狀的方式進行探索。
不過線性探測法因簡易所以有先天的缺陷，若資料鍵值容易聚集在一起，要尋找空位就要尋找很久。但還是要實作一下代碼，使用除法雜湊函數取得雜湊值，以線性探測法來儲存資料。
建立靜態變數與陣列
static int INDEX = 17; static int MAX = 13; // 建立資料雜湊最大元素 static int?[] index = new int?[INDEX]; // 建立陣列儲存空間 static int[] data = new int[MAX]; 建立相關方法
/// &lt;summary&gt; /// 亂樹建立資料 /// &lt;/summary&gt; static void CreateData() { int i; Random r = new Random(); for (i = 0; i &lt; MAX; i&#43;&#43;) data[i] = r....</p>
  </section>
  <footer class="entry-footer">September 9, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】雜湊應用—碰撞與溢位處理" href="https://fakestandard.github.io/algorithm/algorithm-47-hashcollisionandoverflow/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】雜湊應用—雜湊演算法</h2>
  </header>
  <section class="entry-content">
    <p>【5/24 閱讀紀錄】
根據先前文章介紹的雜湊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 雜湊法是利用雜湊函數來計算鍵值所對應的位址，進而建立雜湊表。
常見的雜湊函數有四種
 除法 中間平方法 折疊法 數位分析法  除法 除法是最簡單的雜湊演算法，原理是將資料除以某個常數（通常會選擇質數），取其餘數作為索引，在將資料儲存於索引相對應的位址。
公式是 H(key) = key mod B
假設一陣列大小為 7，欲將 12, 65, 70, 99, 67 這五個值經由雜湊法，放入相對應的位置，因陣列大小為 7，故將 B 帶入質數 7 進行雜湊，得到結果會界於 0-6 之間以符合陣列大小，如 H(12) = 12 mod 7 = 5，最後可得雜湊表如下
中間平方法 中間平方法是將資料自己做平方，再取中間的某段數字做為索引。
假設一陣列的位址空間大小為 100，欲將 12, 65, 70, 99, 67 五個值經由雜湊法，放入相對應的位址。首先，先將每個資料平方，就是資料與自己相乘，可得 144, 4225, 4900, 9801, 4489，分別取得這五個值的百位數及十分數，分別為 14, 22, 90, 80, 48，將得到的索引鍵值分別放入原先的對應值，即
f(14) = 12 f(22) = 65 f(90) = 70 f(80) = 99 f(67) = 48 折疊法 折疊法是先將資料轉換成一串數字，再將數字拆成數個部分，最後再將它們相加得到 Bucket Address。折疊法區分為以下兩種...</p>
  </section>
  <footer class="entry-footer">September 6, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】雜湊應用—雜湊演算法" href="https://fakestandard.github.io/algorithm/algorithm-46-hashalgorithm/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】雜湊應用—安全性演算法</h2>
  </header>
  <section class="entry-content">
    <p>【5/24 閱讀紀錄】
根據先前文章介紹的雜湊，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 網路目前已經非常普及，在網路的世界裡有大量的資料再進行傳輸，但在傳輸的過程中，有些資訊可以被公開共享，有些則屬於機密資料，不得被竊取或是破壞，例如交易。
對於 資訊安全（Information Security） 來說，必須具備以下四種特性
 秘密性（Confidentiality）
當資料在網路上傳遞時，必須確保資料傳遞時不會被竊取，進而洩漏資料內容，除了被授權者之外，資料皆必須保密。 完整性（Integrity）
當資料送達時，必須保證資料沒有被竄改，如果訊息被竄改，收訊端在接收時會立刻知道資料是否完整。 認證性（Authentication）
當傳送方送出資訊時，必須能確認傳送者的身分是否經過認證，如未經認證就是假冒傳送方，將無法傳送資料，例如持卡人、發卡行、支付閘道都必須申請憑證進行身分識別。 不可否認性（Non-repudiation）
表示保證者無法否認完成過的資料傳送行為的一種機制，指無法否認傳送或接收訊息的行為，例如轉出金錢不可否認未轉出過，有金額轉入也不可否認未收到。  資料加密 基於資訊安全，必須對欲傳遞的資料進行加密，方能確保在網路傳輸時不會被有心人士攔截瀏覽，因此我們可以利用事先定義好的演算法、運算式或編碼方式，將資料轉換成不具任何意義的數據，其處理的過程就是 「加密」（Encrypt） ，反之，要將不具任何意義的數據，轉換成原始資料，該過程稱為 「解密」（Decrypt） ，在加密前的原始資料我們稱為 「明文」（Plaintext） ，經加密後得到的結果數據 「密文」（Cipher text），在加解密的過程中，有一個 金鑰（Key） 機制，傳送者將明文透過金鑰進行加密，再丟到網路上傳輸，接收者透過網路接收到密文，將密文以金鑰解密得到明文，此過程即是標準加解密的流程。
在基礎密碼學中，有兩種加解密方式，分別是「對稱加密」和「非對稱加密」
對稱式加密（Symmetric Encryption） 對稱式加密的運作方式，是由傳送者利用金鑰將資料加密後，再加以傳送，而接收方收到訊息後，再用金鑰解密，就能看到訊息內容。
此方法非常簡易，傳送方與接收方彼此共用同一把金鑰，在第一次傳送時會夾帶金鑰一起傳送出去，使接收方可以利用金鑰進行解密，但是此方法也較為不安全，它最大的弱點就是，若再第一次傳送時，被有心人士從中攔截，且複製一把金鑰，再將資料繼續傳遞給接收方，那之後傳遞的資料都會被輕易破解。
常見的對稱加密演算法有 DES（Data Encryption Standard, 資料加密標準）、Triple DES、IDEA（International Data Encryption Algorithm, 國際資料加密演算法）等。
非對稱式加密（Asymmetric Encryption） 非對稱式加密比對稱式加密來的安全，以目前來說，使用上較為普遍，對金融界而言也是最安全的加密系統。
其原理是每個使用者都擁有一對（pair）金鑰，分別為公開金鑰（Public Key）和私密金鑰（Private Key），該對金鑰分別用來加密及解密，公開金鑰可以被廣泛流傳，私密金鑰則必須被妥善保存，當資料被一把金鑰加密時，必須以另一把進行解密，金鑰的加解密並非一定是公鑰加密私鑰解密，也可以是公鑰解密私鑰加密。
其運作方式，起初傳送方與接收方將彼此的公鑰傳送給對方，當傳送方要傳送資料時，就用接收方的公鑰進行加密，接收方收到訊息時，再用自己的私鑰進行解密；反之，接收方欲傳遞資料給傳送方，須使用傳送方的公鑰進行加密，傳送方收到資料後，再使用自己的私鑰進行解密動作。
如此一來，即便在傳遞公鑰的過程中，被有心人士攔截複製，沒有私鑰也無法解密資料。
常見的非對稱式加密 RSA，雖然加解密的速度比對稱式加密慢，其原理是隨機選出兩個超大的質數 p &amp; q，利用兩質數作為加密與解密的金鑰，金鑰的長度約 40 位元到 1024 位元之間，所以要短時間內破解 RSA 幾乎是不可能，是一種十分安全的演算法，在電子商務交易市場中被廣泛使用。
認證 在資料傳輸的過程中，為了避免使用者發送資料後不認帳（否認有傳遞），或有人冒用使用者名義進行資料傳遞，衍生出第三種加密方式—對資料進行認證工作。
其運作方式為，起初雙方傳遞公鑰給對方，傳送方使用接收方的公鑰加密，再使用自己的私鑰進行第二次加密，接收方收到資料後，先用傳送方的公鑰解密，再使用自己的私鑰進行解密，若解密成功，即能確保訊息傳遞的私密性。...</p>
  </section>
  <footer class="entry-footer">September 2, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】雜湊應用—安全性演算法" href="https://fakestandard.github.io/algorithm/algorithm-45-securityalgorithm/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—平衡樹（Balanced Binary Tree）</h2>
  </header>
  <section class="entry-content">
    <p>Start Reference 【圖說演算法 C#】</p>
  </section>
  <footer class="entry-footer">August 30, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—平衡樹（Balanced Binary Tree）" href="https://fakestandard.github.io/algorithm/algorithm-44-balancedbinarytree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—引線二元樹（Threaded Binary Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【6/9 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 一般來說，一個 n 節點的二元樹，共有 2n 個 LINK 欄位，實際上使用的數量只有 n-1 個鏈結，另外 n&#43;1 個都是空鏈結，等於有 n&#43;1 個空間被浪費，而引線二元樹就是將這些空鏈結加以利用，再指到其他節點，這些鏈結就稱為引線，其樹稱為引線二元樹（Threaded Binary Tree）。
將二元樹轉換成引線二元樹的第一步，先將二元樹以中序走訪方式將資料排出，接著找出所有節點的空指標，再將節點的空指標指向其左、右相鄰的節點，即使用引線取代指向 Null 的指標。
引線二元樹的資料結構
 LBit：左控制位元 LChild：左子樹指標 Data：節點資料 RChild：右子樹指標 RBit：右控制位元  引線二元樹會用一個額外的 Bit，以判斷指標內容是 Link 還是 Thread
 LBit = 1, LChild 是正常指標 LBit = 0, LChild 是引線 RBit = 1, RChild 是正常指標 RBit = 0, RChild 是引線  所以在定義引線二元樹的節點類別時，會比一般二元樹多了左、右控制位元兩屬性
/// &lt;summary&gt; /// 引線二元樹節點類別 /// &lt;/summary&gt; public class ThreadNode { public int data; public int lbit; public int rbit; public ThreadNode leftNode; public ThreadNode rightNode; public ThreadNode(int data) { this....</p>
  </section>
  <footer class="entry-footer">August 27, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—引線二元樹（Threaded Binary Tree）" href="https://fakestandard.github.io/algorithm/algorithm-43-threadedbinarytree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元運算樹（Binary Expression Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【6/7 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元樹應用範圍還可包含運算式間的轉換，我們可以把一個四則運算，使用二元樹來表示，再依二元樹的特性進行前中後序的走訪，即二元運算樹（Binary Expression Tree）
書中表示建立方法有以下二種規則
  考慮算術式中運算子的結合性與優先權，再適當地加上括號，其中樹葉一定是運算元，內部節點一定是運算子 再由最內層的括號逐步向外，利用運算子當樹根，左邊運算元當左子樹，右邊運算元當右子樹，其中優先權最低的運算子作為此二元運算樹的樹根   以 ((7&#43;8)/5)*(4&#43;9-3) 運算式為例，先建立二元運算樹
接著分別求出此運算式的前中後序表示法
前序（Prefix） 又稱波蘭表示法（Polish notation），上述例子利用前序走訪表示為 */&#43;785&#43;4-93
中序（Infix） 對於中序表示法而言，運算元是二元樹的葉節點，運算子是非終端節點，其表示法也是一般的運算式。以中序走訪表示為 ((7&#43;8)/5)*(4&#43;9-3)
後序（Postfix） 又稱逆波蘭表示法（Reverse Polish notation），上述例子利用後序走訪表示為 78&#43;5/493-&#43;*
利用鏈結串列實作二元運算樹之運算，先建立節點和二元樹類別
/// &lt;summary&gt; /// 節點類別 /// &lt;/summary&gt; class TreeNode { public int val; public TreeNode leftNode; public TreeNode rightNode; public TreeNode(int val) { this.val = val; this.leftNode = null; this.rightNode = null; } } /// &lt;summary&gt; /// 二元搜尋樹類別 /// &lt;/summary&gt; class BinarySearchTree { public TreeNode root; public BinarySearchTree() { root = null; } public BinarySearchTree(int[] data) { for (int i = 0; i &lt; data....</p>
  </section>
  <footer class="entry-footer">August 23, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元運算樹（Binary Expression Tree）" href="https://fakestandard.github.io/algorithm/algorithm-42-binaryexpressiontree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元排序樹在先前的文章都已經有實作過，一顆符合規定的二元樹，也就是二元排序樹，必須符合以下規則
 第一個輸入的值作為二元樹的樹根 逐一將後續的資料與樹根進行比較，大於樹根的資料放置右子樹，小於樹根的資料放置左子樹，以遞迴的方式進行比較，直到資料找到一個空節點可以放置。  假設有一陣列 12, 46, 10, 23, 11, 30, 7, 21，欲對此陣列建立二元排序樹，先將地一個元素作為樹根
接著取得第二個元素，與樹根作比較，因元素 46 大於樹根 12，故放置於右子樹
繼續取得第三個元素，與樹根作比較，因元素 10 小於樹根 12，故放置於左子樹
取得第四個元素，與樹根作比較，元素 23 大於樹根 12，故放置於右子樹，但右子樹已經存在 46 這個節點，所以繼續將元素 23 與右子樹根節點 46 進行比較，最後元素 23 小於 46，故放置於左子樹中。
使用此方式繼續將所有資料在樹中進行比較，欲到已被佔位的節點，就繼續比較，最後形成一顆二元排序樹。
實作程式碼的部分也相當簡單，先前也實作過很多遍，透過遞迴的方式進行比較，值到有空節點為止。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this....</p>
  </section>
  <footer class="entry-footer">August 20, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元排序樹（Binary Sort Tree）" href="https://fakestandard.github.io/algorithm/algorithm-41-binarysorttree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹插入與刪除節點</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 這篇文章會紀錄節點插入與刪除的原理與應用
節點插入 在二元樹中節點插入非常簡單，利用先前學到的走訪與搜尋，先對二元樹進行走訪搜尋，若搜尋時發現樹中已存在相同值，則節點插入失敗，若樹中沒有找到值，才執行節點插入。
依據先前實作過的樹，逐一建立樹節點類別、二元樹類別，二元樹類別中至少需具有新增節點方法與搜尋節點方法，方能執行節點插入。在類別中額外添加前序走訪方法，供後續輸出二元樹節點使用。
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } /// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array.Length; i&#43;&#43;) AddNode(array[i]); } public void AddNode(int value) { if (root == null) { root = new TreeNode(value); return; } TreeNode current = root; while (true) { if (value &gt; current....</p>
  </section>
  <footer class="entry-footer">August 17, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹插入與刪除節點" href="https://fakestandard.github.io/algorithm/algorithm-40-binarytreeinsertanddelete/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元搜尋樹</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 二元搜尋樹其實就是在樹中搜尋指定的值，只是二元搜尋樹必須符合以下特性
 可以是空集合，若非空集合，則節點上必須有一個鍵值 每個樹根的值須大於左子樹的值 每個樹根的值必須小於右子樹的值 左右子樹也同是二元搜尋樹 樹的每個節點值都不相同  那要如何搜尋？其實很簡單，只需在二元樹中比較樹節點值和欲搜尋的值，依序由左子樹→樹根→右子樹的順序進行走訪，直到找到值或搜尋完畢為止。
實作程式碼，先建立樹節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹類別，下一步實作搜尋方法
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 13, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元搜尋樹" href="https://fakestandard.github.io/algorithm/algorithm-39-binarysearchtree/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【Algorithm】樹的應用—二元樹走訪</h2>
  </header>
  <section class="entry-content">
    <p>【5/28 閱讀紀錄】
根據先前文章介紹的樹，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 對於線性結構的陣列和串列而言，只能執行單向的走訪，如從頭到尾或反向走訪，而二元樹的走訪即是訪問樹中所有節點一次，並且在走訪後，將樹中的資料傳換成線性關係。
二元樹走訪方式有三種，以樹根訪問的順序作為區分，分別是
 前序走訪（Preorder Traversal）：樹根→左子樹→右子樹 中序走訪（Inorder Traversal）：左子樹→樹根→右子樹 後序走訪（Postorder Traversal）：左子樹→右子樹→樹根  從上可以明顯知道，先訪問樹根的稱為前序走訪，後訪問樹根稱為後續走訪，而樹根訪問順序在中間稱為中序走訪，非常的好記。
前序走訪 前序走訪的順序是由上往下進行訪問，從樹根開始，接著往左方移動走訪左子樹，若無法再繼續前進時，則往右方移動訪問右子樹，重複此步驟直到訪問完成。
以上圖為例，訪問的順序是 A→B→D→F→G→H→I→E→C
中序走訪 中序走訪的順序，是從樹根左側開始向下移動，直到無法移動時，追蹤此節點，再往右側移動，若右側無法再移動時，則返回上層父節點，重複左中右的順序進行訪問。
以上圖為例，訪問的順序是 F→D→H→G→I→B→E→A→C
後序走訪 後序走訪的順序，從左子樹開始，接著在往右子樹，最後訪問樹根，因樹根是最後訪問，訪問的方向是由下往上，與前序稍微不同的感覺。
以上圖為例，訪問的順序是 F→H→I→G→D→E→B→C→A
實作程式碼時間，分別為三種走訪方式設計方法，讓以串列表示的二元樹，可以分別輸出前序、中序和後序走訪的結果
建立樹的節點類別
/// &lt;summary&gt; /// 樹節點類別 /// &lt;/summary&gt; class TreeNode { public int data; public TreeNode left; public TreeNode right; public TreeNode(int value) { this.data = value; this.left = null; this.right = null; } } 建立二元樹的類別，其中前序、中序和後續走訪方法在下一步實作
/// &lt;summary&gt; /// 二元樹類別 /// &lt;/summary&gt; class BinaryTree { public TreeNode root; public BinaryTree(int[] array) { for (int i = 0; i &lt; array....</p>
  </section>
  <footer class="entry-footer">August 9, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Polar Bear</footer>
  <a class="entry-link" aria-label="post link to 【Algorithm】樹的應用—二元樹走訪" href="https://fakestandard.github.io/algorithm/algorithm-38-binarytreetraversal/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://fakestandard.github.io/tags/algorithm/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://fakestandard.github.io/">How can I help</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
