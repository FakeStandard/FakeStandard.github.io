<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Queue on How can I help</title>
    <link>https://fakestandard.github.io/tags/queue/</link>
    <description>Recent content in Queue on How can I help</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Sun, 11 Jul 2021 11:02:02 +0800</lastBuildDate><atom:link href="https://fakestandard.github.io/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【Algorithm】佇列應用—陣列實作佇列</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-26-queuearray/</link>
      <pubDate>Sun, 11 Jul 2021 11:02:02 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-26-queuearray/</guid>
      <description>【5/20 閱讀紀錄】
根據先前文章介紹的佇列，此篇實際運用它們實作一個應用。
程式碼已放上 GitHub
Start 利用陣列簡單地時做佇列應用，宣告一個大小為 10 的佇列 queue[10]，設置 front 和 rear 作為頭尾的指標且預設為 -1。
static int front = -1; static int rear = -1; static int max = 10; static int val; static int[] queue = new int[max]; static void Main(string[] args) { int choice = 0; while (rear &amp;lt; max - 1 &amp;amp;&amp;amp; choice != 3) { Write(&amp;#34;請輸入 \n[1] 新增一個資料 \n[2] 取出資料 \n[3] 結束 :&amp;#34;); choice = int.Parse(Console.ReadLine()); switch (choice) { case 1: Write(&amp;#34;請輸入要新增的數值:&amp;#34;); val = int.</description>
    </item>
    
    <item>
      <title>【Algorithm】資料結構—佇列（Queue）</title>
      <link>https://fakestandard.github.io/algorithm/algorithm-6-queue/</link>
      <pubDate>Fri, 21 May 2021 10:54:12 +0800</pubDate>
      
      <guid>https://fakestandard.github.io/algorithm/algorithm-6-queue/</guid>
      <description>【5/16 閱讀紀錄】
選擇適當的資料結構供程式應用，讓演算法發揮最大效能，端看資料結構的選擇。
Start 此篇紀錄記錄佇列定義及應用，其餘常見的資料結構如下
 陣列（Array） 鏈結串列（Linked List） 堆疊（Stack） 佇列（Queue） 樹（Tree） 圖形（Graph） 雜湊表（Hash Table）  佇列（Queue） 佇列是一種抽象型資料結構（Abstract Data Type, ADT），它的所有動作是由不同的兩端執行，並且具有先進先出的特性（First In, First Out: FIFO）。
佇列基本運算具備以下五種工作定義
   Action Description     create 建立空佇列   add 將資料加入佇列的末端，返回新佇列   delete 刪除佇列頂端的資料，返回新佇列   front 傳回佇列頂端的值   empty 判斷佇列是否為空集合，是回傳 Ture，反之    生活中有許多佇列的應用，例如排隊，假設現在有一個排隊買票的隊伍，欲買票就要從隊伍的最後方加入，然而原本在隊伍的第一個人，因為先排隊的關係，它可以先買到票，然後離開隊伍；在排隊的案例可以知道，先排隊的人，可以先買到票，並且從隊伍的頂端離開，後排隊的人，必須從隊伍的尾端加入，當隊伍前面的人都買票離開，才會輪到他買票，而且加入和離開隊伍的動作是從不同的兩端進行，此概念符合了先進先出的特性，也就是佇列的應用。
Note  堆疊（Stack）：後進先出（Last In, First Out: LIFO） 佇列（Queue）：先進先出（First In, First Out: FIFO）  Reference 【圖說演算法 C#】</description>
    </item>
    
  </channel>
</rss>
